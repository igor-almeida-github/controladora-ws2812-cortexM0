
controladora_ws2812_cortexM0.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002a8c  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000058  08002b4c  08002b4c  00012b4c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08002ba4  08002ba4  00020010  2**0
                  CONTENTS
  4 .ARM          00000000  08002ba4  08002ba4  00020010  2**0
                  CONTENTS
  5 .preinit_array 00000000  08002ba4  08002ba4  00020010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08002ba4  08002ba4  00012ba4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08002ba8  08002ba8  00012ba8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20000000  08002bac  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000928  20000010  08002bbc  00020010  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000938  08002bbc  00020938  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
 12 .debug_info   000176cd  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000036f2  00000000  00000000  00037705  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0000ee18  00000000  00000000  0003adf7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000da8  00000000  00000000  00049c10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 000016f0  00000000  00000000  0004a9b8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00010da2  00000000  00000000  0004c0a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00017a9a  00000000  00000000  0005ce4a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000692aa  00000000  00000000  000748e4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000053  00000000  00000000  000ddb8e  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000029e0  00000000  00000000  000ddbe4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000010 	.word	0x20000010
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08002b34 	.word	0x08002b34

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000014 	.word	0x20000014
 8000104:	08002b34 	.word	0x08002b34

08000108 <__gnu_thumb1_case_sqi>:
 8000108:	b402      	push	{r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0049      	lsls	r1, r1, #1
 8000110:	5609      	ldrsb	r1, [r1, r0]
 8000112:	0049      	lsls	r1, r1, #1
 8000114:	448e      	add	lr, r1
 8000116:	bc02      	pop	{r1}
 8000118:	4770      	bx	lr
 800011a:	46c0      	nop			; (mov r8, r8)

0800011c <__gnu_thumb1_case_uqi>:
 800011c:	b402      	push	{r1}
 800011e:	4671      	mov	r1, lr
 8000120:	0849      	lsrs	r1, r1, #1
 8000122:	0049      	lsls	r1, r1, #1
 8000124:	5c09      	ldrb	r1, [r1, r0]
 8000126:	0049      	lsls	r1, r1, #1
 8000128:	448e      	add	lr, r1
 800012a:	bc02      	pop	{r1}
 800012c:	4770      	bx	lr
 800012e:	46c0      	nop			; (mov r8, r8)

08000130 <__udivsi3>:
 8000130:	2200      	movs	r2, #0
 8000132:	0843      	lsrs	r3, r0, #1
 8000134:	428b      	cmp	r3, r1
 8000136:	d374      	bcc.n	8000222 <__udivsi3+0xf2>
 8000138:	0903      	lsrs	r3, r0, #4
 800013a:	428b      	cmp	r3, r1
 800013c:	d35f      	bcc.n	80001fe <__udivsi3+0xce>
 800013e:	0a03      	lsrs	r3, r0, #8
 8000140:	428b      	cmp	r3, r1
 8000142:	d344      	bcc.n	80001ce <__udivsi3+0x9e>
 8000144:	0b03      	lsrs	r3, r0, #12
 8000146:	428b      	cmp	r3, r1
 8000148:	d328      	bcc.n	800019c <__udivsi3+0x6c>
 800014a:	0c03      	lsrs	r3, r0, #16
 800014c:	428b      	cmp	r3, r1
 800014e:	d30d      	bcc.n	800016c <__udivsi3+0x3c>
 8000150:	22ff      	movs	r2, #255	; 0xff
 8000152:	0209      	lsls	r1, r1, #8
 8000154:	ba12      	rev	r2, r2
 8000156:	0c03      	lsrs	r3, r0, #16
 8000158:	428b      	cmp	r3, r1
 800015a:	d302      	bcc.n	8000162 <__udivsi3+0x32>
 800015c:	1212      	asrs	r2, r2, #8
 800015e:	0209      	lsls	r1, r1, #8
 8000160:	d065      	beq.n	800022e <__udivsi3+0xfe>
 8000162:	0b03      	lsrs	r3, r0, #12
 8000164:	428b      	cmp	r3, r1
 8000166:	d319      	bcc.n	800019c <__udivsi3+0x6c>
 8000168:	e000      	b.n	800016c <__udivsi3+0x3c>
 800016a:	0a09      	lsrs	r1, r1, #8
 800016c:	0bc3      	lsrs	r3, r0, #15
 800016e:	428b      	cmp	r3, r1
 8000170:	d301      	bcc.n	8000176 <__udivsi3+0x46>
 8000172:	03cb      	lsls	r3, r1, #15
 8000174:	1ac0      	subs	r0, r0, r3
 8000176:	4152      	adcs	r2, r2
 8000178:	0b83      	lsrs	r3, r0, #14
 800017a:	428b      	cmp	r3, r1
 800017c:	d301      	bcc.n	8000182 <__udivsi3+0x52>
 800017e:	038b      	lsls	r3, r1, #14
 8000180:	1ac0      	subs	r0, r0, r3
 8000182:	4152      	adcs	r2, r2
 8000184:	0b43      	lsrs	r3, r0, #13
 8000186:	428b      	cmp	r3, r1
 8000188:	d301      	bcc.n	800018e <__udivsi3+0x5e>
 800018a:	034b      	lsls	r3, r1, #13
 800018c:	1ac0      	subs	r0, r0, r3
 800018e:	4152      	adcs	r2, r2
 8000190:	0b03      	lsrs	r3, r0, #12
 8000192:	428b      	cmp	r3, r1
 8000194:	d301      	bcc.n	800019a <__udivsi3+0x6a>
 8000196:	030b      	lsls	r3, r1, #12
 8000198:	1ac0      	subs	r0, r0, r3
 800019a:	4152      	adcs	r2, r2
 800019c:	0ac3      	lsrs	r3, r0, #11
 800019e:	428b      	cmp	r3, r1
 80001a0:	d301      	bcc.n	80001a6 <__udivsi3+0x76>
 80001a2:	02cb      	lsls	r3, r1, #11
 80001a4:	1ac0      	subs	r0, r0, r3
 80001a6:	4152      	adcs	r2, r2
 80001a8:	0a83      	lsrs	r3, r0, #10
 80001aa:	428b      	cmp	r3, r1
 80001ac:	d301      	bcc.n	80001b2 <__udivsi3+0x82>
 80001ae:	028b      	lsls	r3, r1, #10
 80001b0:	1ac0      	subs	r0, r0, r3
 80001b2:	4152      	adcs	r2, r2
 80001b4:	0a43      	lsrs	r3, r0, #9
 80001b6:	428b      	cmp	r3, r1
 80001b8:	d301      	bcc.n	80001be <__udivsi3+0x8e>
 80001ba:	024b      	lsls	r3, r1, #9
 80001bc:	1ac0      	subs	r0, r0, r3
 80001be:	4152      	adcs	r2, r2
 80001c0:	0a03      	lsrs	r3, r0, #8
 80001c2:	428b      	cmp	r3, r1
 80001c4:	d301      	bcc.n	80001ca <__udivsi3+0x9a>
 80001c6:	020b      	lsls	r3, r1, #8
 80001c8:	1ac0      	subs	r0, r0, r3
 80001ca:	4152      	adcs	r2, r2
 80001cc:	d2cd      	bcs.n	800016a <__udivsi3+0x3a>
 80001ce:	09c3      	lsrs	r3, r0, #7
 80001d0:	428b      	cmp	r3, r1
 80001d2:	d301      	bcc.n	80001d8 <__udivsi3+0xa8>
 80001d4:	01cb      	lsls	r3, r1, #7
 80001d6:	1ac0      	subs	r0, r0, r3
 80001d8:	4152      	adcs	r2, r2
 80001da:	0983      	lsrs	r3, r0, #6
 80001dc:	428b      	cmp	r3, r1
 80001de:	d301      	bcc.n	80001e4 <__udivsi3+0xb4>
 80001e0:	018b      	lsls	r3, r1, #6
 80001e2:	1ac0      	subs	r0, r0, r3
 80001e4:	4152      	adcs	r2, r2
 80001e6:	0943      	lsrs	r3, r0, #5
 80001e8:	428b      	cmp	r3, r1
 80001ea:	d301      	bcc.n	80001f0 <__udivsi3+0xc0>
 80001ec:	014b      	lsls	r3, r1, #5
 80001ee:	1ac0      	subs	r0, r0, r3
 80001f0:	4152      	adcs	r2, r2
 80001f2:	0903      	lsrs	r3, r0, #4
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d301      	bcc.n	80001fc <__udivsi3+0xcc>
 80001f8:	010b      	lsls	r3, r1, #4
 80001fa:	1ac0      	subs	r0, r0, r3
 80001fc:	4152      	adcs	r2, r2
 80001fe:	08c3      	lsrs	r3, r0, #3
 8000200:	428b      	cmp	r3, r1
 8000202:	d301      	bcc.n	8000208 <__udivsi3+0xd8>
 8000204:	00cb      	lsls	r3, r1, #3
 8000206:	1ac0      	subs	r0, r0, r3
 8000208:	4152      	adcs	r2, r2
 800020a:	0883      	lsrs	r3, r0, #2
 800020c:	428b      	cmp	r3, r1
 800020e:	d301      	bcc.n	8000214 <__udivsi3+0xe4>
 8000210:	008b      	lsls	r3, r1, #2
 8000212:	1ac0      	subs	r0, r0, r3
 8000214:	4152      	adcs	r2, r2
 8000216:	0843      	lsrs	r3, r0, #1
 8000218:	428b      	cmp	r3, r1
 800021a:	d301      	bcc.n	8000220 <__udivsi3+0xf0>
 800021c:	004b      	lsls	r3, r1, #1
 800021e:	1ac0      	subs	r0, r0, r3
 8000220:	4152      	adcs	r2, r2
 8000222:	1a41      	subs	r1, r0, r1
 8000224:	d200      	bcs.n	8000228 <__udivsi3+0xf8>
 8000226:	4601      	mov	r1, r0
 8000228:	4152      	adcs	r2, r2
 800022a:	4610      	mov	r0, r2
 800022c:	4770      	bx	lr
 800022e:	e7ff      	b.n	8000230 <__udivsi3+0x100>
 8000230:	b501      	push	{r0, lr}
 8000232:	2000      	movs	r0, #0
 8000234:	f000 f806 	bl	8000244 <__aeabi_idiv0>
 8000238:	bd02      	pop	{r1, pc}
 800023a:	46c0      	nop			; (mov r8, r8)

0800023c <__aeabi_uidivmod>:
 800023c:	2900      	cmp	r1, #0
 800023e:	d0f7      	beq.n	8000230 <__udivsi3+0x100>
 8000240:	e776      	b.n	8000130 <__udivsi3>
 8000242:	4770      	bx	lr

08000244 <__aeabi_idiv0>:
 8000244:	4770      	bx	lr
 8000246:	46c0      	nop			; (mov r8, r8)

08000248 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000248:	b570      	push	{r4, r5, r6, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800024a:	2610      	movs	r6, #16
{
 800024c:	b090      	sub	sp, #64	; 0x40
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800024e:	221c      	movs	r2, #28
 8000250:	2100      	movs	r1, #0
 8000252:	a805      	add	r0, sp, #20
 8000254:	f002 fc65 	bl	8002b22 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000258:	0032      	movs	r2, r6
 800025a:	2100      	movs	r1, #0
 800025c:	4668      	mov	r0, sp
 800025e:	f002 fc60 	bl	8002b22 <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 8000262:	2280      	movs	r2, #128	; 0x80
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000264:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000266:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000268:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 800026a:	0392      	lsls	r2, r2, #14
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800026c:	a804      	add	r0, sp, #16
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800026e:	9404      	str	r4, [sp, #16]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000270:	9507      	str	r5, [sp, #28]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000272:	9608      	str	r6, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000274:	940c      	str	r4, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000276:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 8000278:	920e      	str	r2, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 800027a:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800027c:	f000 fb96 	bl	80009ac <HAL_RCC_OscConfig>
 8000280:	2800      	cmp	r0, #0
 8000282:	d001      	beq.n	8000288 <SystemClock_Config+0x40>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000284:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000286:	e7fe      	b.n	8000286 <SystemClock_Config+0x3e>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000288:	2307      	movs	r3, #7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800028a:	9002      	str	r0, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800028c:	9003      	str	r0, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800028e:	0029      	movs	r1, r5
 8000290:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000292:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000294:	9401      	str	r4, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000296:	f000 fdbb 	bl	8000e10 <HAL_RCC_ClockConfig>
 800029a:	2800      	cmp	r0, #0
 800029c:	d001      	beq.n	80002a2 <SystemClock_Config+0x5a>
 800029e:	b672      	cpsid	i
  while (1)
 80002a0:	e7fe      	b.n	80002a0 <SystemClock_Config+0x58>
}
 80002a2:	b010      	add	sp, #64	; 0x40
 80002a4:	bd70      	pop	{r4, r5, r6, pc}
	...

080002a8 <main>:
{
 80002a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_Init();
 80002aa:	f000 f9b7 	bl	800061c <HAL_Init>
  SystemClock_Config();
 80002ae:	f7ff ffcb 	bl	8000248 <SystemClock_Config>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80002b2:	2080      	movs	r0, #128	; 0x80
 80002b4:	4b23      	ldr	r3, [pc, #140]	; (8000344 <main+0x9c>)
 80002b6:	0280      	lsls	r0, r0, #10
 80002b8:	6959      	ldr	r1, [r3, #20]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 80002ba:	2402      	movs	r4, #2
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80002bc:	4301      	orrs	r1, r0
 80002be:	6159      	str	r1, [r3, #20]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002c0:	2101      	movs	r1, #1
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80002c2:	695a      	ldr	r2, [r3, #20]
 80002c4:	4002      	ands	r2, r0
 80002c6:	9203      	str	r2, [sp, #12]
 80002c8:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002ca:	695a      	ldr	r2, [r3, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002cc:	200a      	movs	r0, #10
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002ce:	430a      	orrs	r2, r1
 80002d0:	615a      	str	r2, [r3, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002d2:	2200      	movs	r2, #0
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002d4:	695b      	ldr	r3, [r3, #20]
 80002d6:	400b      	ands	r3, r1
 80002d8:	9302      	str	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002da:	0011      	movs	r1, r2
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002dc:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002de:	f000 f9bf 	bl	8000660 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_3_IRQn);
 80002e2:	200a      	movs	r0, #10
 80002e4:	f000 f9e6 	bl	80006b4 <HAL_NVIC_EnableIRQ>
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002e8:	22e0      	movs	r2, #224	; 0xe0
  hspi1.Instance = SPI1;
 80002ea:	4817      	ldr	r0, [pc, #92]	; (8000348 <main+0xa0>)
 80002ec:	4b17      	ldr	r3, [pc, #92]	; (800034c <main+0xa4>)
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002ee:	00d2      	lsls	r2, r2, #3
  hspi1.Instance = SPI1;
 80002f0:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80002f2:	2382      	movs	r3, #130	; 0x82
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002f4:	60c2      	str	r2, [r0, #12]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80002f6:	2280      	movs	r2, #128	; 0x80
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80002f8:	005b      	lsls	r3, r3, #1
 80002fa:	6043      	str	r3, [r0, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80002fc:	2300      	movs	r3, #0
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80002fe:	0092      	lsls	r2, r2, #2
 8000300:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 8000302:	3ae9      	subs	r2, #233	; 0xe9
 8000304:	3aff      	subs	r2, #255	; 0xff
 8000306:	61c2      	str	r2, [r0, #28]
  hspi1.Init.CRCPolynomial = 7;
 8000308:	3a11      	subs	r2, #17
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800030a:	6083      	str	r3, [r0, #8]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 800030c:	6143      	str	r3, [r0, #20]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800030e:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8000310:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000312:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8000314:	6303      	str	r3, [r0, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8000316:	6343      	str	r3, [r0, #52]	; 0x34
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8000318:	6104      	str	r4, [r0, #16]
  hspi1.Init.CRCPolynomial = 7;
 800031a:	62c2      	str	r2, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800031c:	f000 ff14 	bl	8001148 <HAL_SPI_Init>
 8000320:	1e03      	subs	r3, r0, #0
 8000322:	d001      	beq.n	8000328 <main+0x80>
 8000324:	b672      	cpsid	i
  while (1)
 8000326:	e7fe      	b.n	8000326 <main+0x7e>
  status = xTaskCreate(&ws2812_task, "ws2812-task", 50, NULL, 2, &ws2812_task_handle);
 8000328:	4a09      	ldr	r2, [pc, #36]	; (8000350 <main+0xa8>)
 800032a:	490a      	ldr	r1, [pc, #40]	; (8000354 <main+0xac>)
 800032c:	9201      	str	r2, [sp, #4]
 800032e:	480a      	ldr	r0, [pc, #40]	; (8000358 <main+0xb0>)
 8000330:	2232      	movs	r2, #50	; 0x32
 8000332:	9400      	str	r4, [sp, #0]
 8000334:	f001 fcc6 	bl	8001cc4 <xTaskCreate>
  if(status != pdPASS) while(1);  // Traps the code if the above function returns an unexpected status
 8000338:	2801      	cmp	r0, #1
 800033a:	d000      	beq.n	800033e <main+0x96>
 800033c:	e7fe      	b.n	800033c <main+0x94>
  vTaskStartScheduler();
 800033e:	f001 fd97 	bl	8001e70 <vTaskStartScheduler>
  while (1)
 8000342:	e7fe      	b.n	8000342 <main+0x9a>
 8000344:	40021000 	.word	0x40021000
 8000348:	2000076c 	.word	0x2000076c
 800034c:	40013000 	.word	0x40013000
 8000350:	20000768 	.word	0x20000768
 8000354:	08002b4c 	.word	0x08002b4c
 8000358:	08000555 	.word	0x08000555

0800035c <HAL_SPI_TxCpltCallback>:
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi){
 800035c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	xHigherPriorityTaskWoken = pdFALSE;
 800035e:	2100      	movs	r1, #0
	xTaskNotifyFromISR(ws2812_task_handle, 0, eNoAction, &xHigherPriorityTaskWoken);
 8000360:	4809      	ldr	r0, [pc, #36]	; (8000388 <HAL_SPI_TxCpltCallback+0x2c>)
 8000362:	ab03      	add	r3, sp, #12
 8000364:	9301      	str	r3, [sp, #4]
 8000366:	9100      	str	r1, [sp, #0]
 8000368:	000b      	movs	r3, r1
 800036a:	000a      	movs	r2, r1
 800036c:	6800      	ldr	r0, [r0, #0]
	xHigherPriorityTaskWoken = pdFALSE;
 800036e:	9103      	str	r1, [sp, #12]
	xTaskNotifyFromISR(ws2812_task_handle, 0, eNoAction, &xHigherPriorityTaskWoken);
 8000370:	f001 ffe6 	bl	8002340 <xTaskGenericNotifyFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 8000374:	9b03      	ldr	r3, [sp, #12]
 8000376:	2b00      	cmp	r3, #0
 8000378:	d003      	beq.n	8000382 <HAL_SPI_TxCpltCallback+0x26>
 800037a:	2280      	movs	r2, #128	; 0x80
 800037c:	4b03      	ldr	r3, [pc, #12]	; (800038c <HAL_SPI_TxCpltCallback+0x30>)
 800037e:	0552      	lsls	r2, r2, #21
 8000380:	601a      	str	r2, [r3, #0]
}
 8000382:	b005      	add	sp, #20
 8000384:	bd00      	pop	{pc}
 8000386:	46c0      	nop			; (mov r8, r8)
 8000388:	20000768 	.word	0x20000768
 800038c:	e000ed04 	.word	0xe000ed04

08000390 <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM14) {
 8000390:	4b03      	ldr	r3, [pc, #12]	; (80003a0 <HAL_TIM_PeriodElapsedCallback+0x10>)
 8000392:	6802      	ldr	r2, [r0, #0]
{
 8000394:	b510      	push	{r4, lr}
  if (htim->Instance == TIM14) {
 8000396:	429a      	cmp	r2, r3
 8000398:	d101      	bne.n	800039e <HAL_TIM_PeriodElapsedCallback+0xe>
    HAL_IncTick();
 800039a:	f000 f94f 	bl	800063c <HAL_IncTick>
}
 800039e:	bd10      	pop	{r4, pc}
 80003a0:	40002000 	.word	0x40002000

080003a4 <Error_Handler>:
 80003a4:	b672      	cpsid	i
  while (1)
 80003a6:	e7fe      	b.n	80003a6 <Error_Handler+0x2>

080003a8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003a8:	2001      	movs	r0, #1
 80003aa:	4b0a      	ldr	r3, [pc, #40]	; (80003d4 <HAL_MspInit+0x2c>)
{
 80003ac:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003ae:	6999      	ldr	r1, [r3, #24]
 80003b0:	4301      	orrs	r1, r0
 80003b2:	6199      	str	r1, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 80003b4:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003b6:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 80003b8:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003ba:	4002      	ands	r2, r0
 80003bc:	9200      	str	r2, [sp, #0]
 80003be:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80003c0:	69da      	ldr	r2, [r3, #28]
 80003c2:	430a      	orrs	r2, r1
 80003c4:	61da      	str	r2, [r3, #28]
 80003c6:	69db      	ldr	r3, [r3, #28]
 80003c8:	400b      	ands	r3, r1
 80003ca:	9301      	str	r3, [sp, #4]
 80003cc:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80003ce:	b002      	add	sp, #8
 80003d0:	4770      	bx	lr
 80003d2:	46c0      	nop			; (mov r8, r8)
 80003d4:	40021000 	.word	0x40021000

080003d8 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80003d8:	b570      	push	{r4, r5, r6, lr}
 80003da:	0006      	movs	r6, r0
 80003dc:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80003de:	2214      	movs	r2, #20
 80003e0:	2100      	movs	r1, #0
 80003e2:	a803      	add	r0, sp, #12
 80003e4:	f002 fb9d 	bl	8002b22 <memset>
  if(hspi->Instance==SPI1)
 80003e8:	4b1d      	ldr	r3, [pc, #116]	; (8000460 <HAL_SPI_MspInit+0x88>)
 80003ea:	6832      	ldr	r2, [r6, #0]
 80003ec:	429a      	cmp	r2, r3
 80003ee:	d135      	bne.n	800045c <HAL_SPI_MspInit+0x84>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003f0:	2080      	movs	r0, #128	; 0x80
 80003f2:	4b1c      	ldr	r3, [pc, #112]	; (8000464 <HAL_SPI_MspInit+0x8c>)
 80003f4:	0140      	lsls	r0, r0, #5
 80003f6:	6999      	ldr	r1, [r3, #24]
    PA5     ------> SPI1_SCK
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003f8:	2500      	movs	r5, #0
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003fa:	4301      	orrs	r1, r0
 80003fc:	6199      	str	r1, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003fe:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000400:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000402:	0289      	lsls	r1, r1, #10
    __HAL_RCC_SPI1_CLK_ENABLE();
 8000404:	4002      	ands	r2, r0
 8000406:	9201      	str	r2, [sp, #4]
 8000408:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800040a:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800040c:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800040e:	430a      	orrs	r2, r1
 8000410:	615a      	str	r2, [r3, #20]
 8000412:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000414:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000416:	400b      	ands	r3, r1
 8000418:	9302      	str	r3, [sp, #8]
 800041a:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 800041c:	23a0      	movs	r3, #160	; 0xa0
 800041e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000420:	3b9e      	subs	r3, #158	; 0x9e
 8000422:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000424:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000426:	3301      	adds	r3, #1
 8000428:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800042a:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
 800042c:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800042e:	f000 fa07 	bl	8000840 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Channel3;
 8000432:	4c0d      	ldr	r4, [pc, #52]	; (8000468 <HAL_SPI_MspInit+0x90>)
 8000434:	4b0d      	ldr	r3, [pc, #52]	; (800046c <HAL_SPI_MspInit+0x94>)
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8000436:	0020      	movs	r0, r4
    hdma_spi1_tx.Instance = DMA1_Channel3;
 8000438:	6023      	str	r3, [r4, #0]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800043a:	2310      	movs	r3, #16
 800043c:	6063      	str	r3, [r4, #4]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 800043e:	3370      	adds	r3, #112	; 0x70
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8000440:	60a5      	str	r5, [r4, #8]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8000442:	60e3      	str	r3, [r4, #12]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8000444:	6125      	str	r5, [r4, #16]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8000446:	6165      	str	r5, [r4, #20]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 8000448:	61a5      	str	r5, [r4, #24]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 800044a:	61e5      	str	r5, [r4, #28]
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 800044c:	f000 f93e 	bl	80006cc <HAL_DMA_Init>
 8000450:	42a8      	cmp	r0, r5
 8000452:	d001      	beq.n	8000458 <HAL_SPI_MspInit+0x80>
    {
      Error_Handler();
 8000454:	f7ff ffa6 	bl	80003a4 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 8000458:	6574      	str	r4, [r6, #84]	; 0x54
 800045a:	6266      	str	r6, [r4, #36]	; 0x24
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 800045c:	b008      	add	sp, #32
 800045e:	bd70      	pop	{r4, r5, r6, pc}
 8000460:	40013000 	.word	0x40013000
 8000464:	40021000 	.word	0x40021000
 8000468:	200007d0 	.word	0x200007d0
 800046c:	40020030 	.word	0x40020030

08000470 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000470:	b510      	push	{r4, lr}
 8000472:	0001      	movs	r1, r0
 8000474:	b086      	sub	sp, #24
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM14 IRQ priority */
  HAL_NVIC_SetPriority(TIM14_IRQn, TickPriority ,0);
 8000476:	2200      	movs	r2, #0
 8000478:	2013      	movs	r0, #19
 800047a:	f000 f8f1 	bl	8000660 <HAL_NVIC_SetPriority>

  /* Enable the TIM14 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM14_IRQn);
 800047e:	2013      	movs	r0, #19
 8000480:	f000 f918 	bl	80006b4 <HAL_NVIC_EnableIRQ>
  /* Enable TIM14 clock */
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000484:	2080      	movs	r0, #128	; 0x80
 8000486:	4a14      	ldr	r2, [pc, #80]	; (80004d8 <HAL_InitTick+0x68>)
 8000488:	0040      	lsls	r0, r0, #1
 800048a:	69d1      	ldr	r1, [r2, #28]
 800048c:	4301      	orrs	r1, r0
 800048e:	61d1      	str	r1, [r2, #28]
 8000490:	69d3      	ldr	r3, [r2, #28]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000492:	4669      	mov	r1, sp
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000494:	4003      	ands	r3, r0
 8000496:	9301      	str	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000498:	a802      	add	r0, sp, #8
  __HAL_RCC_TIM14_CLK_ENABLE();
 800049a:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800049c:	f000 fd4c 	bl	8000f38 <HAL_RCC_GetClockConfig>

  /* Compute TIM14 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 80004a0:	f000 fd3a 	bl	8000f18 <HAL_RCC_GetPCLK1Freq>
  /* Compute the prescaler value to have TIM14 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM14 */
  htim14.Instance = TIM14;
 80004a4:	4c0d      	ldr	r4, [pc, #52]	; (80004dc <HAL_InitTick+0x6c>)
 80004a6:	4b0e      	ldr	r3, [pc, #56]	; (80004e0 <HAL_InitTick+0x70>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80004a8:	490e      	ldr	r1, [pc, #56]	; (80004e4 <HAL_InitTick+0x74>)
  htim14.Instance = TIM14;
 80004aa:	6023      	str	r3, [r4, #0]
  + Period = [(TIM14CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim14.Init.Period = (1000000U / 1000U) - 1U;
 80004ac:	4b0e      	ldr	r3, [pc, #56]	; (80004e8 <HAL_InitTick+0x78>)
 80004ae:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80004b0:	f7ff fe3e 	bl	8000130 <__udivsi3>
  htim14.Init.Prescaler = uwPrescalerValue;
  htim14.Init.ClockDivision = 0;
 80004b4:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80004b6:	3801      	subs	r0, #1
  htim14.Init.Prescaler = uwPrescalerValue;
 80004b8:	6060      	str	r0, [r4, #4]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 80004ba:	0020      	movs	r0, r4
  htim14.Init.ClockDivision = 0;
 80004bc:	6123      	str	r3, [r4, #16]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 80004be:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 80004c0:	f001 f8a8 	bl	8001614 <HAL_TIM_Base_Init>
 80004c4:	0003      	movs	r3, r0
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim14);
  }

  /* Return function status */
  return HAL_ERROR;
 80004c6:	2001      	movs	r0, #1
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 80004c8:	2b00      	cmp	r3, #0
 80004ca:	d102      	bne.n	80004d2 <HAL_InitTick+0x62>
    return HAL_TIM_Base_Start_IT(&htim14);
 80004cc:	0020      	movs	r0, r4
 80004ce:	f000 ff91 	bl	80013f4 <HAL_TIM_Base_Start_IT>
}
 80004d2:	b006      	add	sp, #24
 80004d4:	bd10      	pop	{r4, pc}
 80004d6:	46c0      	nop			; (mov r8, r8)
 80004d8:	40021000 	.word	0x40021000
 80004dc:	20000814 	.word	0x20000814
 80004e0:	40002000 	.word	0x40002000
 80004e4:	000f4240 	.word	0x000f4240
 80004e8:	000003e7 	.word	0x000003e7

080004ec <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80004ec:	e7fe      	b.n	80004ec <NMI_Handler>

080004ee <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80004ee:	e7fe      	b.n	80004ee <HardFault_Handler>

080004f0 <DMA1_Channel2_3_IRQHandler>:

/**
  * @brief This function handles DMA1 channel 2 and 3 interrupts.
  */
void DMA1_Channel2_3_IRQHandler(void)
{
 80004f0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 0 */

  /* USER CODE END DMA1_Channel2_3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 80004f2:	4802      	ldr	r0, [pc, #8]	; (80004fc <DMA1_Channel2_3_IRQHandler+0xc>)
 80004f4:	f000 f95a 	bl	80007ac <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 1 */

  /* USER CODE END DMA1_Channel2_3_IRQn 1 */
}
 80004f8:	bd10      	pop	{r4, pc}
 80004fa:	46c0      	nop			; (mov r8, r8)
 80004fc:	200007d0 	.word	0x200007d0

08000500 <TIM14_IRQHandler>:

/**
  * @brief This function handles TIM14 global interrupt.
  */
void TIM14_IRQHandler(void)
{
 8000500:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM14_IRQn 0 */

  /* USER CODE END TIM14_IRQn 0 */
  HAL_TIM_IRQHandler(&htim14);
 8000502:	4802      	ldr	r0, [pc, #8]	; (800050c <TIM14_IRQHandler+0xc>)
 8000504:	f000 ffa2 	bl	800144c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM14_IRQn 1 */

  /* USER CODE END TIM14_IRQn 1 */
}
 8000508:	bd10      	pop	{r4, pc}
 800050a:	46c0      	nop			; (mov r8, r8)
 800050c:	20000814 	.word	0x20000814

08000510 <SystemInit>:
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 8000510:	4770      	bx	lr
	...

08000514 <ws2812_write_byte_SPI_DMA.constprop.0>:
 * @brief This function sends 1 byte of data to the led strip using SPI and DMA
 * @note
 * @param
 * @retval
 */
static void ws2812_write_byte_SPI_DMA(uint8_t ws2812_led_byte){
 8000514:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000516:	2300      	movs	r3, #0

	/* Iterate over the ws2812_led_byte (bit by bit) starting from the MSb */
	for (int8_t bit_position=7; bit_position>=0; bit_position--){

		/* Get the bit value */
		ws2812_led_bit = (ws2812_led_byte >> bit_position) & 1;
 8000518:	2107      	movs	r1, #7
static void ws2812_write_byte_SPI_DMA(uint8_t ws2812_led_byte){
 800051a:	001a      	movs	r2, r3
		ws2812_led_bit = (ws2812_led_byte >> bit_position) & 1;
 800051c:	468c      	mov	ip, r1
 800051e:	25ff      	movs	r5, #255	; 0xff
 8000520:	2601      	movs	r6, #1
			/* Bit 1 */
			ws2812_led_byte_adapted_SPI |= ((uint32_t)0b1100) << (28 - 4 * bit_position);
		}
		else{
			/* Bit 0 */
			ws2812_led_byte_adapted_SPI |= ((uint32_t)0b1000) << (28 - 4 * bit_position);
 8000522:	2708      	movs	r7, #8
		ws2812_led_bit = (ws2812_led_byte >> bit_position) & 1;
 8000524:	4661      	mov	r1, ip
 8000526:	002c      	movs	r4, r5
 8000528:	1ac9      	subs	r1, r1, r3
 800052a:	410c      	asrs	r4, r1
 800052c:	0098      	lsls	r0, r3, #2
		if(ws2812_led_bit == 1){
 800052e:	4234      	tst	r4, r6
 8000530:	d00c      	beq.n	800054c <ws2812_write_byte_SPI_DMA.constprop.0+0x38>
			ws2812_led_byte_adapted_SPI |= ((uint32_t)0b1100) << (28 - 4 * bit_position);
 8000532:	210c      	movs	r1, #12
			ws2812_led_byte_adapted_SPI |= ((uint32_t)0b1000) << (28 - 4 * bit_position);
 8000534:	4081      	lsls	r1, r0
 8000536:	3301      	adds	r3, #1
 8000538:	430a      	orrs	r2, r1
	for (int8_t bit_position=7; bit_position>=0; bit_position--){
 800053a:	2b08      	cmp	r3, #8
 800053c:	d1f2      	bne.n	8000524 <ws2812_write_byte_SPI_DMA.constprop.0+0x10>
 800053e:	9201      	str	r2, [sp, #4]
		}
	}


	HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)&ws2812_led_byte_adapted_SPI, 4);
 8000540:	a901      	add	r1, sp, #4
 8000542:	2204      	movs	r2, #4
 8000544:	4802      	ldr	r0, [pc, #8]	; (8000550 <ws2812_write_byte_SPI_DMA.constprop.0+0x3c>)
 8000546:	f000 fe77 	bl	8001238 <HAL_SPI_Transmit_DMA>
}
 800054a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
			ws2812_led_byte_adapted_SPI |= ((uint32_t)0b1000) << (28 - 4 * bit_position);
 800054c:	0039      	movs	r1, r7
 800054e:	e7f1      	b.n	8000534 <ws2812_write_byte_SPI_DMA.constprop.0+0x20>
 8000550:	2000076c 	.word	0x2000076c

08000554 <ws2812_task>:
void ws2812_task(void *parameters){
 8000554:	b537      	push	{r0, r1, r2, r4, r5, lr}
	for(int i=0; i<150; i++){
 8000556:	2400      	movs	r4, #0
		sq[i] = 0;
 8000558:	0022      	movs	r2, r4
 800055a:	4919      	ldr	r1, [pc, #100]	; (80005c0 <ws2812_task+0x6c>)
 800055c:	1863      	adds	r3, r4, r1
	for(int i=0; i<150; i++){
 800055e:	3401      	adds	r4, #1
		sq[i] = 0;
 8000560:	701a      	strb	r2, [r3, #0]
	for(int i=0; i<150; i++){
 8000562:	2c96      	cmp	r4, #150	; 0x96
 8000564:	d1fa      	bne.n	800055c <ws2812_task+0x8>
	HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)sq, 150);
 8000566:	0022      	movs	r2, r4
 8000568:	4816      	ldr	r0, [pc, #88]	; (80005c4 <ws2812_task+0x70>)
 800056a:	f000 fe65 	bl	8001238 <HAL_SPI_Transmit_DMA>
	xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(10));
 800056e:	250a      	movs	r5, #10
 8000570:	2300      	movs	r3, #0
 8000572:	9500      	str	r5, [sp, #0]
 8000574:	001a      	movs	r2, r3
 8000576:	0019      	movs	r1, r3
 8000578:	0018      	movs	r0, r3
 800057a:	f001 fea3 	bl	80022c4 <xTaskGenericNotifyWait>
		ws2812_write_byte_SPI_DMA(255);
 800057e:	f7ff ffc9 	bl	8000514 <ws2812_write_byte_SPI_DMA.constprop.0>
		xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(10));
 8000582:	2300      	movs	r3, #0
 8000584:	9500      	str	r5, [sp, #0]
 8000586:	001a      	movs	r2, r3
 8000588:	0019      	movs	r1, r3
 800058a:	0018      	movs	r0, r3
 800058c:	f001 fe9a 	bl	80022c4 <xTaskGenericNotifyWait>
		ws2812_write_byte_SPI_DMA(255);
 8000590:	f7ff ffc0 	bl	8000514 <ws2812_write_byte_SPI_DMA.constprop.0>
		xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(10));
 8000594:	2300      	movs	r3, #0
 8000596:	9500      	str	r5, [sp, #0]
 8000598:	001a      	movs	r2, r3
 800059a:	0019      	movs	r1, r3
 800059c:	0018      	movs	r0, r3
 800059e:	f001 fe91 	bl	80022c4 <xTaskGenericNotifyWait>
		ws2812_write_byte_SPI_DMA(255);
 80005a2:	f7ff ffb7 	bl	8000514 <ws2812_write_byte_SPI_DMA.constprop.0>
		xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(10));
 80005a6:	2300      	movs	r3, #0
 80005a8:	3c01      	subs	r4, #1
 80005aa:	001a      	movs	r2, r3
 80005ac:	0019      	movs	r1, r3
 80005ae:	0018      	movs	r0, r3
 80005b0:	9500      	str	r5, [sp, #0]
 80005b2:	b2e4      	uxtb	r4, r4
 80005b4:	f001 fe86 	bl	80022c4 <xTaskGenericNotifyWait>
	for(uint8_t led_number=0; led_number<150; led_number++){
 80005b8:	2c00      	cmp	r4, #0
 80005ba:	d1e0      	bne.n	800057e <ws2812_task+0x2a>
	while(1){
 80005bc:	e7fe      	b.n	80005bc <ws2812_task+0x68>
 80005be:	46c0      	nop			; (mov r8, r8)
 80005c0:	2000085c 	.word	0x2000085c
 80005c4:	2000076c 	.word	0x2000076c

080005c8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80005c8:	480d      	ldr	r0, [pc, #52]	; (8000600 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80005ca:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80005cc:	480d      	ldr	r0, [pc, #52]	; (8000604 <LoopForever+0x6>)
  ldr r1, =_edata
 80005ce:	490e      	ldr	r1, [pc, #56]	; (8000608 <LoopForever+0xa>)
  ldr r2, =_sidata
 80005d0:	4a0e      	ldr	r2, [pc, #56]	; (800060c <LoopForever+0xe>)
  movs r3, #0
 80005d2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80005d4:	e002      	b.n	80005dc <LoopCopyDataInit>

080005d6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80005d6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80005d8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80005da:	3304      	adds	r3, #4

080005dc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80005dc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80005de:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80005e0:	d3f9      	bcc.n	80005d6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80005e2:	4a0b      	ldr	r2, [pc, #44]	; (8000610 <LoopForever+0x12>)
  ldr r4, =_ebss
 80005e4:	4c0b      	ldr	r4, [pc, #44]	; (8000614 <LoopForever+0x16>)
  movs r3, #0
 80005e6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80005e8:	e001      	b.n	80005ee <LoopFillZerobss>

080005ea <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80005ea:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80005ec:	3204      	adds	r2, #4

080005ee <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80005ee:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80005f0:	d3fb      	bcc.n	80005ea <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80005f2:	f7ff ff8d 	bl	8000510 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 80005f6:	f002 fa67 	bl	8002ac8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80005fa:	f7ff fe55 	bl	80002a8 <main>

080005fe <LoopForever>:

LoopForever:
    b LoopForever
 80005fe:	e7fe      	b.n	80005fe <LoopForever>
  ldr   r0, =_estack
 8000600:	20001000 	.word	0x20001000
  ldr r0, =_sdata
 8000604:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000608:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 800060c:	08002bac 	.word	0x08002bac
  ldr r2, =_sbss
 8000610:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 8000614:	20000938 	.word	0x20000938

08000618 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000618:	e7fe      	b.n	8000618 <ADC1_IRQHandler>
	...

0800061c <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800061c:	2310      	movs	r3, #16
 800061e:	4a06      	ldr	r2, [pc, #24]	; (8000638 <HAL_Init+0x1c>)
{
 8000620:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000622:	6811      	ldr	r1, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 8000624:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000626:	430b      	orrs	r3, r1
 8000628:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 800062a:	f7ff ff21 	bl	8000470 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800062e:	f7ff febb 	bl	80003a8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000632:	2000      	movs	r0, #0
 8000634:	bd10      	pop	{r4, pc}
 8000636:	46c0      	nop			; (mov r8, r8)
 8000638:	40022000 	.word	0x40022000

0800063c <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800063c:	4a03      	ldr	r2, [pc, #12]	; (800064c <HAL_IncTick+0x10>)
 800063e:	4b04      	ldr	r3, [pc, #16]	; (8000650 <HAL_IncTick+0x14>)
 8000640:	6811      	ldr	r1, [r2, #0]
 8000642:	781b      	ldrb	r3, [r3, #0]
 8000644:	185b      	adds	r3, r3, r1
 8000646:	6013      	str	r3, [r2, #0]
}
 8000648:	4770      	bx	lr
 800064a:	46c0      	nop			; (mov r8, r8)
 800064c:	200008f4 	.word	0x200008f4
 8000650:	20000004 	.word	0x20000004

08000654 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000654:	4b01      	ldr	r3, [pc, #4]	; (800065c <HAL_GetTick+0x8>)
 8000656:	6818      	ldr	r0, [r3, #0]
}
 8000658:	4770      	bx	lr
 800065a:	46c0      	nop			; (mov r8, r8)
 800065c:	200008f4 	.word	0x200008f4

08000660 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000660:	b530      	push	{r4, r5, lr}
 8000662:	25ff      	movs	r5, #255	; 0xff
 8000664:	2403      	movs	r4, #3
 8000666:	002a      	movs	r2, r5
 8000668:	4004      	ands	r4, r0
 800066a:	00e4      	lsls	r4, r4, #3
 800066c:	40a2      	lsls	r2, r4
 800066e:	0189      	lsls	r1, r1, #6
 8000670:	4029      	ands	r1, r5
 8000672:	43d2      	mvns	r2, r2
 8000674:	40a1      	lsls	r1, r4
 8000676:	b2c3      	uxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8000678:	2800      	cmp	r0, #0
 800067a:	db0a      	blt.n	8000692 <HAL_NVIC_SetPriority+0x32>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800067c:	24c0      	movs	r4, #192	; 0xc0
 800067e:	4b0b      	ldr	r3, [pc, #44]	; (80006ac <HAL_NVIC_SetPriority+0x4c>)
 8000680:	0880      	lsrs	r0, r0, #2
 8000682:	0080      	lsls	r0, r0, #2
 8000684:	18c0      	adds	r0, r0, r3
 8000686:	00a4      	lsls	r4, r4, #2
 8000688:	5903      	ldr	r3, [r0, r4]
 800068a:	401a      	ands	r2, r3
 800068c:	4311      	orrs	r1, r2
 800068e:	5101      	str	r1, [r0, r4]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8000690:	bd30      	pop	{r4, r5, pc}
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000692:	200f      	movs	r0, #15
 8000694:	4003      	ands	r3, r0
 8000696:	3b08      	subs	r3, #8
 8000698:	4805      	ldr	r0, [pc, #20]	; (80006b0 <HAL_NVIC_SetPriority+0x50>)
 800069a:	089b      	lsrs	r3, r3, #2
 800069c:	009b      	lsls	r3, r3, #2
 800069e:	181b      	adds	r3, r3, r0
 80006a0:	69d8      	ldr	r0, [r3, #28]
 80006a2:	4002      	ands	r2, r0
 80006a4:	4311      	orrs	r1, r2
 80006a6:	61d9      	str	r1, [r3, #28]
 80006a8:	e7f2      	b.n	8000690 <HAL_NVIC_SetPriority+0x30>
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	e000e100 	.word	0xe000e100
 80006b0:	e000ed00 	.word	0xe000ed00

080006b4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80006b4:	2800      	cmp	r0, #0
 80006b6:	db05      	blt.n	80006c4 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80006b8:	231f      	movs	r3, #31
 80006ba:	4018      	ands	r0, r3
 80006bc:	3b1e      	subs	r3, #30
 80006be:	4083      	lsls	r3, r0
 80006c0:	4a01      	ldr	r2, [pc, #4]	; (80006c8 <HAL_NVIC_EnableIRQ+0x14>)
 80006c2:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80006c4:	4770      	bx	lr
 80006c6:	46c0      	nop			; (mov r8, r8)
 80006c8:	e000e100 	.word	0xe000e100

080006cc <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 80006cc:	b570      	push	{r4, r5, r6, lr}
 80006ce:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 80006d0:	2001      	movs	r0, #1
  if(NULL == hdma)
 80006d2:	2c00      	cmp	r4, #0
 80006d4:	d024      	beq.n	8000720 <HAL_DMA_Init+0x54>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80006d6:	2302      	movs	r3, #2
 80006d8:	1ca5      	adds	r5, r4, #2
 80006da:	77eb      	strb	r3, [r5, #31]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 80006dc:	6820      	ldr	r0, [r4, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80006de:	4b11      	ldr	r3, [pc, #68]	; (8000724 <HAL_DMA_Init+0x58>)
  tmp = hdma->Instance->CCR;
 80006e0:	6802      	ldr	r2, [r0, #0]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 80006e2:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80006e4:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 80006e6:	6863      	ldr	r3, [r4, #4]
 80006e8:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80006ea:	68e1      	ldr	r1, [r4, #12]
 80006ec:	430b      	orrs	r3, r1
 80006ee:	6921      	ldr	r1, [r4, #16]
 80006f0:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80006f2:	6961      	ldr	r1, [r4, #20]
 80006f4:	430b      	orrs	r3, r1
 80006f6:	69a1      	ldr	r1, [r4, #24]
 80006f8:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 80006fa:	69e1      	ldr	r1, [r4, #28]
 80006fc:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 80006fe:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8000700:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8000702:	4b09      	ldr	r3, [pc, #36]	; (8000728 <HAL_DMA_Init+0x5c>)
 8000704:	2114      	movs	r1, #20
 8000706:	18c0      	adds	r0, r0, r3
 8000708:	f7ff fd12 	bl	8000130 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 800070c:	4b07      	ldr	r3, [pc, #28]	; (800072c <HAL_DMA_Init+0x60>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800070e:	0080      	lsls	r0, r0, #2
 8000710:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 8000712:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000714:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8000716:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000718:	63a0      	str	r0, [r4, #56]	; 0x38
  hdma->Lock = HAL_UNLOCKED;
 800071a:	18e4      	adds	r4, r4, r3
  hdma->State = HAL_DMA_STATE_READY;
 800071c:	77eb      	strb	r3, [r5, #31]
  hdma->Lock = HAL_UNLOCKED;
 800071e:	77e0      	strb	r0, [r4, #31]
}  
 8000720:	bd70      	pop	{r4, r5, r6, pc}
 8000722:	46c0      	nop			; (mov r8, r8)
 8000724:	ffffc00f 	.word	0xffffc00f
 8000728:	bffdfff8 	.word	0xbffdfff8
 800072c:	40020000 	.word	0x40020000

08000730 <HAL_DMA_Start_IT>:
{
 8000730:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 8000732:	1c45      	adds	r5, r0, #1
{
 8000734:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hdma);
 8000736:	7feb      	ldrb	r3, [r5, #31]
{
 8000738:	0004      	movs	r4, r0
  __HAL_LOCK(hdma);
 800073a:	2002      	movs	r0, #2
 800073c:	2b01      	cmp	r3, #1
 800073e:	d027      	beq.n	8000790 <HAL_DMA_Start_IT+0x60>
 8000740:	2301      	movs	r3, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8000742:	1827      	adds	r7, r4, r0
  __HAL_LOCK(hdma);
 8000744:	77eb      	strb	r3, [r5, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8000746:	7ffb      	ldrb	r3, [r7, #31]
 8000748:	2600      	movs	r6, #0
 800074a:	469c      	mov	ip, r3
 800074c:	4660      	mov	r0, ip
 800074e:	b2db      	uxtb	r3, r3
 8000750:	2801      	cmp	r0, #1
 8000752:	d128      	bne.n	80007a6 <HAL_DMA_Start_IT+0x76>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8000754:	3001      	adds	r0, #1
 8000756:	77f8      	strb	r0, [r7, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000758:	6820      	ldr	r0, [r4, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800075a:	63a6      	str	r6, [r4, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800075c:	6805      	ldr	r5, [r0, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800075e:	6c26      	ldr	r6, [r4, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000760:	439d      	bics	r5, r3
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8000762:	40b3      	lsls	r3, r6
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000764:	6005      	str	r5, [r0, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8000766:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8000768:	606b      	str	r3, [r5, #4]
  hdma->Instance->CNDTR = DataLength;
 800076a:	9b01      	ldr	r3, [sp, #4]
 800076c:	6043      	str	r3, [r0, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800076e:	6863      	ldr	r3, [r4, #4]
 8000770:	2b10      	cmp	r3, #16
 8000772:	d10e      	bne.n	8000792 <HAL_DMA_Start_IT+0x62>
    hdma->Instance->CPAR = DstAddress;
 8000774:	6082      	str	r2, [r0, #8]
    hdma->Instance->CMAR = SrcAddress;
 8000776:	60c1      	str	r1, [r0, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8000778:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800077a:	6802      	ldr	r2, [r0, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 800077c:	2b00      	cmp	r3, #0
 800077e:	d00b      	beq.n	8000798 <HAL_DMA_Start_IT+0x68>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8000780:	230e      	movs	r3, #14
 8000782:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8000784:	6003      	str	r3, [r0, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8000786:	2301      	movs	r3, #1
 8000788:	6802      	ldr	r2, [r0, #0]
 800078a:	4313      	orrs	r3, r2
 800078c:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 800078e:	2000      	movs	r0, #0
} 
 8000790:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 8000792:	6081      	str	r1, [r0, #8]
    hdma->Instance->CMAR = DstAddress;
 8000794:	60c2      	str	r2, [r0, #12]
 8000796:	e7ef      	b.n	8000778 <HAL_DMA_Start_IT+0x48>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8000798:	230a      	movs	r3, #10
 800079a:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800079c:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 800079e:	6003      	str	r3, [r0, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80007a0:	6803      	ldr	r3, [r0, #0]
 80007a2:	4393      	bics	r3, r2
 80007a4:	e7ee      	b.n	8000784 <HAL_DMA_Start_IT+0x54>
    status = HAL_BUSY;
 80007a6:	2002      	movs	r0, #2
    __HAL_UNLOCK(hdma); 
 80007a8:	77ee      	strb	r6, [r5, #31]
    status = HAL_BUSY;
 80007aa:	e7f1      	b.n	8000790 <HAL_DMA_Start_IT+0x60>

080007ac <HAL_DMA_IRQHandler>:
{
 80007ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80007ae:	2704      	movs	r7, #4
 80007b0:	003e      	movs	r6, r7
 80007b2:	6c01      	ldr	r1, [r0, #64]	; 0x40
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80007b4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80007b6:	408e      	lsls	r6, r1
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80007b8:	6815      	ldr	r5, [r2, #0]
  uint32_t source_it = hdma->Instance->CCR;
 80007ba:	6803      	ldr	r3, [r0, #0]
 80007bc:	681c      	ldr	r4, [r3, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80007be:	4235      	tst	r5, r6
 80007c0:	d00d      	beq.n	80007de <HAL_DMA_IRQHandler+0x32>
 80007c2:	423c      	tst	r4, r7
 80007c4:	d00b      	beq.n	80007de <HAL_DMA_IRQHandler+0x32>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80007c6:	6819      	ldr	r1, [r3, #0]
 80007c8:	0689      	lsls	r1, r1, #26
 80007ca:	d402      	bmi.n	80007d2 <HAL_DMA_IRQHandler+0x26>
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80007cc:	6819      	ldr	r1, [r3, #0]
 80007ce:	43b9      	bics	r1, r7
 80007d0:	6019      	str	r1, [r3, #0]
  	if(hdma->XferHalfCpltCallback != NULL)
 80007d2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
 80007d4:	6056      	str	r6, [r2, #4]
  	if(hdma->XferHalfCpltCallback != NULL)
 80007d6:	2b00      	cmp	r3, #0
 80007d8:	d019      	beq.n	800080e <HAL_DMA_IRQHandler+0x62>
    	hdma->XferErrorCallback(hdma);
 80007da:	4798      	blx	r3
}  
 80007dc:	e017      	b.n	800080e <HAL_DMA_IRQHandler+0x62>
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 80007de:	2702      	movs	r7, #2
 80007e0:	003e      	movs	r6, r7
 80007e2:	408e      	lsls	r6, r1
 80007e4:	4235      	tst	r5, r6
 80007e6:	d013      	beq.n	8000810 <HAL_DMA_IRQHandler+0x64>
 80007e8:	423c      	tst	r4, r7
 80007ea:	d011      	beq.n	8000810 <HAL_DMA_IRQHandler+0x64>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80007ec:	6819      	ldr	r1, [r3, #0]
 80007ee:	0689      	lsls	r1, r1, #26
 80007f0:	d406      	bmi.n	8000800 <HAL_DMA_IRQHandler+0x54>
  		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
 80007f2:	240a      	movs	r4, #10
 80007f4:	6819      	ldr	r1, [r3, #0]
 80007f6:	43a1      	bics	r1, r4
 80007f8:	6019      	str	r1, [r3, #0]
  		hdma->State = HAL_DMA_STATE_READY;
 80007fa:	2101      	movs	r1, #1
 80007fc:	19c3      	adds	r3, r0, r7
 80007fe:	77d9      	strb	r1, [r3, #31]
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
 8000800:	6056      	str	r6, [r2, #4]
  	__HAL_UNLOCK(hdma);
 8000802:	2200      	movs	r2, #0
 8000804:	1c43      	adds	r3, r0, #1
 8000806:	77da      	strb	r2, [r3, #31]
  	if(hdma->XferCpltCallback != NULL)
 8000808:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(hdma->XferErrorCallback != NULL)
 800080a:	4293      	cmp	r3, r2
 800080c:	d1e5      	bne.n	80007da <HAL_DMA_IRQHandler+0x2e>
}  
 800080e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8000810:	2608      	movs	r6, #8
 8000812:	0037      	movs	r7, r6
 8000814:	408f      	lsls	r7, r1
 8000816:	423d      	tst	r5, r7
 8000818:	d0f9      	beq.n	800080e <HAL_DMA_IRQHandler+0x62>
 800081a:	4234      	tst	r4, r6
 800081c:	d0f7      	beq.n	800080e <HAL_DMA_IRQHandler+0x62>
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800081e:	250e      	movs	r5, #14
 8000820:	681c      	ldr	r4, [r3, #0]
 8000822:	43ac      	bics	r4, r5
 8000824:	601c      	str	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8000826:	2301      	movs	r3, #1
 8000828:	001c      	movs	r4, r3
 800082a:	408c      	lsls	r4, r1
 800082c:	6054      	str	r4, [r2, #4]
    hdma->State = HAL_DMA_STATE_READY;    
 800082e:	1c82      	adds	r2, r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8000830:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;    
 8000832:	77d3      	strb	r3, [r2, #31]
    __HAL_UNLOCK(hdma); 
 8000834:	2200      	movs	r2, #0
 8000836:	18c3      	adds	r3, r0, r3
 8000838:	77da      	strb	r2, [r3, #31]
    if(hdma->XferErrorCallback != NULL)
 800083a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800083c:	e7e5      	b.n	800080a <HAL_DMA_IRQHandler+0x5e>
	...

08000840 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00u;
 8000840:	2300      	movs	r3, #0
{
 8000842:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000844:	b087      	sub	sp, #28
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000846:	680a      	ldr	r2, [r1, #0]
 8000848:	0014      	movs	r4, r2
 800084a:	40dc      	lsrs	r4, r3
 800084c:	d101      	bne.n	8000852 <HAL_GPIO_Init+0x12>
      }
    }

    position++;
  } 
}
 800084e:	b007      	add	sp, #28
 8000850:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8000852:	2501      	movs	r5, #1
 8000854:	0014      	movs	r4, r2
 8000856:	409d      	lsls	r5, r3
 8000858:	402c      	ands	r4, r5
 800085a:	9401      	str	r4, [sp, #4]
    if (iocurrent != 0x00u)
 800085c:	422a      	tst	r2, r5
 800085e:	d100      	bne.n	8000862 <HAL_GPIO_Init+0x22>
 8000860:	e095      	b.n	800098e <HAL_GPIO_Init+0x14e>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8000862:	684a      	ldr	r2, [r1, #4]
 8000864:	005e      	lsls	r6, r3, #1
 8000866:	4694      	mov	ip, r2
 8000868:	2203      	movs	r2, #3
 800086a:	4664      	mov	r4, ip
 800086c:	4022      	ands	r2, r4
 800086e:	2403      	movs	r4, #3
 8000870:	40b4      	lsls	r4, r6
 8000872:	43e4      	mvns	r4, r4
 8000874:	9402      	str	r4, [sp, #8]
 8000876:	1e54      	subs	r4, r2, #1
 8000878:	2c01      	cmp	r4, #1
 800087a:	d82a      	bhi.n	80008d2 <HAL_GPIO_Init+0x92>
        temp = GPIOx->OSPEEDR;
 800087c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800087e:	9c02      	ldr	r4, [sp, #8]
 8000880:	4027      	ands	r7, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 8000882:	68cc      	ldr	r4, [r1, #12]
 8000884:	40b4      	lsls	r4, r6
 8000886:	433c      	orrs	r4, r7
        GPIOx->OSPEEDR = temp;
 8000888:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 800088a:	6844      	ldr	r4, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800088c:	2701      	movs	r7, #1
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800088e:	43ac      	bics	r4, r5
 8000890:	0025      	movs	r5, r4
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8000892:	4664      	mov	r4, ip
 8000894:	0924      	lsrs	r4, r4, #4
 8000896:	403c      	ands	r4, r7
 8000898:	409c      	lsls	r4, r3
 800089a:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 800089c:	6044      	str	r4, [r0, #4]
        temp = GPIOx->PUPDR;
 800089e:	68c5      	ldr	r5, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 80008a0:	9c02      	ldr	r4, [sp, #8]
 80008a2:	4025      	ands	r5, r4
        temp |= ((GPIO_Init->Pull) << (position * 2u));
 80008a4:	688c      	ldr	r4, [r1, #8]
 80008a6:	40b4      	lsls	r4, r6
 80008a8:	432c      	orrs	r4, r5
        GPIOx->PUPDR = temp;
 80008aa:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80008ac:	2a02      	cmp	r2, #2
 80008ae:	d112      	bne.n	80008d6 <HAL_GPIO_Init+0x96>
        temp = GPIOx->AFR[position >> 3u];
 80008b0:	08dc      	lsrs	r4, r3, #3
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80008b2:	2507      	movs	r5, #7
 80008b4:	00a4      	lsls	r4, r4, #2
 80008b6:	1904      	adds	r4, r0, r4
        temp = GPIOx->AFR[position >> 3u];
 80008b8:	6a27      	ldr	r7, [r4, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80008ba:	9403      	str	r4, [sp, #12]
 80008bc:	240f      	movs	r4, #15
 80008be:	401d      	ands	r5, r3
 80008c0:	00ad      	lsls	r5, r5, #2
 80008c2:	40ac      	lsls	r4, r5
 80008c4:	43a7      	bics	r7, r4
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80008c6:	690c      	ldr	r4, [r1, #16]
 80008c8:	40ac      	lsls	r4, r5
 80008ca:	4327      	orrs	r7, r4
        GPIOx->AFR[position >> 3u] = temp;
 80008cc:	9c03      	ldr	r4, [sp, #12]
 80008ce:	6227      	str	r7, [r4, #32]
 80008d0:	e001      	b.n	80008d6 <HAL_GPIO_Init+0x96>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80008d2:	2a03      	cmp	r2, #3
 80008d4:	d1e3      	bne.n	800089e <HAL_GPIO_Init+0x5e>
      temp = GPIOx->MODER;
 80008d6:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 80008d8:	9d02      	ldr	r5, [sp, #8]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80008da:	40b2      	lsls	r2, r6
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 80008dc:	4025      	ands	r5, r4
 80008de:	002c      	movs	r4, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80008e0:	4314      	orrs	r4, r2
      GPIOx->MODER = temp;
 80008e2:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80008e4:	24c0      	movs	r4, #192	; 0xc0
 80008e6:	4662      	mov	r2, ip
 80008e8:	02a4      	lsls	r4, r4, #10
 80008ea:	4222      	tst	r2, r4
 80008ec:	d04f      	beq.n	800098e <HAL_GPIO_Init+0x14e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008ee:	2501      	movs	r5, #1
 80008f0:	4a28      	ldr	r2, [pc, #160]	; (8000994 <HAL_GPIO_Init+0x154>)
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80008f2:	2790      	movs	r7, #144	; 0x90
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008f4:	6994      	ldr	r4, [r2, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80008f6:	05ff      	lsls	r7, r7, #23
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80008f8:	432c      	orrs	r4, r5
 80008fa:	6194      	str	r4, [r2, #24]
 80008fc:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2u];
 80008fe:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000900:	402a      	ands	r2, r5
 8000902:	9205      	str	r2, [sp, #20]
 8000904:	9a05      	ldr	r2, [sp, #20]
        temp = SYSCFG->EXTICR[position >> 2u];
 8000906:	4a24      	ldr	r2, [pc, #144]	; (8000998 <HAL_GPIO_Init+0x158>)
 8000908:	00a4      	lsls	r4, r4, #2
 800090a:	18a4      	adds	r4, r4, r2
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800090c:	220f      	movs	r2, #15
 800090e:	3502      	adds	r5, #2
 8000910:	401d      	ands	r5, r3
 8000912:	00ad      	lsls	r5, r5, #2
 8000914:	40aa      	lsls	r2, r5
        temp = SYSCFG->EXTICR[position >> 2u];
 8000916:	68a6      	ldr	r6, [r4, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8000918:	4396      	bics	r6, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800091a:	2200      	movs	r2, #0
 800091c:	42b8      	cmp	r0, r7
 800091e:	d00c      	beq.n	800093a <HAL_GPIO_Init+0xfa>
 8000920:	4f1e      	ldr	r7, [pc, #120]	; (800099c <HAL_GPIO_Init+0x15c>)
 8000922:	3201      	adds	r2, #1
 8000924:	42b8      	cmp	r0, r7
 8000926:	d008      	beq.n	800093a <HAL_GPIO_Init+0xfa>
 8000928:	4f1d      	ldr	r7, [pc, #116]	; (80009a0 <HAL_GPIO_Init+0x160>)
 800092a:	3201      	adds	r2, #1
 800092c:	42b8      	cmp	r0, r7
 800092e:	d004      	beq.n	800093a <HAL_GPIO_Init+0xfa>
 8000930:	4f1c      	ldr	r7, [pc, #112]	; (80009a4 <HAL_GPIO_Init+0x164>)
 8000932:	3201      	adds	r2, #1
 8000934:	42b8      	cmp	r0, r7
 8000936:	d000      	beq.n	800093a <HAL_GPIO_Init+0xfa>
 8000938:	3202      	adds	r2, #2
 800093a:	40aa      	lsls	r2, r5
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800093c:	4667      	mov	r7, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800093e:	4332      	orrs	r2, r6
        SYSCFG->EXTICR[position >> 2u] = temp;
 8000940:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 8000942:	4a19      	ldr	r2, [pc, #100]	; (80009a8 <HAL_GPIO_Init+0x168>)
        temp &= ~(iocurrent);
 8000944:	9c01      	ldr	r4, [sp, #4]
        temp = EXTI->IMR;
 8000946:	6816      	ldr	r6, [r2, #0]
          temp |= iocurrent;
 8000948:	9d01      	ldr	r5, [sp, #4]
        temp &= ~(iocurrent);
 800094a:	43e4      	mvns	r4, r4
          temp |= iocurrent;
 800094c:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800094e:	03ff      	lsls	r7, r7, #15
 8000950:	d401      	bmi.n	8000956 <HAL_GPIO_Init+0x116>
        temp &= ~(iocurrent);
 8000952:	0035      	movs	r5, r6
 8000954:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000956:	4667      	mov	r7, ip
        EXTI->IMR = temp;
 8000958:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 800095a:	6856      	ldr	r6, [r2, #4]
          temp |= iocurrent;
 800095c:	9d01      	ldr	r5, [sp, #4]
 800095e:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000960:	03bf      	lsls	r7, r7, #14
 8000962:	d401      	bmi.n	8000968 <HAL_GPIO_Init+0x128>
        temp &= ~(iocurrent);
 8000964:	0035      	movs	r5, r6
 8000966:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000968:	4667      	mov	r7, ip
        EXTI->EMR = temp;
 800096a:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 800096c:	6896      	ldr	r6, [r2, #8]
          temp |= iocurrent;
 800096e:	9d01      	ldr	r5, [sp, #4]
 8000970:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000972:	02ff      	lsls	r7, r7, #11
 8000974:	d401      	bmi.n	800097a <HAL_GPIO_Init+0x13a>
        temp &= ~(iocurrent);
 8000976:	0035      	movs	r5, r6
 8000978:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800097a:	4667      	mov	r7, ip
        EXTI->RTSR = temp;
 800097c:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 800097e:	68d5      	ldr	r5, [r2, #12]
          temp |= iocurrent;
 8000980:	9e01      	ldr	r6, [sp, #4]
 8000982:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8000984:	02bf      	lsls	r7, r7, #10
 8000986:	d401      	bmi.n	800098c <HAL_GPIO_Init+0x14c>
        temp &= ~(iocurrent);
 8000988:	4025      	ands	r5, r4
 800098a:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 800098c:	60d6      	str	r6, [r2, #12]
    position++;
 800098e:	3301      	adds	r3, #1
 8000990:	e759      	b.n	8000846 <HAL_GPIO_Init+0x6>
 8000992:	46c0      	nop			; (mov r8, r8)
 8000994:	40021000 	.word	0x40021000
 8000998:	40010000 	.word	0x40010000
 800099c:	48000400 	.word	0x48000400
 80009a0:	48000800 	.word	0x48000800
 80009a4:	48000c00 	.word	0x48000c00
 80009a8:	40010400 	.word	0x40010400

080009ac <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80009ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80009ae:	0004      	movs	r4, r0
 80009b0:	b085      	sub	sp, #20
  uint32_t tickstart;
  uint32_t pll_config;
  uint32_t pll_config2;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80009b2:	2800      	cmp	r0, #0
 80009b4:	d045      	beq.n	8000a42 <HAL_RCC_OscConfig+0x96>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80009b6:	6803      	ldr	r3, [r0, #0]
 80009b8:	07db      	lsls	r3, r3, #31
 80009ba:	d42f      	bmi.n	8000a1c <HAL_RCC_OscConfig+0x70>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80009bc:	6823      	ldr	r3, [r4, #0]
 80009be:	079b      	lsls	r3, r3, #30
 80009c0:	d500      	bpl.n	80009c4 <HAL_RCC_OscConfig+0x18>
 80009c2:	e081      	b.n	8000ac8 <HAL_RCC_OscConfig+0x11c>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80009c4:	6823      	ldr	r3, [r4, #0]
 80009c6:	071b      	lsls	r3, r3, #28
 80009c8:	d500      	bpl.n	80009cc <HAL_RCC_OscConfig+0x20>
 80009ca:	e0bc      	b.n	8000b46 <HAL_RCC_OscConfig+0x19a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80009cc:	6823      	ldr	r3, [r4, #0]
 80009ce:	075b      	lsls	r3, r3, #29
 80009d0:	d500      	bpl.n	80009d4 <HAL_RCC_OscConfig+0x28>
 80009d2:	e0df      	b.n	8000b94 <HAL_RCC_OscConfig+0x1e8>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*----------------------------- HSI14 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 80009d4:	6823      	ldr	r3, [r4, #0]
 80009d6:	06db      	lsls	r3, r3, #27
 80009d8:	d51a      	bpl.n	8000a10 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));

    /* Check the HSI14 State */
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 80009da:	6962      	ldr	r2, [r4, #20]
 80009dc:	2304      	movs	r3, #4
 80009de:	4db5      	ldr	r5, [pc, #724]	; (8000cb4 <HAL_RCC_OscConfig+0x308>)
 80009e0:	2a01      	cmp	r2, #1
 80009e2:	d000      	beq.n	80009e6 <HAL_RCC_OscConfig+0x3a>
 80009e4:	e14a      	b.n	8000c7c <HAL_RCC_OscConfig+0x2d0>
    {
      /* Disable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_DISABLE();
 80009e6:	6b69      	ldr	r1, [r5, #52]	; 0x34

      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till HSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80009e8:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 80009ea:	430b      	orrs	r3, r1
 80009ec:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 80009ee:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80009f0:	431a      	orrs	r2, r3
 80009f2:	636a      	str	r2, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 80009f4:	f7ff fe2e 	bl	8000654 <HAL_GetTick>
 80009f8:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 80009fa:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80009fc:	423b      	tst	r3, r7
 80009fe:	d100      	bne.n	8000a02 <HAL_RCC_OscConfig+0x56>
 8000a00:	e135      	b.n	8000c6e <HAL_RCC_OscConfig+0x2c2>
    {
      /* Enable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_ENABLE();

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 8000a02:	21f8      	movs	r1, #248	; 0xf8
 8000a04:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000a06:	69a3      	ldr	r3, [r4, #24]
 8000a08:	438a      	bics	r2, r1
 8000a0a:	00db      	lsls	r3, r3, #3
 8000a0c:	4313      	orrs	r3, r2
 8000a0e:	636b      	str	r3, [r5, #52]	; 0x34
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000a10:	6a23      	ldr	r3, [r4, #32]
 8000a12:	2b00      	cmp	r3, #0
 8000a14:	d000      	beq.n	8000a18 <HAL_RCC_OscConfig+0x6c>
 8000a16:	e159      	b.n	8000ccc <HAL_RCC_OscConfig+0x320>
        }
      }
    }
  }

  return HAL_OK;
 8000a18:	2000      	movs	r0, #0
 8000a1a:	e02a      	b.n	8000a72 <HAL_RCC_OscConfig+0xc6>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000a1c:	210c      	movs	r1, #12
 8000a1e:	4da5      	ldr	r5, [pc, #660]	; (8000cb4 <HAL_RCC_OscConfig+0x308>)
 8000a20:	686a      	ldr	r2, [r5, #4]
 8000a22:	400a      	ands	r2, r1
 8000a24:	2a04      	cmp	r2, #4
 8000a26:	d006      	beq.n	8000a36 <HAL_RCC_OscConfig+0x8a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000a28:	686b      	ldr	r3, [r5, #4]
 8000a2a:	400b      	ands	r3, r1
 8000a2c:	2b08      	cmp	r3, #8
 8000a2e:	d10a      	bne.n	8000a46 <HAL_RCC_OscConfig+0x9a>
 8000a30:	686b      	ldr	r3, [r5, #4]
 8000a32:	03db      	lsls	r3, r3, #15
 8000a34:	d507      	bpl.n	8000a46 <HAL_RCC_OscConfig+0x9a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000a36:	682b      	ldr	r3, [r5, #0]
 8000a38:	039b      	lsls	r3, r3, #14
 8000a3a:	d5bf      	bpl.n	80009bc <HAL_RCC_OscConfig+0x10>
 8000a3c:	6863      	ldr	r3, [r4, #4]
 8000a3e:	2b00      	cmp	r3, #0
 8000a40:	d1bc      	bne.n	80009bc <HAL_RCC_OscConfig+0x10>
          return HAL_ERROR;
 8000a42:	2001      	movs	r0, #1
 8000a44:	e015      	b.n	8000a72 <HAL_RCC_OscConfig+0xc6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a46:	6863      	ldr	r3, [r4, #4]
 8000a48:	2b01      	cmp	r3, #1
 8000a4a:	d114      	bne.n	8000a76 <HAL_RCC_OscConfig+0xca>
 8000a4c:	2380      	movs	r3, #128	; 0x80
 8000a4e:	682a      	ldr	r2, [r5, #0]
 8000a50:	025b      	lsls	r3, r3, #9
 8000a52:	4313      	orrs	r3, r2
 8000a54:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000a56:	f7ff fdfd 	bl	8000654 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000a5a:	2780      	movs	r7, #128	; 0x80
        tickstart = HAL_GetTick();
 8000a5c:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000a5e:	02bf      	lsls	r7, r7, #10
 8000a60:	682b      	ldr	r3, [r5, #0]
 8000a62:	423b      	tst	r3, r7
 8000a64:	d1aa      	bne.n	80009bc <HAL_RCC_OscConfig+0x10>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a66:	f7ff fdf5 	bl	8000654 <HAL_GetTick>
 8000a6a:	1b80      	subs	r0, r0, r6
 8000a6c:	2864      	cmp	r0, #100	; 0x64
 8000a6e:	d9f7      	bls.n	8000a60 <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
 8000a70:	2003      	movs	r0, #3
}
 8000a72:	b005      	add	sp, #20
 8000a74:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a76:	2b00      	cmp	r3, #0
 8000a78:	d116      	bne.n	8000aa8 <HAL_RCC_OscConfig+0xfc>
 8000a7a:	682b      	ldr	r3, [r5, #0]
 8000a7c:	4a8e      	ldr	r2, [pc, #568]	; (8000cb8 <HAL_RCC_OscConfig+0x30c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a7e:	2780      	movs	r7, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a80:	4013      	ands	r3, r2
 8000a82:	602b      	str	r3, [r5, #0]
 8000a84:	682b      	ldr	r3, [r5, #0]
 8000a86:	4a8d      	ldr	r2, [pc, #564]	; (8000cbc <HAL_RCC_OscConfig+0x310>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a88:	02bf      	lsls	r7, r7, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000a8a:	4013      	ands	r3, r2
 8000a8c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000a8e:	f7ff fde1 	bl	8000654 <HAL_GetTick>
 8000a92:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000a94:	682b      	ldr	r3, [r5, #0]
 8000a96:	423b      	tst	r3, r7
 8000a98:	d100      	bne.n	8000a9c <HAL_RCC_OscConfig+0xf0>
 8000a9a:	e78f      	b.n	80009bc <HAL_RCC_OscConfig+0x10>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000a9c:	f7ff fdda 	bl	8000654 <HAL_GetTick>
 8000aa0:	1b80      	subs	r0, r0, r6
 8000aa2:	2864      	cmp	r0, #100	; 0x64
 8000aa4:	d9f6      	bls.n	8000a94 <HAL_RCC_OscConfig+0xe8>
 8000aa6:	e7e3      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000aa8:	2b05      	cmp	r3, #5
 8000aaa:	d105      	bne.n	8000ab8 <HAL_RCC_OscConfig+0x10c>
 8000aac:	2380      	movs	r3, #128	; 0x80
 8000aae:	682a      	ldr	r2, [r5, #0]
 8000ab0:	02db      	lsls	r3, r3, #11
 8000ab2:	4313      	orrs	r3, r2
 8000ab4:	602b      	str	r3, [r5, #0]
 8000ab6:	e7c9      	b.n	8000a4c <HAL_RCC_OscConfig+0xa0>
 8000ab8:	682b      	ldr	r3, [r5, #0]
 8000aba:	4a7f      	ldr	r2, [pc, #508]	; (8000cb8 <HAL_RCC_OscConfig+0x30c>)
 8000abc:	4013      	ands	r3, r2
 8000abe:	602b      	str	r3, [r5, #0]
 8000ac0:	682b      	ldr	r3, [r5, #0]
 8000ac2:	4a7e      	ldr	r2, [pc, #504]	; (8000cbc <HAL_RCC_OscConfig+0x310>)
 8000ac4:	4013      	ands	r3, r2
 8000ac6:	e7c5      	b.n	8000a54 <HAL_RCC_OscConfig+0xa8>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000ac8:	220c      	movs	r2, #12
 8000aca:	4d7a      	ldr	r5, [pc, #488]	; (8000cb4 <HAL_RCC_OscConfig+0x308>)
 8000acc:	686b      	ldr	r3, [r5, #4]
 8000ace:	4213      	tst	r3, r2
 8000ad0:	d006      	beq.n	8000ae0 <HAL_RCC_OscConfig+0x134>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8000ad2:	686b      	ldr	r3, [r5, #4]
 8000ad4:	4013      	ands	r3, r2
 8000ad6:	2b08      	cmp	r3, #8
 8000ad8:	d110      	bne.n	8000afc <HAL_RCC_OscConfig+0x150>
 8000ada:	686b      	ldr	r3, [r5, #4]
 8000adc:	03db      	lsls	r3, r3, #15
 8000ade:	d40d      	bmi.n	8000afc <HAL_RCC_OscConfig+0x150>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000ae0:	682b      	ldr	r3, [r5, #0]
 8000ae2:	079b      	lsls	r3, r3, #30
 8000ae4:	d502      	bpl.n	8000aec <HAL_RCC_OscConfig+0x140>
 8000ae6:	68e3      	ldr	r3, [r4, #12]
 8000ae8:	2b01      	cmp	r3, #1
 8000aea:	d1aa      	bne.n	8000a42 <HAL_RCC_OscConfig+0x96>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000aec:	21f8      	movs	r1, #248	; 0xf8
 8000aee:	682a      	ldr	r2, [r5, #0]
 8000af0:	6923      	ldr	r3, [r4, #16]
 8000af2:	438a      	bics	r2, r1
 8000af4:	00db      	lsls	r3, r3, #3
 8000af6:	4313      	orrs	r3, r2
 8000af8:	602b      	str	r3, [r5, #0]
 8000afa:	e763      	b.n	80009c4 <HAL_RCC_OscConfig+0x18>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000afc:	68e2      	ldr	r2, [r4, #12]
 8000afe:	2301      	movs	r3, #1
 8000b00:	2a00      	cmp	r2, #0
 8000b02:	d00f      	beq.n	8000b24 <HAL_RCC_OscConfig+0x178>
        __HAL_RCC_HSI_ENABLE();
 8000b04:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000b06:	2702      	movs	r7, #2
        __HAL_RCC_HSI_ENABLE();
 8000b08:	4313      	orrs	r3, r2
 8000b0a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000b0c:	f7ff fda2 	bl	8000654 <HAL_GetTick>
 8000b10:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000b12:	682b      	ldr	r3, [r5, #0]
 8000b14:	423b      	tst	r3, r7
 8000b16:	d1e9      	bne.n	8000aec <HAL_RCC_OscConfig+0x140>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b18:	f7ff fd9c 	bl	8000654 <HAL_GetTick>
 8000b1c:	1b80      	subs	r0, r0, r6
 8000b1e:	2802      	cmp	r0, #2
 8000b20:	d9f7      	bls.n	8000b12 <HAL_RCC_OscConfig+0x166>
 8000b22:	e7a5      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
        __HAL_RCC_HSI_DISABLE();
 8000b24:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000b26:	2702      	movs	r7, #2
        __HAL_RCC_HSI_DISABLE();
 8000b28:	439a      	bics	r2, r3
 8000b2a:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 8000b2c:	f7ff fd92 	bl	8000654 <HAL_GetTick>
 8000b30:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000b32:	682b      	ldr	r3, [r5, #0]
 8000b34:	423b      	tst	r3, r7
 8000b36:	d100      	bne.n	8000b3a <HAL_RCC_OscConfig+0x18e>
 8000b38:	e744      	b.n	80009c4 <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000b3a:	f7ff fd8b 	bl	8000654 <HAL_GetTick>
 8000b3e:	1b80      	subs	r0, r0, r6
 8000b40:	2802      	cmp	r0, #2
 8000b42:	d9f6      	bls.n	8000b32 <HAL_RCC_OscConfig+0x186>
 8000b44:	e794      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000b46:	69e2      	ldr	r2, [r4, #28]
 8000b48:	2301      	movs	r3, #1
 8000b4a:	4d5a      	ldr	r5, [pc, #360]	; (8000cb4 <HAL_RCC_OscConfig+0x308>)
 8000b4c:	2a00      	cmp	r2, #0
 8000b4e:	d010      	beq.n	8000b72 <HAL_RCC_OscConfig+0x1c6>
      __HAL_RCC_LSI_ENABLE();
 8000b50:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000b52:	2702      	movs	r7, #2
      __HAL_RCC_LSI_ENABLE();
 8000b54:	4313      	orrs	r3, r2
 8000b56:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000b58:	f7ff fd7c 	bl	8000654 <HAL_GetTick>
 8000b5c:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000b5e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000b60:	423b      	tst	r3, r7
 8000b62:	d000      	beq.n	8000b66 <HAL_RCC_OscConfig+0x1ba>
 8000b64:	e732      	b.n	80009cc <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000b66:	f7ff fd75 	bl	8000654 <HAL_GetTick>
 8000b6a:	1b80      	subs	r0, r0, r6
 8000b6c:	2802      	cmp	r0, #2
 8000b6e:	d9f6      	bls.n	8000b5e <HAL_RCC_OscConfig+0x1b2>
 8000b70:	e77e      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
      __HAL_RCC_LSI_DISABLE();
 8000b72:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000b74:	2702      	movs	r7, #2
      __HAL_RCC_LSI_DISABLE();
 8000b76:	439a      	bics	r2, r3
 8000b78:	626a      	str	r2, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000b7a:	f7ff fd6b 	bl	8000654 <HAL_GetTick>
 8000b7e:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000b80:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000b82:	423b      	tst	r3, r7
 8000b84:	d100      	bne.n	8000b88 <HAL_RCC_OscConfig+0x1dc>
 8000b86:	e721      	b.n	80009cc <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000b88:	f7ff fd64 	bl	8000654 <HAL_GetTick>
 8000b8c:	1b80      	subs	r0, r0, r6
 8000b8e:	2802      	cmp	r0, #2
 8000b90:	d9f6      	bls.n	8000b80 <HAL_RCC_OscConfig+0x1d4>
 8000b92:	e76d      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000b94:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 8000b96:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000b98:	4d46      	ldr	r5, [pc, #280]	; (8000cb4 <HAL_RCC_OscConfig+0x308>)
 8000b9a:	0552      	lsls	r2, r2, #21
 8000b9c:	69eb      	ldr	r3, [r5, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000b9e:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000ba0:	4213      	tst	r3, r2
 8000ba2:	d108      	bne.n	8000bb6 <HAL_RCC_OscConfig+0x20a>
      __HAL_RCC_PWR_CLK_ENABLE();
 8000ba4:	69eb      	ldr	r3, [r5, #28]
 8000ba6:	4313      	orrs	r3, r2
 8000ba8:	61eb      	str	r3, [r5, #28]
 8000baa:	69eb      	ldr	r3, [r5, #28]
 8000bac:	4013      	ands	r3, r2
 8000bae:	9303      	str	r3, [sp, #12]
 8000bb0:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 8000bb2:	2301      	movs	r3, #1
 8000bb4:	9300      	str	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000bb6:	2780      	movs	r7, #128	; 0x80
 8000bb8:	4e41      	ldr	r6, [pc, #260]	; (8000cc0 <HAL_RCC_OscConfig+0x314>)
 8000bba:	007f      	lsls	r7, r7, #1
 8000bbc:	6833      	ldr	r3, [r6, #0]
 8000bbe:	423b      	tst	r3, r7
 8000bc0:	d006      	beq.n	8000bd0 <HAL_RCC_OscConfig+0x224>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000bc2:	68a3      	ldr	r3, [r4, #8]
 8000bc4:	2b01      	cmp	r3, #1
 8000bc6:	d113      	bne.n	8000bf0 <HAL_RCC_OscConfig+0x244>
 8000bc8:	6a2a      	ldr	r2, [r5, #32]
 8000bca:	4313      	orrs	r3, r2
 8000bcc:	622b      	str	r3, [r5, #32]
 8000bce:	e030      	b.n	8000c32 <HAL_RCC_OscConfig+0x286>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000bd0:	6833      	ldr	r3, [r6, #0]
 8000bd2:	433b      	orrs	r3, r7
 8000bd4:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8000bd6:	f7ff fd3d 	bl	8000654 <HAL_GetTick>
 8000bda:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000bdc:	6833      	ldr	r3, [r6, #0]
 8000bde:	423b      	tst	r3, r7
 8000be0:	d1ef      	bne.n	8000bc2 <HAL_RCC_OscConfig+0x216>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000be2:	f7ff fd37 	bl	8000654 <HAL_GetTick>
 8000be6:	9b01      	ldr	r3, [sp, #4]
 8000be8:	1ac0      	subs	r0, r0, r3
 8000bea:	2864      	cmp	r0, #100	; 0x64
 8000bec:	d9f6      	bls.n	8000bdc <HAL_RCC_OscConfig+0x230>
 8000bee:	e73f      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000bf0:	2201      	movs	r2, #1
 8000bf2:	2b00      	cmp	r3, #0
 8000bf4:	d114      	bne.n	8000c20 <HAL_RCC_OscConfig+0x274>
 8000bf6:	6a2b      	ldr	r3, [r5, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000bf8:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000bfa:	4393      	bics	r3, r2
 8000bfc:	622b      	str	r3, [r5, #32]
 8000bfe:	6a2b      	ldr	r3, [r5, #32]
 8000c00:	3203      	adds	r2, #3
 8000c02:	4393      	bics	r3, r2
 8000c04:	622b      	str	r3, [r5, #32]
      tickstart = HAL_GetTick();
 8000c06:	f7ff fd25 	bl	8000654 <HAL_GetTick>
 8000c0a:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000c0c:	6a2b      	ldr	r3, [r5, #32]
 8000c0e:	423b      	tst	r3, r7
 8000c10:	d016      	beq.n	8000c40 <HAL_RCC_OscConfig+0x294>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000c12:	f7ff fd1f 	bl	8000654 <HAL_GetTick>
 8000c16:	4b2b      	ldr	r3, [pc, #172]	; (8000cc4 <HAL_RCC_OscConfig+0x318>)
 8000c18:	1b80      	subs	r0, r0, r6
 8000c1a:	4298      	cmp	r0, r3
 8000c1c:	d9f6      	bls.n	8000c0c <HAL_RCC_OscConfig+0x260>
 8000c1e:	e727      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000c20:	2b05      	cmp	r3, #5
 8000c22:	d116      	bne.n	8000c52 <HAL_RCC_OscConfig+0x2a6>
 8000c24:	6a29      	ldr	r1, [r5, #32]
 8000c26:	3b01      	subs	r3, #1
 8000c28:	430b      	orrs	r3, r1
 8000c2a:	622b      	str	r3, [r5, #32]
 8000c2c:	6a2b      	ldr	r3, [r5, #32]
 8000c2e:	431a      	orrs	r2, r3
 8000c30:	622a      	str	r2, [r5, #32]
      tickstart = HAL_GetTick();
 8000c32:	f7ff fd0f 	bl	8000654 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000c36:	2702      	movs	r7, #2
      tickstart = HAL_GetTick();
 8000c38:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000c3a:	6a2b      	ldr	r3, [r5, #32]
 8000c3c:	423b      	tst	r3, r7
 8000c3e:	d00f      	beq.n	8000c60 <HAL_RCC_OscConfig+0x2b4>
    if(pwrclkchanged == SET)
 8000c40:	9b00      	ldr	r3, [sp, #0]
 8000c42:	2b01      	cmp	r3, #1
 8000c44:	d000      	beq.n	8000c48 <HAL_RCC_OscConfig+0x29c>
 8000c46:	e6c5      	b.n	80009d4 <HAL_RCC_OscConfig+0x28>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000c48:	69eb      	ldr	r3, [r5, #28]
 8000c4a:	4a1f      	ldr	r2, [pc, #124]	; (8000cc8 <HAL_RCC_OscConfig+0x31c>)
 8000c4c:	4013      	ands	r3, r2
 8000c4e:	61eb      	str	r3, [r5, #28]
 8000c50:	e6c0      	b.n	80009d4 <HAL_RCC_OscConfig+0x28>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000c52:	6a2b      	ldr	r3, [r5, #32]
 8000c54:	4393      	bics	r3, r2
 8000c56:	2204      	movs	r2, #4
 8000c58:	622b      	str	r3, [r5, #32]
 8000c5a:	6a2b      	ldr	r3, [r5, #32]
 8000c5c:	4393      	bics	r3, r2
 8000c5e:	e7b5      	b.n	8000bcc <HAL_RCC_OscConfig+0x220>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000c60:	f7ff fcf8 	bl	8000654 <HAL_GetTick>
 8000c64:	4b17      	ldr	r3, [pc, #92]	; (8000cc4 <HAL_RCC_OscConfig+0x318>)
 8000c66:	1b80      	subs	r0, r0, r6
 8000c68:	4298      	cmp	r0, r3
 8000c6a:	d9e6      	bls.n	8000c3a <HAL_RCC_OscConfig+0x28e>
 8000c6c:	e700      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000c6e:	f7ff fcf1 	bl	8000654 <HAL_GetTick>
 8000c72:	1b80      	subs	r0, r0, r6
 8000c74:	2802      	cmp	r0, #2
 8000c76:	d800      	bhi.n	8000c7a <HAL_RCC_OscConfig+0x2ce>
 8000c78:	e6bf      	b.n	80009fa <HAL_RCC_OscConfig+0x4e>
 8000c7a:	e6f9      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 8000c7c:	3205      	adds	r2, #5
 8000c7e:	d103      	bne.n	8000c88 <HAL_RCC_OscConfig+0x2dc>
      __HAL_RCC_HSI14ADC_ENABLE();
 8000c80:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000c82:	439a      	bics	r2, r3
 8000c84:	636a      	str	r2, [r5, #52]	; 0x34
 8000c86:	e6bc      	b.n	8000a02 <HAL_RCC_OscConfig+0x56>
      __HAL_RCC_HSI14ADC_DISABLE();
 8000c88:	6b6a      	ldr	r2, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000c8a:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8000c8c:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 8000c8e:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 8000c90:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 8000c92:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000c94:	4393      	bics	r3, r2
 8000c96:	636b      	str	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 8000c98:	f7ff fcdc 	bl	8000654 <HAL_GetTick>
 8000c9c:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000c9e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000ca0:	423b      	tst	r3, r7
 8000ca2:	d100      	bne.n	8000ca6 <HAL_RCC_OscConfig+0x2fa>
 8000ca4:	e6b4      	b.n	8000a10 <HAL_RCC_OscConfig+0x64>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000ca6:	f7ff fcd5 	bl	8000654 <HAL_GetTick>
 8000caa:	1b80      	subs	r0, r0, r6
 8000cac:	2802      	cmp	r0, #2
 8000cae:	d9f6      	bls.n	8000c9e <HAL_RCC_OscConfig+0x2f2>
 8000cb0:	e6de      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
 8000cb2:	46c0      	nop			; (mov r8, r8)
 8000cb4:	40021000 	.word	0x40021000
 8000cb8:	fffeffff 	.word	0xfffeffff
 8000cbc:	fffbffff 	.word	0xfffbffff
 8000cc0:	40007000 	.word	0x40007000
 8000cc4:	00001388 	.word	0x00001388
 8000cc8:	efffffff 	.word	0xefffffff
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000ccc:	200c      	movs	r0, #12
 8000cce:	4a34      	ldr	r2, [pc, #208]	; (8000da0 <HAL_RCC_OscConfig+0x3f4>)
 8000cd0:	6851      	ldr	r1, [r2, #4]
 8000cd2:	0015      	movs	r5, r2
 8000cd4:	4001      	ands	r1, r0
 8000cd6:	2908      	cmp	r1, #8
 8000cd8:	d047      	beq.n	8000d6a <HAL_RCC_OscConfig+0x3be>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000cda:	4a32      	ldr	r2, [pc, #200]	; (8000da4 <HAL_RCC_OscConfig+0x3f8>)
 8000cdc:	2b02      	cmp	r3, #2
 8000cde:	d132      	bne.n	8000d46 <HAL_RCC_OscConfig+0x39a>
        __HAL_RCC_PLL_DISABLE();
 8000ce0:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000ce2:	2780      	movs	r7, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8000ce4:	4013      	ands	r3, r2
 8000ce6:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000ce8:	f7ff fcb4 	bl	8000654 <HAL_GetTick>
 8000cec:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000cee:	04bf      	lsls	r7, r7, #18
 8000cf0:	682b      	ldr	r3, [r5, #0]
 8000cf2:	423b      	tst	r3, r7
 8000cf4:	d121      	bne.n	8000d3a <HAL_RCC_OscConfig+0x38e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000cf6:	220f      	movs	r2, #15
 8000cf8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000cfa:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000cfc:	4393      	bics	r3, r2
 8000cfe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000d00:	04b6      	lsls	r6, r6, #18
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000d02:	4313      	orrs	r3, r2
 8000d04:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000d06:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000d08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000d0a:	686a      	ldr	r2, [r5, #4]
 8000d0c:	430b      	orrs	r3, r1
 8000d0e:	4926      	ldr	r1, [pc, #152]	; (8000da8 <HAL_RCC_OscConfig+0x3fc>)
 8000d10:	400a      	ands	r2, r1
 8000d12:	4313      	orrs	r3, r2
 8000d14:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8000d16:	2380      	movs	r3, #128	; 0x80
 8000d18:	682a      	ldr	r2, [r5, #0]
 8000d1a:	045b      	lsls	r3, r3, #17
 8000d1c:	4313      	orrs	r3, r2
 8000d1e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000d20:	f7ff fc98 	bl	8000654 <HAL_GetTick>
 8000d24:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000d26:	682b      	ldr	r3, [r5, #0]
 8000d28:	4233      	tst	r3, r6
 8000d2a:	d000      	beq.n	8000d2e <HAL_RCC_OscConfig+0x382>
 8000d2c:	e674      	b.n	8000a18 <HAL_RCC_OscConfig+0x6c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000d2e:	f7ff fc91 	bl	8000654 <HAL_GetTick>
 8000d32:	1b00      	subs	r0, r0, r4
 8000d34:	2802      	cmp	r0, #2
 8000d36:	d9f6      	bls.n	8000d26 <HAL_RCC_OscConfig+0x37a>
 8000d38:	e69a      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000d3a:	f7ff fc8b 	bl	8000654 <HAL_GetTick>
 8000d3e:	1b80      	subs	r0, r0, r6
 8000d40:	2802      	cmp	r0, #2
 8000d42:	d9d5      	bls.n	8000cf0 <HAL_RCC_OscConfig+0x344>
 8000d44:	e694      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
        __HAL_RCC_PLL_DISABLE();
 8000d46:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000d48:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8000d4a:	4013      	ands	r3, r2
 8000d4c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000d4e:	f7ff fc81 	bl	8000654 <HAL_GetTick>
 8000d52:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000d54:	04b6      	lsls	r6, r6, #18
 8000d56:	682b      	ldr	r3, [r5, #0]
 8000d58:	4233      	tst	r3, r6
 8000d5a:	d100      	bne.n	8000d5e <HAL_RCC_OscConfig+0x3b2>
 8000d5c:	e65c      	b.n	8000a18 <HAL_RCC_OscConfig+0x6c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000d5e:	f7ff fc79 	bl	8000654 <HAL_GetTick>
 8000d62:	1b00      	subs	r0, r0, r4
 8000d64:	2802      	cmp	r0, #2
 8000d66:	d9f6      	bls.n	8000d56 <HAL_RCC_OscConfig+0x3aa>
 8000d68:	e682      	b.n	8000a70 <HAL_RCC_OscConfig+0xc4>
        return HAL_ERROR;
 8000d6a:	0018      	movs	r0, r3
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8000d6c:	2b01      	cmp	r3, #1
 8000d6e:	d100      	bne.n	8000d72 <HAL_RCC_OscConfig+0x3c6>
 8000d70:	e67f      	b.n	8000a72 <HAL_RCC_OscConfig+0xc6>
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000d72:	2180      	movs	r1, #128	; 0x80
        pll_config  = RCC->CFGR;
 8000d74:	6853      	ldr	r3, [r2, #4]
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000d76:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000d78:	0249      	lsls	r1, r1, #9
        pll_config2 = RCC->CFGR2;
 8000d7a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000d7c:	4019      	ands	r1, r3
 8000d7e:	4281      	cmp	r1, r0
 8000d80:	d000      	beq.n	8000d84 <HAL_RCC_OscConfig+0x3d8>
 8000d82:	e65e      	b.n	8000a42 <HAL_RCC_OscConfig+0x96>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 8000d84:	210f      	movs	r1, #15
 8000d86:	400a      	ands	r2, r1
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000d88:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000d8a:	428a      	cmp	r2, r1
 8000d8c:	d000      	beq.n	8000d90 <HAL_RCC_OscConfig+0x3e4>
 8000d8e:	e658      	b.n	8000a42 <HAL_RCC_OscConfig+0x96>
           (READ_BIT(pll_config,  RCC_CFGR_PLLMUL)  != RCC_OscInitStruct->PLL.PLLMUL))
 8000d90:	22f0      	movs	r2, #240	; 0xf0
 8000d92:	0392      	lsls	r2, r2, #14
 8000d94:	4013      	ands	r3, r2
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 8000d96:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000d98:	4293      	cmp	r3, r2
 8000d9a:	d100      	bne.n	8000d9e <HAL_RCC_OscConfig+0x3f2>
 8000d9c:	e63c      	b.n	8000a18 <HAL_RCC_OscConfig+0x6c>
 8000d9e:	e650      	b.n	8000a42 <HAL_RCC_OscConfig+0x96>
 8000da0:	40021000 	.word	0x40021000
 8000da4:	feffffff 	.word	0xfeffffff
 8000da8:	ffc2ffff 	.word	0xffc2ffff

08000dac <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000dac:	b570      	push	{r4, r5, r6, lr}
 8000dae:	b088      	sub	sp, #32
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000db0:	2210      	movs	r2, #16
 8000db2:	4912      	ldr	r1, [pc, #72]	; (8000dfc <HAL_RCC_GetSysClockFreq+0x50>)
 8000db4:	4668      	mov	r0, sp
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000db6:	ad04      	add	r5, sp, #16
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000db8:	f001 feaa 	bl	8002b10 <memcpy>
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000dbc:	2210      	movs	r2, #16
 8000dbe:	0028      	movs	r0, r5
 8000dc0:	490f      	ldr	r1, [pc, #60]	; (8000e00 <HAL_RCC_GetSysClockFreq+0x54>)
 8000dc2:	f001 fea5 	bl	8002b10 <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000dc6:	220c      	movs	r2, #12
  tmpreg = RCC->CFGR;
 8000dc8:	4e0e      	ldr	r6, [pc, #56]	; (8000e04 <HAL_RCC_GetSysClockFreq+0x58>)
 8000dca:	6873      	ldr	r3, [r6, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8000dcc:	401a      	ands	r2, r3
 8000dce:	2a08      	cmp	r2, #8
 8000dd0:	d111      	bne.n	8000df6 <HAL_RCC_GetSysClockFreq+0x4a>
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000dd2:	200f      	movs	r0, #15
 8000dd4:	466a      	mov	r2, sp
 8000dd6:	0c99      	lsrs	r1, r3, #18
 8000dd8:	4001      	ands	r1, r0
 8000dda:	5c54      	ldrb	r4, [r2, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8000ddc:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8000dde:	4002      	ands	r2, r0
 8000de0:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8000de2:	03db      	lsls	r3, r3, #15
 8000de4:	d505      	bpl.n	8000df2 <HAL_RCC_GetSysClockFreq+0x46>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSE_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 8000de6:	4808      	ldr	r0, [pc, #32]	; (8000e08 <HAL_RCC_GetSysClockFreq+0x5c>)
 8000de8:	f7ff f9a2 	bl	8000130 <__udivsi3>
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
#else
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 8000dec:	4360      	muls	r0, r4
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000dee:	b008      	add	sp, #32
 8000df0:	bd70      	pop	{r4, r5, r6, pc}
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 8000df2:	4806      	ldr	r0, [pc, #24]	; (8000e0c <HAL_RCC_GetSysClockFreq+0x60>)
 8000df4:	e7fa      	b.n	8000dec <HAL_RCC_GetSysClockFreq+0x40>
      sysclockfreq = HSE_VALUE;
 8000df6:	4804      	ldr	r0, [pc, #16]	; (8000e08 <HAL_RCC_GetSysClockFreq+0x5c>)
  return sysclockfreq;
 8000df8:	e7f9      	b.n	8000dee <HAL_RCC_GetSysClockFreq+0x42>
 8000dfa:	46c0      	nop			; (mov r8, r8)
 8000dfc:	08002b70 	.word	0x08002b70
 8000e00:	08002b81 	.word	0x08002b81
 8000e04:	40021000 	.word	0x40021000
 8000e08:	007a1200 	.word	0x007a1200
 8000e0c:	003d0900 	.word	0x003d0900

08000e10 <HAL_RCC_ClockConfig>:
{
 8000e10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000e12:	0005      	movs	r5, r0
 8000e14:	000e      	movs	r6, r1
  if(RCC_ClkInitStruct == NULL)
 8000e16:	2800      	cmp	r0, #0
 8000e18:	d101      	bne.n	8000e1e <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 8000e1a:	2001      	movs	r0, #1
}
 8000e1c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8000e1e:	2201      	movs	r2, #1
 8000e20:	4c37      	ldr	r4, [pc, #220]	; (8000f00 <HAL_RCC_ClockConfig+0xf0>)
 8000e22:	6823      	ldr	r3, [r4, #0]
 8000e24:	4013      	ands	r3, r2
 8000e26:	428b      	cmp	r3, r1
 8000e28:	d31c      	bcc.n	8000e64 <HAL_RCC_ClockConfig+0x54>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000e2a:	6829      	ldr	r1, [r5, #0]
 8000e2c:	078b      	lsls	r3, r1, #30
 8000e2e:	d422      	bmi.n	8000e76 <HAL_RCC_ClockConfig+0x66>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000e30:	07cb      	lsls	r3, r1, #31
 8000e32:	d42f      	bmi.n	8000e94 <HAL_RCC_ClockConfig+0x84>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8000e34:	2301      	movs	r3, #1
 8000e36:	6822      	ldr	r2, [r4, #0]
 8000e38:	401a      	ands	r2, r3
 8000e3a:	42b2      	cmp	r2, r6
 8000e3c:	d851      	bhi.n	8000ee2 <HAL_RCC_ClockConfig+0xd2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000e3e:	682b      	ldr	r3, [r5, #0]
 8000e40:	4c30      	ldr	r4, [pc, #192]	; (8000f04 <HAL_RCC_ClockConfig+0xf4>)
 8000e42:	075b      	lsls	r3, r3, #29
 8000e44:	d454      	bmi.n	8000ef0 <HAL_RCC_ClockConfig+0xe0>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8000e46:	f7ff ffb1 	bl	8000dac <HAL_RCC_GetSysClockFreq>
 8000e4a:	6863      	ldr	r3, [r4, #4]
 8000e4c:	4a2e      	ldr	r2, [pc, #184]	; (8000f08 <HAL_RCC_ClockConfig+0xf8>)
 8000e4e:	061b      	lsls	r3, r3, #24
 8000e50:	0f1b      	lsrs	r3, r3, #28
 8000e52:	5cd3      	ldrb	r3, [r2, r3]
 8000e54:	40d8      	lsrs	r0, r3
 8000e56:	4b2d      	ldr	r3, [pc, #180]	; (8000f0c <HAL_RCC_ClockConfig+0xfc>)
 8000e58:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8000e5a:	2000      	movs	r0, #0
 8000e5c:	f7ff fb08 	bl	8000470 <HAL_InitTick>
  return HAL_OK;
 8000e60:	2000      	movs	r0, #0
 8000e62:	e7db      	b.n	8000e1c <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000e64:	6823      	ldr	r3, [r4, #0]
 8000e66:	4393      	bics	r3, r2
 8000e68:	430b      	orrs	r3, r1
 8000e6a:	6023      	str	r3, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000e6c:	6823      	ldr	r3, [r4, #0]
 8000e6e:	4013      	ands	r3, r2
 8000e70:	428b      	cmp	r3, r1
 8000e72:	d1d2      	bne.n	8000e1a <HAL_RCC_ClockConfig+0xa>
 8000e74:	e7d9      	b.n	8000e2a <HAL_RCC_ClockConfig+0x1a>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000e76:	4a23      	ldr	r2, [pc, #140]	; (8000f04 <HAL_RCC_ClockConfig+0xf4>)
 8000e78:	074b      	lsls	r3, r1, #29
 8000e7a:	d504      	bpl.n	8000e86 <HAL_RCC_ClockConfig+0x76>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 8000e7c:	23e0      	movs	r3, #224	; 0xe0
 8000e7e:	6850      	ldr	r0, [r2, #4]
 8000e80:	00db      	lsls	r3, r3, #3
 8000e82:	4303      	orrs	r3, r0
 8000e84:	6053      	str	r3, [r2, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000e86:	20f0      	movs	r0, #240	; 0xf0
 8000e88:	6853      	ldr	r3, [r2, #4]
 8000e8a:	4383      	bics	r3, r0
 8000e8c:	68a8      	ldr	r0, [r5, #8]
 8000e8e:	4303      	orrs	r3, r0
 8000e90:	6053      	str	r3, [r2, #4]
 8000e92:	e7cd      	b.n	8000e30 <HAL_RCC_ClockConfig+0x20>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000e94:	4f1b      	ldr	r7, [pc, #108]	; (8000f04 <HAL_RCC_ClockConfig+0xf4>)
 8000e96:	686a      	ldr	r2, [r5, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000e98:	683b      	ldr	r3, [r7, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000e9a:	2a01      	cmp	r2, #1
 8000e9c:	d119      	bne.n	8000ed2 <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000e9e:	039b      	lsls	r3, r3, #14
 8000ea0:	d5bb      	bpl.n	8000e1a <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000ea2:	2103      	movs	r1, #3
 8000ea4:	687b      	ldr	r3, [r7, #4]
 8000ea6:	438b      	bics	r3, r1
 8000ea8:	4313      	orrs	r3, r2
 8000eaa:	607b      	str	r3, [r7, #4]
    tickstart = HAL_GetTick();
 8000eac:	f7ff fbd2 	bl	8000654 <HAL_GetTick>
 8000eb0:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8000eb2:	230c      	movs	r3, #12
 8000eb4:	687a      	ldr	r2, [r7, #4]
 8000eb6:	401a      	ands	r2, r3
 8000eb8:	686b      	ldr	r3, [r5, #4]
 8000eba:	009b      	lsls	r3, r3, #2
 8000ebc:	429a      	cmp	r2, r3
 8000ebe:	d0b9      	beq.n	8000e34 <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000ec0:	f7ff fbc8 	bl	8000654 <HAL_GetTick>
 8000ec4:	9b01      	ldr	r3, [sp, #4]
 8000ec6:	1ac0      	subs	r0, r0, r3
 8000ec8:	4b11      	ldr	r3, [pc, #68]	; (8000f10 <HAL_RCC_ClockConfig+0x100>)
 8000eca:	4298      	cmp	r0, r3
 8000ecc:	d9f1      	bls.n	8000eb2 <HAL_RCC_ClockConfig+0xa2>
        return HAL_TIMEOUT;
 8000ece:	2003      	movs	r0, #3
 8000ed0:	e7a4      	b.n	8000e1c <HAL_RCC_ClockConfig+0xc>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000ed2:	2a02      	cmp	r2, #2
 8000ed4:	d102      	bne.n	8000edc <HAL_RCC_ClockConfig+0xcc>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000ed6:	019b      	lsls	r3, r3, #6
 8000ed8:	d4e3      	bmi.n	8000ea2 <HAL_RCC_ClockConfig+0x92>
 8000eda:	e79e      	b.n	8000e1a <HAL_RCC_ClockConfig+0xa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000edc:	079b      	lsls	r3, r3, #30
 8000ede:	d4e0      	bmi.n	8000ea2 <HAL_RCC_ClockConfig+0x92>
 8000ee0:	e79b      	b.n	8000e1a <HAL_RCC_ClockConfig+0xa>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000ee2:	6822      	ldr	r2, [r4, #0]
 8000ee4:	439a      	bics	r2, r3
 8000ee6:	6022      	str	r2, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000ee8:	6822      	ldr	r2, [r4, #0]
 8000eea:	421a      	tst	r2, r3
 8000eec:	d0a7      	beq.n	8000e3e <HAL_RCC_ClockConfig+0x2e>
 8000eee:	e794      	b.n	8000e1a <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8000ef0:	6863      	ldr	r3, [r4, #4]
 8000ef2:	4a08      	ldr	r2, [pc, #32]	; (8000f14 <HAL_RCC_ClockConfig+0x104>)
 8000ef4:	4013      	ands	r3, r2
 8000ef6:	68ea      	ldr	r2, [r5, #12]
 8000ef8:	4313      	orrs	r3, r2
 8000efa:	6063      	str	r3, [r4, #4]
 8000efc:	e7a3      	b.n	8000e46 <HAL_RCC_ClockConfig+0x36>
 8000efe:	46c0      	nop			; (mov r8, r8)
 8000f00:	40022000 	.word	0x40022000
 8000f04:	40021000 	.word	0x40021000
 8000f08:	08002b58 	.word	0x08002b58
 8000f0c:	20000000 	.word	0x20000000
 8000f10:	00001388 	.word	0x00001388
 8000f14:	fffff8ff 	.word	0xfffff8ff

08000f18 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 8000f18:	4b04      	ldr	r3, [pc, #16]	; (8000f2c <HAL_RCC_GetPCLK1Freq+0x14>)
 8000f1a:	4a05      	ldr	r2, [pc, #20]	; (8000f30 <HAL_RCC_GetPCLK1Freq+0x18>)
 8000f1c:	685b      	ldr	r3, [r3, #4]
 8000f1e:	055b      	lsls	r3, r3, #21
 8000f20:	0f5b      	lsrs	r3, r3, #29
 8000f22:	5cd3      	ldrb	r3, [r2, r3]
 8000f24:	4a03      	ldr	r2, [pc, #12]	; (8000f34 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000f26:	6810      	ldr	r0, [r2, #0]
 8000f28:	40d8      	lsrs	r0, r3
}    
 8000f2a:	4770      	bx	lr
 8000f2c:	40021000 	.word	0x40021000
 8000f30:	08002b68 	.word	0x08002b68
 8000f34:	20000000 	.word	0x20000000

08000f38 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000f38:	2307      	movs	r3, #7
{
 8000f3a:	b510      	push	{r4, lr}
  
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000f3c:	2403      	movs	r4, #3
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000f3e:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000f40:	4b09      	ldr	r3, [pc, #36]	; (8000f68 <HAL_RCC_GetClockConfig+0x30>)
 8000f42:	685a      	ldr	r2, [r3, #4]
 8000f44:	4022      	ands	r2, r4
 8000f46:	6042      	str	r2, [r0, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8000f48:	685a      	ldr	r2, [r3, #4]
 8000f4a:	34ed      	adds	r4, #237	; 0xed
 8000f4c:	4022      	ands	r2, r4
 8000f4e:	6082      	str	r2, [r0, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000f50:	22e0      	movs	r2, #224	; 0xe0
 8000f52:	685b      	ldr	r3, [r3, #4]
 8000f54:	00d2      	lsls	r2, r2, #3
 8000f56:	4013      	ands	r3, r2
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 8000f58:	2201      	movs	r2, #1
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000f5a:	60c3      	str	r3, [r0, #12]
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 8000f5c:	4b03      	ldr	r3, [pc, #12]	; (8000f6c <HAL_RCC_GetClockConfig+0x34>)
 8000f5e:	681b      	ldr	r3, [r3, #0]
 8000f60:	4013      	ands	r3, r2
 8000f62:	600b      	str	r3, [r1, #0]
}
 8000f64:	bd10      	pop	{r4, pc}
 8000f66:	46c0      	nop			; (mov r8, r8)
 8000f68:	40021000 	.word	0x40021000
 8000f6c:	40022000 	.word	0x40022000

08000f70 <SPI_WaitFlagStateUntilTimeout.constprop.0>:
  * @param  State flag state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 8000f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f72:	000e      	movs	r6, r1
 8000f74:	b085      	sub	sp, #20
 8000f76:	0015      	movs	r5, r2
 8000f78:	0004      	movs	r4, r0
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8000f7a:	f7ff fb6b 	bl	8000654 <HAL_GetTick>
 8000f7e:	19ad      	adds	r5, r5, r6
 8000f80:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 8000f82:	f7ff fb67 	bl	8000654 <HAL_GetTick>

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8000f86:	2780      	movs	r7, #128	; 0x80
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8000f88:	4b25      	ldr	r3, [pc, #148]	; (8001020 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xb0>)
  tmp_tickstart = HAL_GetTick();
 8000f8a:	9001      	str	r0, [sp, #4]
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8000f8c:	681b      	ldr	r3, [r3, #0]
 8000f8e:	015b      	lsls	r3, r3, #5
 8000f90:	0d1b      	lsrs	r3, r3, #20
 8000f92:	436b      	muls	r3, r5
 8000f94:	9303      	str	r3, [sp, #12]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8000f96:	6822      	ldr	r2, [r4, #0]
 8000f98:	6893      	ldr	r3, [r2, #8]
 8000f9a:	0018      	movs	r0, r3
 8000f9c:	4038      	ands	r0, r7
 8000f9e:	423b      	tst	r3, r7
 8000fa0:	d032      	beq.n	8001008 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x98>
  {
    if (Timeout != HAL_MAX_DELAY)
 8000fa2:	1c73      	adds	r3, r6, #1
 8000fa4:	d0f8      	beq.n	8000f98 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x28>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8000fa6:	f7ff fb55 	bl	8000654 <HAL_GetTick>
 8000faa:	9b01      	ldr	r3, [sp, #4]
 8000fac:	1ac0      	subs	r0, r0, r3
 8000fae:	42a8      	cmp	r0, r5
 8000fb0:	d32c      	bcc.n	800100c <SPI_WaitFlagStateUntilTimeout.constprop.0+0x9c>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8000fb2:	21e0      	movs	r1, #224	; 0xe0
 8000fb4:	6823      	ldr	r3, [r4, #0]
 8000fb6:	685a      	ldr	r2, [r3, #4]
 8000fb8:	438a      	bics	r2, r1
 8000fba:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8000fbc:	2282      	movs	r2, #130	; 0x82
 8000fbe:	6861      	ldr	r1, [r4, #4]
 8000fc0:	0052      	lsls	r2, r2, #1
 8000fc2:	4291      	cmp	r1, r2
 8000fc4:	d10c      	bne.n	8000fe0 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x70>
 8000fc6:	2180      	movs	r1, #128	; 0x80
 8000fc8:	68a2      	ldr	r2, [r4, #8]
 8000fca:	0209      	lsls	r1, r1, #8
 8000fcc:	428a      	cmp	r2, r1
 8000fce:	d003      	beq.n	8000fd8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x68>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8000fd0:	2180      	movs	r1, #128	; 0x80
 8000fd2:	00c9      	lsls	r1, r1, #3
 8000fd4:	428a      	cmp	r2, r1
 8000fd6:	d103      	bne.n	8000fe0 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x70>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8000fd8:	2140      	movs	r1, #64	; 0x40
 8000fda:	681a      	ldr	r2, [r3, #0]
 8000fdc:	438a      	bics	r2, r1
 8000fde:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8000fe0:	2180      	movs	r1, #128	; 0x80
 8000fe2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000fe4:	0189      	lsls	r1, r1, #6
 8000fe6:	428a      	cmp	r2, r1
 8000fe8:	d106      	bne.n	8000ff8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x88>
        {
          SPI_RESET_CRC(hspi);
 8000fea:	6819      	ldr	r1, [r3, #0]
 8000fec:	480d      	ldr	r0, [pc, #52]	; (8001024 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xb4>)
 8000fee:	4001      	ands	r1, r0
 8000ff0:	6019      	str	r1, [r3, #0]
 8000ff2:	6819      	ldr	r1, [r3, #0]
 8000ff4:	430a      	orrs	r2, r1
 8000ff6:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8000ff8:	0023      	movs	r3, r4
 8000ffa:	2201      	movs	r2, #1
 8000ffc:	335d      	adds	r3, #93	; 0x5d
 8000ffe:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8001000:	2300      	movs	r3, #0
 8001002:	2003      	movs	r0, #3
 8001004:	345c      	adds	r4, #92	; 0x5c
 8001006:	7023      	strb	r3, [r4, #0]
      count--;
    }
  }

  return HAL_OK;
}
 8001008:	b005      	add	sp, #20
 800100a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if(count == 0U)
 800100c:	9b03      	ldr	r3, [sp, #12]
        tmp_timeout = 0U;
 800100e:	1e5a      	subs	r2, r3, #1
 8001010:	4193      	sbcs	r3, r2
 8001012:	425b      	negs	r3, r3
 8001014:	401d      	ands	r5, r3
      count--;
 8001016:	9b03      	ldr	r3, [sp, #12]
 8001018:	3b01      	subs	r3, #1
 800101a:	9303      	str	r3, [sp, #12]
 800101c:	e7bb      	b.n	8000f96 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x26>
 800101e:	46c0      	nop			; (mov r8, r8)
 8001020:	20000000 	.word	0x20000000
 8001024:	ffffdfff 	.word	0xffffdfff

08001028 <SPI_WaitFifoStateUntilTimeout.constprop.0>:
  * @param  State Fifo state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8001028:	b5f0      	push	{r4, r5, r6, r7, lr}
 800102a:	0017      	movs	r7, r2
{
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;
  __IO uint8_t  * ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
 800102c:	2200      	movs	r2, #0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 800102e:	b085      	sub	sp, #20
 8001030:	001d      	movs	r5, r3
  __IO uint8_t  tmpreg8 = 0;
 8001032:	ab02      	add	r3, sp, #8
 8001034:	70da      	strb	r2, [r3, #3]
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8001036:	0004      	movs	r4, r0
 8001038:	000e      	movs	r6, r1

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 800103a:	f7ff fb0b 	bl	8000654 <HAL_GetTick>
 800103e:	19ed      	adds	r5, r5, r7
 8001040:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 8001042:	f7ff fb07 	bl	8000654 <HAL_GetTick>

  /* Initialize the 8bit temporary pointer */
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8001046:	2223      	movs	r2, #35	; 0x23
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 8001048:	6823      	ldr	r3, [r4, #0]
  tmp_tickstart = HAL_GetTick();
 800104a:	9000      	str	r0, [sp, #0]
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 800104c:	9301      	str	r3, [sp, #4]
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 800104e:	4b2a      	ldr	r3, [pc, #168]	; (80010f8 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xd0>)
 8001050:	681b      	ldr	r3, [r3, #0]
 8001052:	4353      	muls	r3, r2
 8001054:	0d1b      	lsrs	r3, r3, #20
 8001056:	436b      	muls	r3, r5
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if(count == 0U)
      {
        tmp_timeout = 0U;
      }      
      count--;
 8001058:	9303      	str	r3, [sp, #12]
  while ((hspi->Instance->SR & Fifo) != State)
 800105a:	6821      	ldr	r1, [r4, #0]
      tmpreg8 = *ptmpreg8;
 800105c:	ab02      	add	r3, sp, #8
 800105e:	1cda      	adds	r2, r3, #3
  while ((hspi->Instance->SR & Fifo) != State)
 8001060:	688b      	ldr	r3, [r1, #8]
 8001062:	0018      	movs	r0, r3
 8001064:	4030      	ands	r0, r6
 8001066:	4233      	tst	r3, r6
 8001068:	d03b      	beq.n	80010e2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xba>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 800106a:	23c0      	movs	r3, #192	; 0xc0
 800106c:	00db      	lsls	r3, r3, #3
 800106e:	429e      	cmp	r6, r3
 8001070:	d104      	bne.n	800107c <SPI_WaitFifoStateUntilTimeout.constprop.0+0x54>
      tmpreg8 = *ptmpreg8;
 8001072:	9b01      	ldr	r3, [sp, #4]
 8001074:	7b1b      	ldrb	r3, [r3, #12]
 8001076:	b2db      	uxtb	r3, r3
 8001078:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg8);
 800107a:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 800107c:	1c7b      	adds	r3, r7, #1
 800107e:	d0ef      	beq.n	8001060 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x38>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8001080:	f7ff fae8 	bl	8000654 <HAL_GetTick>
 8001084:	9b00      	ldr	r3, [sp, #0]
 8001086:	1ac0      	subs	r0, r0, r3
 8001088:	42a8      	cmp	r0, r5
 800108a:	d32c      	bcc.n	80010e6 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xbe>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800108c:	21e0      	movs	r1, #224	; 0xe0
 800108e:	6823      	ldr	r3, [r4, #0]
 8001090:	685a      	ldr	r2, [r3, #4]
 8001092:	438a      	bics	r2, r1
 8001094:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001096:	2282      	movs	r2, #130	; 0x82
 8001098:	6861      	ldr	r1, [r4, #4]
 800109a:	0052      	lsls	r2, r2, #1
 800109c:	4291      	cmp	r1, r2
 800109e:	d10c      	bne.n	80010ba <SPI_WaitFifoStateUntilTimeout.constprop.0+0x92>
 80010a0:	2180      	movs	r1, #128	; 0x80
 80010a2:	68a2      	ldr	r2, [r4, #8]
 80010a4:	0209      	lsls	r1, r1, #8
 80010a6:	428a      	cmp	r2, r1
 80010a8:	d003      	beq.n	80010b2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x8a>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80010aa:	2180      	movs	r1, #128	; 0x80
 80010ac:	00c9      	lsls	r1, r1, #3
 80010ae:	428a      	cmp	r2, r1
 80010b0:	d103      	bne.n	80010ba <SPI_WaitFifoStateUntilTimeout.constprop.0+0x92>
          __HAL_SPI_DISABLE(hspi);
 80010b2:	2140      	movs	r1, #64	; 0x40
 80010b4:	681a      	ldr	r2, [r3, #0]
 80010b6:	438a      	bics	r2, r1
 80010b8:	601a      	str	r2, [r3, #0]
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80010ba:	2180      	movs	r1, #128	; 0x80
 80010bc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80010be:	0189      	lsls	r1, r1, #6
 80010c0:	428a      	cmp	r2, r1
 80010c2:	d106      	bne.n	80010d2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xaa>
          SPI_RESET_CRC(hspi);
 80010c4:	6819      	ldr	r1, [r3, #0]
 80010c6:	480d      	ldr	r0, [pc, #52]	; (80010fc <SPI_WaitFifoStateUntilTimeout.constprop.0+0xd4>)
 80010c8:	4001      	ands	r1, r0
 80010ca:	6019      	str	r1, [r3, #0]
 80010cc:	6819      	ldr	r1, [r3, #0]
 80010ce:	430a      	orrs	r2, r1
 80010d0:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 80010d2:	0023      	movs	r3, r4
 80010d4:	2201      	movs	r2, #1
 80010d6:	335d      	adds	r3, #93	; 0x5d
 80010d8:	701a      	strb	r2, [r3, #0]
        __HAL_UNLOCK(hspi);
 80010da:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 80010dc:	2003      	movs	r0, #3
        __HAL_UNLOCK(hspi);
 80010de:	345c      	adds	r4, #92	; 0x5c
 80010e0:	7023      	strb	r3, [r4, #0]
    }
  }

  return HAL_OK;
}
 80010e2:	b005      	add	sp, #20
 80010e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if(count == 0U)
 80010e6:	9b03      	ldr	r3, [sp, #12]
        tmp_timeout = 0U;
 80010e8:	1e5a      	subs	r2, r3, #1
 80010ea:	4193      	sbcs	r3, r2
 80010ec:	425b      	negs	r3, r3
 80010ee:	401d      	ands	r5, r3
      count--;
 80010f0:	9b03      	ldr	r3, [sp, #12]
 80010f2:	3b01      	subs	r3, #1
 80010f4:	e7b0      	b.n	8001058 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x30>
 80010f6:	46c0      	nop			; (mov r8, r8)
 80010f8:	20000000 	.word	0x20000000
 80010fc:	ffffdfff 	.word	0xffffdfff

08001100 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001100:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001102:	0013      	movs	r3, r2
{
 8001104:	000d      	movs	r5, r1
 8001106:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001108:	000a      	movs	r2, r1
 800110a:	21c0      	movs	r1, #192	; 0xc0
 800110c:	0149      	lsls	r1, r1, #5
{
 800110e:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001110:	f7ff ff8a 	bl	8001028 <SPI_WaitFifoStateUntilTimeout.constprop.0>
 8001114:	2800      	cmp	r0, #0
 8001116:	d005      	beq.n	8001124 <SPI_EndRxTxTransaction+0x24>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001118:	2320      	movs	r3, #32
 800111a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800111c:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800111e:	4313      	orrs	r3, r2
 8001120:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8001122:	e00f      	b.n	8001144 <SPI_EndRxTxTransaction+0x44>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001124:	0032      	movs	r2, r6
 8001126:	0029      	movs	r1, r5
 8001128:	0020      	movs	r0, r4
 800112a:	f7ff ff21 	bl	8000f70 <SPI_WaitFlagStateUntilTimeout.constprop.0>
 800112e:	2800      	cmp	r0, #0
 8001130:	d1f2      	bne.n	8001118 <SPI_EndRxTxTransaction+0x18>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001132:	21c0      	movs	r1, #192	; 0xc0
 8001134:	0033      	movs	r3, r6
 8001136:	002a      	movs	r2, r5
 8001138:	0020      	movs	r0, r4
 800113a:	00c9      	lsls	r1, r1, #3
 800113c:	f7ff ff74 	bl	8001028 <SPI_WaitFifoStateUntilTimeout.constprop.0>
 8001140:	2800      	cmp	r0, #0
 8001142:	d1e9      	bne.n	8001118 <SPI_EndRxTxTransaction+0x18>
  }

  return HAL_OK;
}
 8001144:	bd70      	pop	{r4, r5, r6, pc}
	...

08001148 <HAL_SPI_Init>:
{
 8001148:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800114a:	0004      	movs	r4, r0
    return HAL_ERROR;
 800114c:	2001      	movs	r0, #1
  if (hspi == NULL)
 800114e:	2c00      	cmp	r4, #0
 8001150:	d067      	beq.n	8001222 <HAL_SPI_Init+0xda>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8001152:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001154:	2b00      	cmp	r3, #0
 8001156:	d165      	bne.n	8001224 <HAL_SPI_Init+0xdc>
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8001158:	2282      	movs	r2, #130	; 0x82
 800115a:	6861      	ldr	r1, [r4, #4]
 800115c:	0052      	lsls	r2, r2, #1
 800115e:	4291      	cmp	r1, r2
 8001160:	d000      	beq.n	8001164 <HAL_SPI_Init+0x1c>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8001162:	61e3      	str	r3, [r4, #28]
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001164:	2300      	movs	r3, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8001166:	0025      	movs	r5, r4
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001168:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 800116a:	355d      	adds	r5, #93	; 0x5d
 800116c:	782b      	ldrb	r3, [r5, #0]
 800116e:	b2da      	uxtb	r2, r3
 8001170:	2b00      	cmp	r3, #0
 8001172:	d105      	bne.n	8001180 <HAL_SPI_Init+0x38>
    hspi->Lock = HAL_UNLOCKED;
 8001174:	0023      	movs	r3, r4
 8001176:	335c      	adds	r3, #92	; 0x5c
    HAL_SPI_MspInit(hspi);
 8001178:	0020      	movs	r0, r4
    hspi->Lock = HAL_UNLOCKED;
 800117a:	701a      	strb	r2, [r3, #0]
    HAL_SPI_MspInit(hspi);
 800117c:	f7ff f92c 	bl	80003d8 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8001180:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8001182:	2140      	movs	r1, #64	; 0x40
  hspi->State = HAL_SPI_STATE_BUSY;
 8001184:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 8001186:	6822      	ldr	r2, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001188:	68e5      	ldr	r5, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 800118a:	6813      	ldr	r3, [r2, #0]
 800118c:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800118e:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 8001190:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8001192:	00c9      	lsls	r1, r1, #3
 8001194:	2300      	movs	r3, #0
 8001196:	428d      	cmp	r5, r1
 8001198:	d848      	bhi.n	800122c <HAL_SPI_Init+0xe4>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 800119a:	2080      	movs	r0, #128	; 0x80
 800119c:	0140      	lsls	r0, r0, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800119e:	428d      	cmp	r5, r1
 80011a0:	d000      	beq.n	80011a4 <HAL_SPI_Init+0x5c>
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80011a2:	62a3      	str	r3, [r4, #40]	; 0x28
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80011a4:	2382      	movs	r3, #130	; 0x82
 80011a6:	6866      	ldr	r6, [r4, #4]
 80011a8:	005b      	lsls	r3, r3, #1
 80011aa:	4033      	ands	r3, r6
 80011ac:	2684      	movs	r6, #132	; 0x84
 80011ae:	68a7      	ldr	r7, [r4, #8]
 80011b0:	0236      	lsls	r6, r6, #8
 80011b2:	403e      	ands	r6, r7
 80011b4:	4333      	orrs	r3, r6
 80011b6:	2602      	movs	r6, #2
 80011b8:	6927      	ldr	r7, [r4, #16]
 80011ba:	69a1      	ldr	r1, [r4, #24]
 80011bc:	403e      	ands	r6, r7
 80011be:	4333      	orrs	r3, r6
 80011c0:	2601      	movs	r6, #1
 80011c2:	6967      	ldr	r7, [r4, #20]
 80011c4:	46b4      	mov	ip, r6
 80011c6:	4037      	ands	r7, r6
 80011c8:	433b      	orrs	r3, r7
 80011ca:	2780      	movs	r7, #128	; 0x80
 80011cc:	00bf      	lsls	r7, r7, #2
 80011ce:	400f      	ands	r7, r1
 80011d0:	433b      	orrs	r3, r7
 80011d2:	2738      	movs	r7, #56	; 0x38
 80011d4:	69e6      	ldr	r6, [r4, #28]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80011d6:	0c09      	lsrs	r1, r1, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80011d8:	4037      	ands	r7, r6
 80011da:	433b      	orrs	r3, r7
 80011dc:	2780      	movs	r7, #128	; 0x80
 80011de:	6a26      	ldr	r6, [r4, #32]
 80011e0:	4037      	ands	r7, r6
 80011e2:	433b      	orrs	r3, r7
 80011e4:	2780      	movs	r7, #128	; 0x80
 80011e6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80011e8:	01bf      	lsls	r7, r7, #6
 80011ea:	4037      	ands	r7, r6
 80011ec:	433b      	orrs	r3, r7
 80011ee:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80011f0:	2310      	movs	r3, #16
 80011f2:	2708      	movs	r7, #8
 80011f4:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80011f6:	4033      	ands	r3, r6
 80011f8:	6b66      	ldr	r6, [r4, #52]	; 0x34
 80011fa:	4037      	ands	r7, r6
 80011fc:	433b      	orrs	r3, r7
 80011fe:	27f0      	movs	r7, #240	; 0xf0
 8001200:	013f      	lsls	r7, r7, #4
 8001202:	403d      	ands	r5, r7
 8001204:	431d      	orrs	r5, r3
 8001206:	2304      	movs	r3, #4
 8001208:	4019      	ands	r1, r3
 800120a:	4329      	orrs	r1, r5
 800120c:	4308      	orrs	r0, r1
 800120e:	6050      	str	r0, [r2, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8001210:	69d3      	ldr	r3, [r2, #28]
 8001212:	4908      	ldr	r1, [pc, #32]	; (8001234 <HAL_SPI_Init+0xec>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001214:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8001216:	400b      	ands	r3, r1
 8001218:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 800121a:	4663      	mov	r3, ip
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800121c:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 800121e:	345d      	adds	r4, #93	; 0x5d
 8001220:	7023      	strb	r3, [r4, #0]
}
 8001222:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8001224:	2300      	movs	r3, #0
 8001226:	6123      	str	r3, [r4, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8001228:	6163      	str	r3, [r4, #20]
 800122a:	e79b      	b.n	8001164 <HAL_SPI_Init+0x1c>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800122c:	21f0      	movs	r1, #240	; 0xf0
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800122e:	0018      	movs	r0, r3
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8001230:	0109      	lsls	r1, r1, #4
 8001232:	e7b4      	b.n	800119e <HAL_SPI_Init+0x56>
 8001234:	fffff7ff 	.word	0xfffff7ff

08001238 <HAL_SPI_Transmit_DMA>:
{
 8001238:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 800123a:	0006      	movs	r6, r0
 800123c:	365c      	adds	r6, #92	; 0x5c
 800123e:	7833      	ldrb	r3, [r6, #0]
{
 8001240:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8001242:	2502      	movs	r5, #2
 8001244:	2b01      	cmp	r3, #1
 8001246:	d05b      	beq.n	8001300 <HAL_SPI_Transmit_DMA+0xc8>
 8001248:	2301      	movs	r3, #1
 800124a:	7033      	strb	r3, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 800124c:	0003      	movs	r3, r0
 800124e:	335d      	adds	r3, #93	; 0x5d
 8001250:	7818      	ldrb	r0, [r3, #0]
 8001252:	b2c5      	uxtb	r5, r0
 8001254:	2801      	cmp	r0, #1
 8001256:	d000      	beq.n	800125a <HAL_SPI_Transmit_DMA+0x22>
 8001258:	e06f      	b.n	800133a <HAL_SPI_Transmit_DMA+0x102>
  if ((pData == NULL) || (Size == 0U))
 800125a:	2900      	cmp	r1, #0
 800125c:	d04e      	beq.n	80012fc <HAL_SPI_Transmit_DMA+0xc4>
 800125e:	2a00      	cmp	r2, #0
 8001260:	d04c      	beq.n	80012fc <HAL_SPI_Transmit_DMA+0xc4>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001262:	3002      	adds	r0, #2
 8001264:	7018      	strb	r0, [r3, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001266:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 8001268:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800126a:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 800126c:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 800126e:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001270:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8001272:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8001274:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001276:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8001278:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 800127a:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800127c:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800127e:	2380      	movs	r3, #128	; 0x80
 8001280:	68a0      	ldr	r0, [r4, #8]
 8001282:	6822      	ldr	r2, [r4, #0]
 8001284:	021b      	lsls	r3, r3, #8
 8001286:	4298      	cmp	r0, r3
 8001288:	d108      	bne.n	800129c <HAL_SPI_Transmit_DMA+0x64>
    __HAL_SPI_DISABLE(hspi);
 800128a:	2040      	movs	r0, #64	; 0x40
 800128c:	6813      	ldr	r3, [r2, #0]
 800128e:	4383      	bics	r3, r0
 8001290:	6013      	str	r3, [r2, #0]
    SPI_1LINE_TX(hspi);
 8001292:	2380      	movs	r3, #128	; 0x80
 8001294:	6810      	ldr	r0, [r2, #0]
 8001296:	01db      	lsls	r3, r3, #7
 8001298:	4303      	orrs	r3, r0
 800129a:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 800129c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800129e:	4b28      	ldr	r3, [pc, #160]	; (8001340 <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80012a0:	6857      	ldr	r7, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 80012a2:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 80012a4:	4b27      	ldr	r3, [pc, #156]	; (8001344 <HAL_SPI_Transmit_DMA+0x10c>)
 80012a6:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 80012a8:	4b27      	ldr	r3, [pc, #156]	; (8001348 <HAL_SPI_Transmit_DMA+0x110>)
 80012aa:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 80012ac:	2300      	movs	r3, #0
 80012ae:	6343      	str	r3, [r0, #52]	; 0x34
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80012b0:	4b26      	ldr	r3, [pc, #152]	; (800134c <HAL_SPI_Transmit_DMA+0x114>)
 80012b2:	401f      	ands	r7, r3
 80012b4:	469c      	mov	ip, r3
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80012b6:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80012b8:	6057      	str	r7, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80012ba:	68e7      	ldr	r7, [r4, #12]
 80012bc:	00db      	lsls	r3, r3, #3
 80012be:	429f      	cmp	r7, r3
 80012c0:	d80e      	bhi.n	80012e0 <HAL_SPI_Transmit_DMA+0xa8>
 80012c2:	2380      	movs	r3, #128	; 0x80
 80012c4:	6947      	ldr	r7, [r0, #20]
 80012c6:	00db      	lsls	r3, r3, #3
 80012c8:	429f      	cmp	r7, r3
 80012ca:	d109      	bne.n	80012e0 <HAL_SPI_Transmit_DMA+0xa8>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 80012cc:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80012ce:	07db      	lsls	r3, r3, #31
 80012d0:	d418      	bmi.n	8001304 <HAL_SPI_Transmit_DMA+0xcc>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80012d2:	4667      	mov	r7, ip
 80012d4:	6853      	ldr	r3, [r2, #4]
 80012d6:	403b      	ands	r3, r7
 80012d8:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 80012da:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80012dc:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80012de:	87e3      	strh	r3, [r4, #62]	; 0x3e
                                 hspi->TxXferCount))
 80012e0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 80012e2:	320c      	adds	r2, #12
                                 hspi->TxXferCount))
 80012e4:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 80012e6:	f7ff fa23 	bl	8000730 <HAL_DMA_Start_IT>
 80012ea:	2800      	cmp	r0, #0
 80012ec:	d013      	beq.n	8001316 <HAL_SPI_Transmit_DMA+0xde>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 80012ee:	2310      	movs	r3, #16
 80012f0:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80012f2:	4313      	orrs	r3, r2
 80012f4:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->State = HAL_SPI_STATE_READY;
 80012f6:	2301      	movs	r3, #1
 80012f8:	345d      	adds	r4, #93	; 0x5d
 80012fa:	7023      	strb	r3, [r4, #0]
  __HAL_UNLOCK(hspi);
 80012fc:	2300      	movs	r3, #0
 80012fe:	7033      	strb	r3, [r6, #0]
}
 8001300:	0028      	movs	r0, r5
 8001302:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8001304:	2380      	movs	r3, #128	; 0x80
 8001306:	6857      	ldr	r7, [r2, #4]
 8001308:	01db      	lsls	r3, r3, #7
 800130a:	433b      	orrs	r3, r7
 800130c:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 800130e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001310:	085b      	lsrs	r3, r3, #1
 8001312:	3301      	adds	r3, #1
 8001314:	e7e3      	b.n	80012de <HAL_SPI_Transmit_DMA+0xa6>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001316:	2240      	movs	r2, #64	; 0x40
 8001318:	6823      	ldr	r3, [r4, #0]
 800131a:	6819      	ldr	r1, [r3, #0]
 800131c:	4211      	tst	r1, r2
 800131e:	d102      	bne.n	8001326 <HAL_SPI_Transmit_DMA+0xee>
    __HAL_SPI_ENABLE(hspi);
 8001320:	6819      	ldr	r1, [r3, #0]
 8001322:	430a      	orrs	r2, r1
 8001324:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8001326:	2220      	movs	r2, #32
 8001328:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 800132a:	2500      	movs	r5, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800132c:	430a      	orrs	r2, r1
 800132e:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8001330:	2202      	movs	r2, #2
 8001332:	6859      	ldr	r1, [r3, #4]
 8001334:	430a      	orrs	r2, r1
 8001336:	605a      	str	r2, [r3, #4]
 8001338:	e7e0      	b.n	80012fc <HAL_SPI_Transmit_DMA+0xc4>
    errorcode = HAL_BUSY;
 800133a:	2502      	movs	r5, #2
 800133c:	e7de      	b.n	80012fc <HAL_SPI_Transmit_DMA+0xc4>
 800133e:	46c0      	nop			; (mov r8, r8)
 8001340:	08001353 	.word	0x08001353
 8001344:	08001383 	.word	0x08001383
 8001348:	0800135f 	.word	0x0800135f
 800134c:	ffffbfff 	.word	0xffffbfff

08001350 <HAL_SPI_TxHalfCpltCallback>:
 8001350:	4770      	bx	lr

08001352 <SPI_DMAHalfTransmitCplt>:
{
 8001352:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8001354:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8001356:	f7ff fffb 	bl	8001350 <HAL_SPI_TxHalfCpltCallback>
}
 800135a:	bd10      	pop	{r4, pc}

0800135c <HAL_SPI_ErrorCallback>:
 800135c:	4770      	bx	lr

0800135e <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800135e:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8001360:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8001362:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8001364:	6802      	ldr	r2, [r0, #0]
 8001366:	6853      	ldr	r3, [r2, #4]
 8001368:	438b      	bics	r3, r1
 800136a:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 800136c:	2310      	movs	r3, #16
 800136e:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8001370:	4313      	orrs	r3, r2
 8001372:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8001374:	0003      	movs	r3, r0
 8001376:	2201      	movs	r2, #1
 8001378:	335d      	adds	r3, #93	; 0x5d
 800137a:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 800137c:	f7ff ffee 	bl	800135c <HAL_SPI_ErrorCallback>
}
 8001380:	bd10      	pop	{r4, pc}

08001382 <SPI_DMATransmitCplt>:
{
 8001382:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8001384:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8001386:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8001388:	f7ff f964 	bl	8000654 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800138c:	682b      	ldr	r3, [r5, #0]
 800138e:	2520      	movs	r5, #32
 8001390:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 8001392:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8001394:	422b      	tst	r3, r5
 8001396:	d127      	bne.n	80013e8 <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8001398:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800139a:	6823      	ldr	r3, [r4, #0]
 800139c:	6859      	ldr	r1, [r3, #4]
 800139e:	43a9      	bics	r1, r5
 80013a0:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80013a2:	6859      	ldr	r1, [r3, #4]
 80013a4:	4381      	bics	r1, r0
 80013a6:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80013a8:	0020      	movs	r0, r4
 80013aa:	2164      	movs	r1, #100	; 0x64
 80013ac:	f7ff fea8 	bl	8001100 <SPI_EndRxTxTransaction>
 80013b0:	2800      	cmp	r0, #0
 80013b2:	d002      	beq.n	80013ba <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80013b4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80013b6:	431d      	orrs	r5, r3
 80013b8:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80013ba:	68a3      	ldr	r3, [r4, #8]
 80013bc:	2b00      	cmp	r3, #0
 80013be:	d106      	bne.n	80013ce <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80013c0:	9301      	str	r3, [sp, #4]
 80013c2:	6823      	ldr	r3, [r4, #0]
 80013c4:	68da      	ldr	r2, [r3, #12]
 80013c6:	9201      	str	r2, [sp, #4]
 80013c8:	689b      	ldr	r3, [r3, #8]
 80013ca:	9301      	str	r3, [sp, #4]
 80013cc:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 80013ce:	2300      	movs	r3, #0
 80013d0:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80013d2:	0023      	movs	r3, r4
 80013d4:	2201      	movs	r2, #1
 80013d6:	335d      	adds	r3, #93	; 0x5d
 80013d8:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80013da:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80013dc:	2b00      	cmp	r3, #0
 80013de:	d003      	beq.n	80013e8 <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 80013e0:	0020      	movs	r0, r4
 80013e2:	f7ff ffbb 	bl	800135c <HAL_SPI_ErrorCallback>
}
 80013e6:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 80013e8:	0020      	movs	r0, r4
 80013ea:	f7fe ffb7 	bl	800035c <HAL_SPI_TxCpltCallback>
 80013ee:	e7fa      	b.n	80013e6 <SPI_DMATransmitCplt+0x64>

080013f0 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80013f0:	4770      	bx	lr
	...

080013f4 <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 80013f4:	0002      	movs	r2, r0
{
 80013f6:	0003      	movs	r3, r0
  {
    return HAL_ERROR;
 80013f8:	2001      	movs	r0, #1
  if (htim->State != HAL_TIM_STATE_READY)
 80013fa:	323d      	adds	r2, #61	; 0x3d
 80013fc:	7811      	ldrb	r1, [r2, #0]
 80013fe:	4281      	cmp	r1, r0
 8001400:	d115      	bne.n	800142e <HAL_TIM_Base_Start_IT+0x3a>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8001402:	2102      	movs	r1, #2
 8001404:	7011      	strb	r1, [r2, #0]

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001406:	681b      	ldr	r3, [r3, #0]
 8001408:	68da      	ldr	r2, [r3, #12]
 800140a:	4302      	orrs	r2, r0
 800140c:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800140e:	4a0b      	ldr	r2, [pc, #44]	; (800143c <HAL_TIM_Base_Start_IT+0x48>)
 8001410:	4293      	cmp	r3, r2
 8001412:	d002      	beq.n	800141a <HAL_TIM_Base_Start_IT+0x26>
 8001414:	4a0a      	ldr	r2, [pc, #40]	; (8001440 <HAL_TIM_Base_Start_IT+0x4c>)
 8001416:	4293      	cmp	r3, r2
 8001418:	d10a      	bne.n	8001430 <HAL_TIM_Base_Start_IT+0x3c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800141a:	2107      	movs	r1, #7
 800141c:	689a      	ldr	r2, [r3, #8]
  {
    __HAL_TIM_ENABLE(htim);
  }

  /* Return function status */
  return HAL_OK;
 800141e:	2000      	movs	r0, #0
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001420:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8001422:	2a06      	cmp	r2, #6
 8001424:	d003      	beq.n	800142e <HAL_TIM_Base_Start_IT+0x3a>
      __HAL_TIM_ENABLE(htim);
 8001426:	2201      	movs	r2, #1
 8001428:	6819      	ldr	r1, [r3, #0]
 800142a:	430a      	orrs	r2, r1
 800142c:	601a      	str	r2, [r3, #0]
}
 800142e:	4770      	bx	lr
    __HAL_TIM_ENABLE(htim);
 8001430:	681a      	ldr	r2, [r3, #0]
 8001432:	4310      	orrs	r0, r2
 8001434:	6018      	str	r0, [r3, #0]
  return HAL_OK;
 8001436:	2000      	movs	r0, #0
 8001438:	e7f9      	b.n	800142e <HAL_TIM_Base_Start_IT+0x3a>
 800143a:	46c0      	nop			; (mov r8, r8)
 800143c:	40012c00 	.word	0x40012c00
 8001440:	40000400 	.word	0x40000400

08001444 <HAL_TIM_OC_DelayElapsedCallback>:
 8001444:	4770      	bx	lr

08001446 <HAL_TIM_IC_CaptureCallback>:
 8001446:	4770      	bx	lr

08001448 <HAL_TIM_PWM_PulseFinishedCallback>:
 8001448:	4770      	bx	lr

0800144a <HAL_TIM_TriggerCallback>:
 800144a:	4770      	bx	lr

0800144c <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800144c:	2202      	movs	r2, #2
 800144e:	6803      	ldr	r3, [r0, #0]
{
 8001450:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001452:	6919      	ldr	r1, [r3, #16]
{
 8001454:	0004      	movs	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001456:	4211      	tst	r1, r2
 8001458:	d00e      	beq.n	8001478 <HAL_TIM_IRQHandler+0x2c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800145a:	68d9      	ldr	r1, [r3, #12]
 800145c:	4211      	tst	r1, r2
 800145e:	d00b      	beq.n	8001478 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8001460:	3a05      	subs	r2, #5
 8001462:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001464:	3204      	adds	r2, #4
 8001466:	7702      	strb	r2, [r0, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001468:	699b      	ldr	r3, [r3, #24]
 800146a:	079b      	lsls	r3, r3, #30
 800146c:	d100      	bne.n	8001470 <HAL_TIM_IRQHandler+0x24>
 800146e:	e079      	b.n	8001564 <HAL_TIM_IRQHandler+0x118>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8001470:	f7ff ffe9 	bl	8001446 <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001474:	2300      	movs	r3, #0
 8001476:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001478:	2204      	movs	r2, #4
 800147a:	6823      	ldr	r3, [r4, #0]
 800147c:	6919      	ldr	r1, [r3, #16]
 800147e:	4211      	tst	r1, r2
 8001480:	d010      	beq.n	80014a4 <HAL_TIM_IRQHandler+0x58>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8001482:	68d9      	ldr	r1, [r3, #12]
 8001484:	4211      	tst	r1, r2
 8001486:	d00d      	beq.n	80014a4 <HAL_TIM_IRQHandler+0x58>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8001488:	3a09      	subs	r2, #9
 800148a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800148c:	3207      	adds	r2, #7
 800148e:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001490:	699a      	ldr	r2, [r3, #24]
 8001492:	23c0      	movs	r3, #192	; 0xc0
 8001494:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8001496:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001498:	421a      	tst	r2, r3
 800149a:	d069      	beq.n	8001570 <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_IC_CaptureCallback(htim);
 800149c:	f7ff ffd3 	bl	8001446 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80014a0:	2300      	movs	r3, #0
 80014a2:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80014a4:	2208      	movs	r2, #8
 80014a6:	6823      	ldr	r3, [r4, #0]
 80014a8:	6919      	ldr	r1, [r3, #16]
 80014aa:	4211      	tst	r1, r2
 80014ac:	d00e      	beq.n	80014cc <HAL_TIM_IRQHandler+0x80>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 80014ae:	68d9      	ldr	r1, [r3, #12]
 80014b0:	4211      	tst	r1, r2
 80014b2:	d00b      	beq.n	80014cc <HAL_TIM_IRQHandler+0x80>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80014b4:	3a11      	subs	r2, #17
 80014b6:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80014b8:	320d      	adds	r2, #13
 80014ba:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80014bc:	69db      	ldr	r3, [r3, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80014be:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80014c0:	079b      	lsls	r3, r3, #30
 80014c2:	d05b      	beq.n	800157c <HAL_TIM_IRQHandler+0x130>
        HAL_TIM_IC_CaptureCallback(htim);
 80014c4:	f7ff ffbf 	bl	8001446 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80014c8:	2300      	movs	r3, #0
 80014ca:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80014cc:	2210      	movs	r2, #16
 80014ce:	6823      	ldr	r3, [r4, #0]
 80014d0:	6919      	ldr	r1, [r3, #16]
 80014d2:	4211      	tst	r1, r2
 80014d4:	d010      	beq.n	80014f8 <HAL_TIM_IRQHandler+0xac>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80014d6:	68d9      	ldr	r1, [r3, #12]
 80014d8:	4211      	tst	r1, r2
 80014da:	d00d      	beq.n	80014f8 <HAL_TIM_IRQHandler+0xac>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80014dc:	3a21      	subs	r2, #33	; 0x21
 80014de:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80014e0:	3219      	adds	r2, #25
 80014e2:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80014e4:	69da      	ldr	r2, [r3, #28]
 80014e6:	23c0      	movs	r3, #192	; 0xc0
 80014e8:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80014ea:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80014ec:	421a      	tst	r2, r3
 80014ee:	d04b      	beq.n	8001588 <HAL_TIM_IRQHandler+0x13c>
        HAL_TIM_IC_CaptureCallback(htim);
 80014f0:	f7ff ffa9 	bl	8001446 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80014f4:	2300      	movs	r3, #0
 80014f6:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80014f8:	2201      	movs	r2, #1
 80014fa:	6823      	ldr	r3, [r4, #0]
 80014fc:	6919      	ldr	r1, [r3, #16]
 80014fe:	4211      	tst	r1, r2
 8001500:	d007      	beq.n	8001512 <HAL_TIM_IRQHandler+0xc6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8001502:	68d9      	ldr	r1, [r3, #12]
 8001504:	4211      	tst	r1, r2
 8001506:	d004      	beq.n	8001512 <HAL_TIM_IRQHandler+0xc6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8001508:	3a03      	subs	r2, #3
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800150a:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800150c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800150e:	f7fe ff3f 	bl	8000390 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001512:	2280      	movs	r2, #128	; 0x80
 8001514:	6823      	ldr	r3, [r4, #0]
 8001516:	6919      	ldr	r1, [r3, #16]
 8001518:	4211      	tst	r1, r2
 800151a:	d008      	beq.n	800152e <HAL_TIM_IRQHandler+0xe2>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800151c:	68d9      	ldr	r1, [r3, #12]
 800151e:	4211      	tst	r1, r2
 8001520:	d005      	beq.n	800152e <HAL_TIM_IRQHandler+0xe2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001522:	3a02      	subs	r2, #2
 8001524:	3aff      	subs	r2, #255	; 0xff
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8001526:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001528:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800152a:	f000 f89c 	bl	8001666 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800152e:	2240      	movs	r2, #64	; 0x40
 8001530:	6823      	ldr	r3, [r4, #0]
 8001532:	6919      	ldr	r1, [r3, #16]
 8001534:	4211      	tst	r1, r2
 8001536:	d007      	beq.n	8001548 <HAL_TIM_IRQHandler+0xfc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8001538:	68d9      	ldr	r1, [r3, #12]
 800153a:	4211      	tst	r1, r2
 800153c:	d004      	beq.n	8001548 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800153e:	3a81      	subs	r2, #129	; 0x81
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8001540:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8001542:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8001544:	f7ff ff81 	bl	800144a <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8001548:	2220      	movs	r2, #32
 800154a:	6823      	ldr	r3, [r4, #0]
 800154c:	6919      	ldr	r1, [r3, #16]
 800154e:	4211      	tst	r1, r2
 8001550:	d007      	beq.n	8001562 <HAL_TIM_IRQHandler+0x116>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8001552:	68d9      	ldr	r1, [r3, #12]
 8001554:	4211      	tst	r1, r2
 8001556:	d004      	beq.n	8001562 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8001558:	3a41      	subs	r2, #65	; 0x41
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800155a:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800155c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 800155e:	f000 f881 	bl	8001664 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8001562:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001564:	f7ff ff6e 	bl	8001444 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001568:	0020      	movs	r0, r4
 800156a:	f7ff ff6d 	bl	8001448 <HAL_TIM_PWM_PulseFinishedCallback>
 800156e:	e781      	b.n	8001474 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001570:	f7ff ff68 	bl	8001444 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001574:	0020      	movs	r0, r4
 8001576:	f7ff ff67 	bl	8001448 <HAL_TIM_PWM_PulseFinishedCallback>
 800157a:	e791      	b.n	80014a0 <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800157c:	f7ff ff62 	bl	8001444 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001580:	0020      	movs	r0, r4
 8001582:	f7ff ff61 	bl	8001448 <HAL_TIM_PWM_PulseFinishedCallback>
 8001586:	e79f      	b.n	80014c8 <HAL_TIM_IRQHandler+0x7c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001588:	f7ff ff5c 	bl	8001444 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800158c:	0020      	movs	r0, r4
 800158e:	f7ff ff5b 	bl	8001448 <HAL_TIM_PWM_PulseFinishedCallback>
 8001592:	e7af      	b.n	80014f4 <HAL_TIM_IRQHandler+0xa8>

08001594 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001594:	4a19      	ldr	r2, [pc, #100]	; (80015fc <TIM_Base_SetConfig+0x68>)
{
 8001596:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8001598:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800159a:	4290      	cmp	r0, r2
 800159c:	d002      	beq.n	80015a4 <TIM_Base_SetConfig+0x10>
 800159e:	4c18      	ldr	r4, [pc, #96]	; (8001600 <TIM_Base_SetConfig+0x6c>)
 80015a0:	42a0      	cmp	r0, r4
 80015a2:	d108      	bne.n	80015b6 <TIM_Base_SetConfig+0x22>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80015a4:	2470      	movs	r4, #112	; 0x70
 80015a6:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 80015a8:	684c      	ldr	r4, [r1, #4]
 80015aa:	4323      	orrs	r3, r4
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80015ac:	4290      	cmp	r0, r2
 80015ae:	d00b      	beq.n	80015c8 <TIM_Base_SetConfig+0x34>
 80015b0:	4c13      	ldr	r4, [pc, #76]	; (8001600 <TIM_Base_SetConfig+0x6c>)
 80015b2:	42a0      	cmp	r0, r4
 80015b4:	d008      	beq.n	80015c8 <TIM_Base_SetConfig+0x34>
 80015b6:	4c13      	ldr	r4, [pc, #76]	; (8001604 <TIM_Base_SetConfig+0x70>)
 80015b8:	42a0      	cmp	r0, r4
 80015ba:	d005      	beq.n	80015c8 <TIM_Base_SetConfig+0x34>
 80015bc:	4c12      	ldr	r4, [pc, #72]	; (8001608 <TIM_Base_SetConfig+0x74>)
 80015be:	42a0      	cmp	r0, r4
 80015c0:	d002      	beq.n	80015c8 <TIM_Base_SetConfig+0x34>
 80015c2:	4c12      	ldr	r4, [pc, #72]	; (800160c <TIM_Base_SetConfig+0x78>)
 80015c4:	42a0      	cmp	r0, r4
 80015c6:	d103      	bne.n	80015d0 <TIM_Base_SetConfig+0x3c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80015c8:	4c11      	ldr	r4, [pc, #68]	; (8001610 <TIM_Base_SetConfig+0x7c>)
 80015ca:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80015cc:	68cc      	ldr	r4, [r1, #12]
 80015ce:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80015d0:	2480      	movs	r4, #128	; 0x80
 80015d2:	43a3      	bics	r3, r4
 80015d4:	694c      	ldr	r4, [r1, #20]
 80015d6:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 80015d8:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80015da:	688b      	ldr	r3, [r1, #8]
 80015dc:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80015de:	680b      	ldr	r3, [r1, #0]
 80015e0:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80015e2:	4290      	cmp	r0, r2
 80015e4:	d005      	beq.n	80015f2 <TIM_Base_SetConfig+0x5e>
 80015e6:	4b08      	ldr	r3, [pc, #32]	; (8001608 <TIM_Base_SetConfig+0x74>)
 80015e8:	4298      	cmp	r0, r3
 80015ea:	d002      	beq.n	80015f2 <TIM_Base_SetConfig+0x5e>
 80015ec:	4b07      	ldr	r3, [pc, #28]	; (800160c <TIM_Base_SetConfig+0x78>)
 80015ee:	4298      	cmp	r0, r3
 80015f0:	d101      	bne.n	80015f6 <TIM_Base_SetConfig+0x62>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80015f2:	690b      	ldr	r3, [r1, #16]
 80015f4:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80015f6:	2301      	movs	r3, #1
 80015f8:	6143      	str	r3, [r0, #20]
}
 80015fa:	bd10      	pop	{r4, pc}
 80015fc:	40012c00 	.word	0x40012c00
 8001600:	40000400 	.word	0x40000400
 8001604:	40002000 	.word	0x40002000
 8001608:	40014400 	.word	0x40014400
 800160c:	40014800 	.word	0x40014800
 8001610:	fffffcff 	.word	0xfffffcff

08001614 <HAL_TIM_Base_Init>:
{
 8001614:	b570      	push	{r4, r5, r6, lr}
 8001616:	0004      	movs	r4, r0
    return HAL_ERROR;
 8001618:	2001      	movs	r0, #1
  if (htim == NULL)
 800161a:	2c00      	cmp	r4, #0
 800161c:	d021      	beq.n	8001662 <HAL_TIM_Base_Init+0x4e>
  if (htim->State == HAL_TIM_STATE_RESET)
 800161e:	0025      	movs	r5, r4
 8001620:	353d      	adds	r5, #61	; 0x3d
 8001622:	782b      	ldrb	r3, [r5, #0]
 8001624:	b2da      	uxtb	r2, r3
 8001626:	2b00      	cmp	r3, #0
 8001628:	d105      	bne.n	8001636 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 800162a:	0023      	movs	r3, r4
 800162c:	333c      	adds	r3, #60	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800162e:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 8001630:	701a      	strb	r2, [r3, #0]
    HAL_TIM_Base_MspInit(htim);
 8001632:	f7ff fedd 	bl	80013f0 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 8001636:	2302      	movs	r3, #2
 8001638:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800163a:	6820      	ldr	r0, [r4, #0]
 800163c:	1d21      	adds	r1, r4, #4
 800163e:	f7ff ffa9 	bl	8001594 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001642:	0022      	movs	r2, r4
 8001644:	2301      	movs	r3, #1
  return HAL_OK;
 8001646:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001648:	3246      	adds	r2, #70	; 0x46
 800164a:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800164c:	3445      	adds	r4, #69	; 0x45
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800164e:	3a08      	subs	r2, #8
 8001650:	7013      	strb	r3, [r2, #0]
 8001652:	7053      	strb	r3, [r2, #1]
 8001654:	7093      	strb	r3, [r2, #2]
 8001656:	70d3      	strb	r3, [r2, #3]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001658:	7113      	strb	r3, [r2, #4]
 800165a:	7153      	strb	r3, [r2, #5]
 800165c:	7193      	strb	r3, [r2, #6]
 800165e:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 8001660:	702b      	strb	r3, [r5, #0]
}
 8001662:	bd70      	pop	{r4, r5, r6, pc}

08001664 <HAL_TIMEx_CommutCallback>:
 8001664:	4770      	bx	lr

08001666 <HAL_TIMEx_BreakCallback>:
 8001666:	4770      	bx	lr

08001668 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001668:	0003      	movs	r3, r0

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 800166a:	2201      	movs	r2, #1
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800166c:	3308      	adds	r3, #8
 800166e:	6043      	str	r3, [r0, #4]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001670:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001672:	6103      	str	r3, [r0, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001674:	2300      	movs	r3, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001676:	4252      	negs	r2, r2
 8001678:	6082      	str	r2, [r0, #8]
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800167a:	6003      	str	r3, [r0, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800167c:	4770      	bx	lr

0800167e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 800167e:	2300      	movs	r3, #0
 8001680:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8001682:	4770      	bx	lr

08001684 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
 8001684:	6843      	ldr	r3, [r0, #4]

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8001686:	689a      	ldr	r2, [r3, #8]
    pxNewListItem->pxNext = pxIndex;
 8001688:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800168a:	608a      	str	r2, [r1, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 800168c:	689a      	ldr	r2, [r3, #8]
 800168e:	6051      	str	r1, [r2, #4]
    pxIndex->pxPrevious = pxNewListItem;
 8001690:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 8001692:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 8001694:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 8001696:	3301      	adds	r3, #1
 8001698:	6003      	str	r3, [r0, #0]
}
 800169a:	4770      	bx	lr

0800169c <vListInsert>:
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800169c:	0002      	movs	r2, r0
{
 800169e:	b530      	push	{r4, r5, lr}
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80016a0:	680c      	ldr	r4, [r1, #0]
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80016a2:	3208      	adds	r2, #8
    if( xValueOfInsertion == portMAX_DELAY )
 80016a4:	1c63      	adds	r3, r4, #1
 80016a6:	d10a      	bne.n	80016be <vListInsert+0x22>
        pxIterator = pxList->xListEnd.pxPrevious;
 80016a8:	6903      	ldr	r3, [r0, #16]
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 80016aa:	685a      	ldr	r2, [r3, #4]
 80016ac:	604a      	str	r2, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80016ae:	6091      	str	r1, [r2, #8]
    pxNewListItem->pxPrevious = pxIterator;
 80016b0:	608b      	str	r3, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 80016b2:	6059      	str	r1, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 80016b4:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 80016b6:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 80016b8:	3301      	adds	r3, #1
 80016ba:	6003      	str	r3, [r0, #0]
}
 80016bc:	bd30      	pop	{r4, r5, pc}
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80016be:	0013      	movs	r3, r2
 80016c0:	6852      	ldr	r2, [r2, #4]
 80016c2:	6815      	ldr	r5, [r2, #0]
 80016c4:	42a5      	cmp	r5, r4
 80016c6:	d9fa      	bls.n	80016be <vListInsert+0x22>
 80016c8:	e7ef      	b.n	80016aa <vListInsert+0xe>

080016ca <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 80016ca:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80016cc:	6841      	ldr	r1, [r0, #4]
 80016ce:	6882      	ldr	r2, [r0, #8]
 80016d0:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80016d2:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 80016d4:	6859      	ldr	r1, [r3, #4]
 80016d6:	4281      	cmp	r1, r0
 80016d8:	d100      	bne.n	80016dc <uxListRemove+0x12>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 80016da:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 80016dc:	2200      	movs	r2, #0
 80016de:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 80016e0:	681a      	ldr	r2, [r3, #0]
 80016e2:	3a01      	subs	r2, #1
 80016e4:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 80016e6:	6818      	ldr	r0, [r3, #0]
}
 80016e8:	4770      	bx	lr

080016ea <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 80016ea:	b510      	push	{r4, lr}
 80016ec:	0004      	movs	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 80016ee:	f001 f87f 	bl	80027f0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80016f2:	6ba4      	ldr	r4, [r4, #56]	; 0x38
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 80016f4:	f001 f888 	bl	8002808 <vPortExitCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80016f8:	4260      	negs	r0, r4
 80016fa:	4160      	adcs	r0, r4

    return xReturn;
}
 80016fc:	bd10      	pop	{r4, pc}

080016fe <prvCopyDataToQueue>:
{
 80016fe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001700:	0015      	movs	r5, r2
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001702:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8001704:	0004      	movs	r4, r0
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001706:	6b86      	ldr	r6, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001708:	2a00      	cmp	r2, #0
 800170a:	d10c      	bne.n	8001726 <prvCopyDataToQueue+0x28>
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800170c:	6807      	ldr	r7, [r0, #0]
    BaseType_t xReturn = pdFALSE;
 800170e:	0015      	movs	r5, r2
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001710:	2f00      	cmp	r7, #0
 8001712:	d104      	bne.n	800171e <prvCopyDataToQueue+0x20>
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8001714:	6880      	ldr	r0, [r0, #8]
 8001716:	f000 fd9f 	bl	8002258 <xTaskPriorityDisinherit>
 800171a:	0005      	movs	r5, r0
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800171c:	60a7      	str	r7, [r4, #8]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800171e:	3601      	adds	r6, #1
}
 8001720:	0028      	movs	r0, r5
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8001722:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8001724:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if( xPosition == queueSEND_TO_BACK )
 8001726:	2d00      	cmp	r5, #0
 8001728:	d10c      	bne.n	8001744 <prvCopyDataToQueue+0x46>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800172a:	6840      	ldr	r0, [r0, #4]
 800172c:	f001 f9f0 	bl	8002b10 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001730:	6863      	ldr	r3, [r4, #4]
 8001732:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001734:	189b      	adds	r3, r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001736:	68a2      	ldr	r2, [r4, #8]
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001738:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800173a:	4293      	cmp	r3, r2
 800173c:	d3ef      	bcc.n	800171e <prvCopyDataToQueue+0x20>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 800173e:	6823      	ldr	r3, [r4, #0]
 8001740:	6063      	str	r3, [r4, #4]
 8001742:	e7ec      	b.n	800171e <prvCopyDataToQueue+0x20>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8001744:	68c0      	ldr	r0, [r0, #12]
 8001746:	f001 f9e3 	bl	8002b10 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800174a:	68e3      	ldr	r3, [r4, #12]
 800174c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800174e:	4251      	negs	r1, r2
 8001750:	1a9a      	subs	r2, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001752:	6823      	ldr	r3, [r4, #0]
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8001754:	60e2      	str	r2, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001756:	429a      	cmp	r2, r3
 8001758:	d202      	bcs.n	8001760 <prvCopyDataToQueue+0x62>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 800175a:	68a3      	ldr	r3, [r4, #8]
 800175c:	1859      	adds	r1, r3, r1
 800175e:	60e1      	str	r1, [r4, #12]
        if( xPosition == queueOVERWRITE )
 8001760:	2d02      	cmp	r5, #2
 8001762:	d105      	bne.n	8001770 <prvCopyDataToQueue+0x72>
                --uxMessagesWaiting;
 8001764:	0033      	movs	r3, r6
 8001766:	1e5a      	subs	r2, r3, #1
 8001768:	4193      	sbcs	r3, r2
    BaseType_t xReturn = pdFALSE;
 800176a:	2500      	movs	r5, #0
                --uxMessagesWaiting;
 800176c:	1af6      	subs	r6, r6, r3
 800176e:	e7d6      	b.n	800171e <prvCopyDataToQueue+0x20>
    BaseType_t xReturn = pdFALSE;
 8001770:	2500      	movs	r5, #0
 8001772:	e7d4      	b.n	800171e <prvCopyDataToQueue+0x20>

08001774 <prvCopyDataFromQueue>:
{
 8001774:	0003      	movs	r3, r0
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001776:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8001778:	0008      	movs	r0, r1
 800177a:	b510      	push	{r4, lr}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800177c:	2a00      	cmp	r2, #0
 800177e:	d00a      	beq.n	8001796 <prvCopyDataFromQueue+0x22>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001780:	68d9      	ldr	r1, [r3, #12]
 8001782:	188c      	adds	r4, r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001784:	6899      	ldr	r1, [r3, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001786:	60dc      	str	r4, [r3, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001788:	428c      	cmp	r4, r1
 800178a:	d301      	bcc.n	8001790 <prvCopyDataFromQueue+0x1c>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800178c:	6819      	ldr	r1, [r3, #0]
 800178e:	60d9      	str	r1, [r3, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8001790:	68d9      	ldr	r1, [r3, #12]
 8001792:	f001 f9bd 	bl	8002b10 <memcpy>
}
 8001796:	bd10      	pop	{r4, pc}

08001798 <prvUnlockQueue>:
{
 8001798:	b570      	push	{r4, r5, r6, lr}
 800179a:	0004      	movs	r4, r0
        int8_t cTxLock = pxQueue->cTxLock;
 800179c:	0026      	movs	r6, r4
 800179e:	3645      	adds	r6, #69	; 0x45
    taskENTER_CRITICAL();
 80017a0:	f001 f826 	bl	80027f0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80017a4:	7835      	ldrb	r5, [r6, #0]
 80017a6:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80017a8:	2d00      	cmp	r5, #0
 80017aa:	dc10      	bgt.n	80017ce <prvUnlockQueue+0x36>
        pxQueue->cTxLock = queueUNLOCKED;
 80017ac:	23ff      	movs	r3, #255	; 0xff
 80017ae:	7033      	strb	r3, [r6, #0]
        int8_t cRxLock = pxQueue->cRxLock;
 80017b0:	0026      	movs	r6, r4
 80017b2:	3644      	adds	r6, #68	; 0x44
    taskEXIT_CRITICAL();
 80017b4:	f001 f828 	bl	8002808 <vPortExitCritical>
    taskENTER_CRITICAL();
 80017b8:	f001 f81a 	bl	80027f0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80017bc:	7835      	ldrb	r5, [r6, #0]
 80017be:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80017c0:	2d00      	cmp	r5, #0
 80017c2:	dc11      	bgt.n	80017e8 <prvUnlockQueue+0x50>
        pxQueue->cRxLock = queueUNLOCKED;
 80017c4:	23ff      	movs	r3, #255	; 0xff
 80017c6:	7033      	strb	r3, [r6, #0]
    taskEXIT_CRITICAL();
 80017c8:	f001 f81e 	bl	8002808 <vPortExitCritical>
}
 80017cc:	bd70      	pop	{r4, r5, r6, pc}
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80017ce:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80017d0:	2b00      	cmp	r3, #0
 80017d2:	d0eb      	beq.n	80017ac <prvUnlockQueue+0x14>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80017d4:	0020      	movs	r0, r4
 80017d6:	3024      	adds	r0, #36	; 0x24
 80017d8:	f000 fcae 	bl	8002138 <xTaskRemoveFromEventList>
 80017dc:	2800      	cmp	r0, #0
 80017de:	d001      	beq.n	80017e4 <prvUnlockQueue+0x4c>
                            vTaskMissedYield();
 80017e0:	f000 fd24 	bl	800222c <vTaskMissedYield>
            --cTxLock;
 80017e4:	3d01      	subs	r5, #1
 80017e6:	e7de      	b.n	80017a6 <prvUnlockQueue+0xe>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80017e8:	6923      	ldr	r3, [r4, #16]
 80017ea:	2b00      	cmp	r3, #0
 80017ec:	d0ea      	beq.n	80017c4 <prvUnlockQueue+0x2c>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80017ee:	0020      	movs	r0, r4
 80017f0:	3010      	adds	r0, #16
 80017f2:	f000 fca1 	bl	8002138 <xTaskRemoveFromEventList>
 80017f6:	2800      	cmp	r0, #0
 80017f8:	d001      	beq.n	80017fe <prvUnlockQueue+0x66>
                    vTaskMissedYield();
 80017fa:	f000 fd17 	bl	800222c <vTaskMissedYield>
                --cRxLock;
 80017fe:	3d01      	subs	r5, #1
 8001800:	e7dd      	b.n	80017be <prvUnlockQueue+0x26>

08001802 <xQueueGenericReset>:
{
 8001802:	b570      	push	{r4, r5, r6, lr}
 8001804:	0004      	movs	r4, r0
 8001806:	000d      	movs	r5, r1
    configASSERT( pxQueue );
 8001808:	2800      	cmp	r0, #0
 800180a:	d101      	bne.n	8001810 <xQueueGenericReset+0xe>
 800180c:	b672      	cpsid	i
 800180e:	e7fe      	b.n	800180e <xQueueGenericReset+0xc>
    taskENTER_CRITICAL();
 8001810:	f000 ffee 	bl	80027f0 <vPortEnterCritical>
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001814:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001816:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001818:	6822      	ldr	r2, [r4, #0]
 800181a:	434b      	muls	r3, r1
 800181c:	18d0      	adds	r0, r2, r3
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800181e:	1a5b      	subs	r3, r3, r1
 8001820:	18d3      	adds	r3, r2, r3
 8001822:	60e3      	str	r3, [r4, #12]
        pxQueue->cRxLock = queueUNLOCKED;
 8001824:	0023      	movs	r3, r4
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001826:	60a0      	str	r0, [r4, #8]
        pxQueue->pcWriteTo = pxQueue->pcHead;
 8001828:	6062      	str	r2, [r4, #4]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800182a:	2000      	movs	r0, #0
        pxQueue->cRxLock = queueUNLOCKED;
 800182c:	22ff      	movs	r2, #255	; 0xff
 800182e:	3344      	adds	r3, #68	; 0x44
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001830:	63a0      	str	r0, [r4, #56]	; 0x38
        pxQueue->cRxLock = queueUNLOCKED;
 8001832:	701a      	strb	r2, [r3, #0]
        pxQueue->cTxLock = queueUNLOCKED;
 8001834:	705a      	strb	r2, [r3, #1]
        if( xNewQueue == pdFALSE )
 8001836:	4285      	cmp	r5, r0
 8001838:	d10a      	bne.n	8001850 <xQueueGenericReset+0x4e>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800183a:	6923      	ldr	r3, [r4, #16]
 800183c:	4283      	cmp	r3, r0
 800183e:	d003      	beq.n	8001848 <xQueueGenericReset+0x46>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001840:	0020      	movs	r0, r4
 8001842:	3010      	adds	r0, #16
 8001844:	f000 fc78 	bl	8002138 <xTaskRemoveFromEventList>
    taskEXIT_CRITICAL();
 8001848:	f000 ffde 	bl	8002808 <vPortExitCritical>
}
 800184c:	2001      	movs	r0, #1
 800184e:	bd70      	pop	{r4, r5, r6, pc}
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001850:	0020      	movs	r0, r4
 8001852:	3010      	adds	r0, #16
 8001854:	f7ff ff08 	bl	8001668 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001858:	0020      	movs	r0, r4
 800185a:	3024      	adds	r0, #36	; 0x24
 800185c:	f7ff ff04 	bl	8001668 <vListInitialise>
 8001860:	e7f2      	b.n	8001848 <xQueueGenericReset+0x46>

08001862 <xQueueGenericCreate>:
    {
 8001862:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001864:	0006      	movs	r6, r0
 8001866:	000d      	movs	r5, r1
 8001868:	0017      	movs	r7, r2
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800186a:	2800      	cmp	r0, #0
 800186c:	d101      	bne.n	8001872 <xQueueGenericCreate+0x10>
 800186e:	b672      	cpsid	i
 8001870:	e7fe      	b.n	8001870 <xQueueGenericCreate+0xe>
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001872:	000c      	movs	r4, r1
 8001874:	4344      	muls	r4, r0
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
 8001876:	2900      	cmp	r1, #0
 8001878:	d00b      	beq.n	8001892 <xQueueGenericCreate+0x30>
 800187a:	0020      	movs	r0, r4
 800187c:	f7fe fc58 	bl	8000130 <__udivsi3>
 8001880:	4286      	cmp	r6, r0
 8001882:	d001      	beq.n	8001888 <xQueueGenericCreate+0x26>
 8001884:	b672      	cpsid	i
 8001886:	e7fe      	b.n	8001886 <xQueueGenericCreate+0x24>
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
 8001888:	0023      	movs	r3, r4
 800188a:	3351      	adds	r3, #81	; 0x51
 800188c:	d901      	bls.n	8001892 <xQueueGenericCreate+0x30>
 800188e:	b672      	cpsid	i
 8001890:	e7fe      	b.n	8001890 <xQueueGenericCreate+0x2e>
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8001892:	0020      	movs	r0, r4
 8001894:	3050      	adds	r0, #80	; 0x50
 8001896:	f001 f863 	bl	8002960 <pvPortMalloc>
 800189a:	1e04      	subs	r4, r0, #0
        if( pxNewQueue != NULL )
 800189c:	d00d      	beq.n	80018ba <xQueueGenericCreate+0x58>
    if( uxItemSize == ( UBaseType_t ) 0 )
 800189e:	0003      	movs	r3, r0
 80018a0:	2d00      	cmp	r5, #0
 80018a2:	d000      	beq.n	80018a6 <xQueueGenericCreate+0x44>
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80018a4:	3350      	adds	r3, #80	; 0x50
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80018a6:	6023      	str	r3, [r4, #0]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80018a8:	2101      	movs	r1, #1
 80018aa:	0020      	movs	r0, r4
    pxNewQueue->uxLength = uxQueueLength;
 80018ac:	63e6      	str	r6, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 80018ae:	6425      	str	r5, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80018b0:	f7ff ffa7 	bl	8001802 <xQueueGenericReset>
            pxNewQueue->ucQueueType = ucQueueType;
 80018b4:	0023      	movs	r3, r4
 80018b6:	334c      	adds	r3, #76	; 0x4c
 80018b8:	701f      	strb	r7, [r3, #0]
    }
 80018ba:	0020      	movs	r0, r4
 80018bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080018be <xQueueGenericSend>:
{
 80018be:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018c0:	b085      	sub	sp, #20
 80018c2:	0004      	movs	r4, r0
 80018c4:	000d      	movs	r5, r1
 80018c6:	001f      	movs	r7, r3
 80018c8:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
 80018ca:	2800      	cmp	r0, #0
 80018cc:	d101      	bne.n	80018d2 <xQueueGenericSend+0x14>
 80018ce:	b672      	cpsid	i
 80018d0:	e7fe      	b.n	80018d0 <xQueueGenericSend+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80018d2:	2900      	cmp	r1, #0
 80018d4:	d104      	bne.n	80018e0 <xQueueGenericSend+0x22>
 80018d6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80018d8:	2b00      	cmp	r3, #0
 80018da:	d001      	beq.n	80018e0 <xQueueGenericSend+0x22>
 80018dc:	b672      	cpsid	i
 80018de:	e7fe      	b.n	80018de <xQueueGenericSend+0x20>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80018e0:	2f02      	cmp	r7, #2
 80018e2:	d104      	bne.n	80018ee <xQueueGenericSend+0x30>
 80018e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80018e6:	2b01      	cmp	r3, #1
 80018e8:	d001      	beq.n	80018ee <xQueueGenericSend+0x30>
 80018ea:	b672      	cpsid	i
 80018ec:	e7fe      	b.n	80018ec <xQueueGenericSend+0x2e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80018ee:	f000 fca3 	bl	8002238 <xTaskGetSchedulerState>
 80018f2:	1e06      	subs	r6, r0, #0
 80018f4:	d104      	bne.n	8001900 <xQueueGenericSend+0x42>
 80018f6:	9b01      	ldr	r3, [sp, #4]
 80018f8:	2b00      	cmp	r3, #0
 80018fa:	d04d      	beq.n	8001998 <xQueueGenericSend+0xda>
 80018fc:	b672      	cpsid	i
 80018fe:	e7fe      	b.n	80018fe <xQueueGenericSend+0x40>
 8001900:	2600      	movs	r6, #0
 8001902:	e049      	b.n	8001998 <xQueueGenericSend+0xda>
                if( xTicksToWait == ( TickType_t ) 0 )
 8001904:	9b01      	ldr	r3, [sp, #4]
 8001906:	9300      	str	r3, [sp, #0]
 8001908:	2b00      	cmp	r3, #0
 800190a:	d103      	bne.n	8001914 <xQueueGenericSend+0x56>
                    taskEXIT_CRITICAL();
 800190c:	f000 ff7c 	bl	8002808 <vPortExitCritical>
            return errQUEUE_FULL;
 8001910:	2000      	movs	r0, #0
 8001912:	e058      	b.n	80019c6 <xQueueGenericSend+0x108>
                else if( xEntryTimeSet == pdFALSE )
 8001914:	2e00      	cmp	r6, #0
 8001916:	d102      	bne.n	800191e <xQueueGenericSend+0x60>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001918:	a802      	add	r0, sp, #8
 800191a:	f000 fc49 	bl	80021b0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 800191e:	f000 ff73 	bl	8002808 <vPortExitCritical>
        vTaskSuspendAll();
 8001922:	f000 fad7 	bl	8001ed4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001926:	f000 ff63 	bl	80027f0 <vPortEnterCritical>
 800192a:	0022      	movs	r2, r4
 800192c:	3244      	adds	r2, #68	; 0x44
 800192e:	7813      	ldrb	r3, [r2, #0]
 8001930:	b25b      	sxtb	r3, r3
 8001932:	3301      	adds	r3, #1
 8001934:	d101      	bne.n	800193a <xQueueGenericSend+0x7c>
 8001936:	2300      	movs	r3, #0
 8001938:	7013      	strb	r3, [r2, #0]
 800193a:	0022      	movs	r2, r4
 800193c:	3245      	adds	r2, #69	; 0x45
 800193e:	7813      	ldrb	r3, [r2, #0]
 8001940:	b25b      	sxtb	r3, r3
 8001942:	3301      	adds	r3, #1
 8001944:	d101      	bne.n	800194a <xQueueGenericSend+0x8c>
 8001946:	2300      	movs	r3, #0
 8001948:	7013      	strb	r3, [r2, #0]
 800194a:	f000 ff5d 	bl	8002808 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800194e:	a901      	add	r1, sp, #4
 8001950:	a802      	add	r0, sp, #8
 8001952:	f000 fc39 	bl	80021c8 <xTaskCheckForTimeOut>
 8001956:	2800      	cmp	r0, #0
 8001958:	d137      	bne.n	80019ca <xQueueGenericSend+0x10c>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 800195a:	f000 ff49 	bl	80027f0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800195e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001960:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001962:	4293      	cmp	r3, r2
 8001964:	d110      	bne.n	8001988 <xQueueGenericSend+0xca>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 8001966:	f000 ff4f 	bl	8002808 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800196a:	0020      	movs	r0, r4
 800196c:	9901      	ldr	r1, [sp, #4]
 800196e:	3010      	adds	r0, #16
 8001970:	f000 fbb8 	bl	80020e4 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001974:	0020      	movs	r0, r4
 8001976:	f7ff ff0f 	bl	8001798 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 800197a:	f000 fb1b 	bl	8001fb4 <xTaskResumeAll>
 800197e:	2800      	cmp	r0, #0
 8001980:	d109      	bne.n	8001996 <xQueueGenericSend+0xd8>
                    portYIELD_WITHIN_API();
 8001982:	f000 ff29 	bl	80027d8 <vPortYield>
 8001986:	e006      	b.n	8001996 <xQueueGenericSend+0xd8>
    taskEXIT_CRITICAL();
 8001988:	f000 ff3e 	bl	8002808 <vPortExitCritical>
                prvUnlockQueue( pxQueue );
 800198c:	0020      	movs	r0, r4
 800198e:	f7ff ff03 	bl	8001798 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001992:	f000 fb0f 	bl	8001fb4 <xTaskResumeAll>
 8001996:	2601      	movs	r6, #1
        taskENTER_CRITICAL();
 8001998:	f000 ff2a 	bl	80027f0 <vPortEnterCritical>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800199c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800199e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80019a0:	4293      	cmp	r3, r2
 80019a2:	d301      	bcc.n	80019a8 <xQueueGenericSend+0xea>
 80019a4:	2f02      	cmp	r7, #2
 80019a6:	d1ad      	bne.n	8001904 <xQueueGenericSend+0x46>
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80019a8:	003a      	movs	r2, r7
 80019aa:	0029      	movs	r1, r5
 80019ac:	0020      	movs	r0, r4
 80019ae:	f7ff fea6 	bl	80016fe <prvCopyDataToQueue>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80019b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80019b4:	2b00      	cmp	r3, #0
 80019b6:	d003      	beq.n	80019c0 <xQueueGenericSend+0x102>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80019b8:	0020      	movs	r0, r4
 80019ba:	3024      	adds	r0, #36	; 0x24
 80019bc:	f000 fbbc 	bl	8002138 <xTaskRemoveFromEventList>
                taskEXIT_CRITICAL();
 80019c0:	f000 ff22 	bl	8002808 <vPortExitCritical>
                return pdPASS;
 80019c4:	2001      	movs	r0, #1
}
 80019c6:	b005      	add	sp, #20
 80019c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            prvUnlockQueue( pxQueue );
 80019ca:	0020      	movs	r0, r4
 80019cc:	f7ff fee4 	bl	8001798 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 80019d0:	f000 faf0 	bl	8001fb4 <xTaskResumeAll>
 80019d4:	e79c      	b.n	8001910 <xQueueGenericSend+0x52>

080019d6 <xQueueGenericSendFromISR>:
{
 80019d6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019d8:	b085      	sub	sp, #20
 80019da:	0004      	movs	r4, r0
 80019dc:	0017      	movs	r7, r2
 80019de:	001e      	movs	r6, r3
 80019e0:	9101      	str	r1, [sp, #4]
    configASSERT( pxQueue );
 80019e2:	2800      	cmp	r0, #0
 80019e4:	d101      	bne.n	80019ea <xQueueGenericSendFromISR+0x14>
 80019e6:	b672      	cpsid	i
 80019e8:	e7fe      	b.n	80019e8 <xQueueGenericSendFromISR+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80019ea:	9b01      	ldr	r3, [sp, #4]
 80019ec:	2b00      	cmp	r3, #0
 80019ee:	d104      	bne.n	80019fa <xQueueGenericSendFromISR+0x24>
 80019f0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80019f2:	2b00      	cmp	r3, #0
 80019f4:	d001      	beq.n	80019fa <xQueueGenericSendFromISR+0x24>
 80019f6:	b672      	cpsid	i
 80019f8:	e7fe      	b.n	80019f8 <xQueueGenericSendFromISR+0x22>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80019fa:	2e02      	cmp	r6, #2
 80019fc:	d104      	bne.n	8001a08 <xQueueGenericSendFromISR+0x32>
 80019fe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001a00:	2b01      	cmp	r3, #1
 8001a02:	d001      	beq.n	8001a08 <xQueueGenericSendFromISR+0x32>
 8001a04:	b672      	cpsid	i
 8001a06:	e7fe      	b.n	8001a06 <xQueueGenericSendFromISR+0x30>
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001a08:	f000 ff0c 	bl	8002824 <ulSetInterruptMaskFromISR>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001a0c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001a0e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001a10:	9003      	str	r0, [sp, #12]
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001a12:	4293      	cmp	r3, r2
 8001a14:	d302      	bcc.n	8001a1c <xQueueGenericSendFromISR+0x46>
            xReturn = errQUEUE_FULL;
 8001a16:	2500      	movs	r5, #0
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001a18:	2e02      	cmp	r6, #2
 8001a1a:	d11b      	bne.n	8001a54 <xQueueGenericSendFromISR+0x7e>
            const int8_t cTxLock = pxQueue->cTxLock;
 8001a1c:	0023      	movs	r3, r4
 8001a1e:	3345      	adds	r3, #69	; 0x45
 8001a20:	9302      	str	r3, [sp, #8]
 8001a22:	781d      	ldrb	r5, [r3, #0]
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001a24:	0032      	movs	r2, r6
            const int8_t cTxLock = pxQueue->cTxLock;
 8001a26:	b26d      	sxtb	r5, r5
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001a28:	0020      	movs	r0, r4
 8001a2a:	9901      	ldr	r1, [sp, #4]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001a2c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001a2e:	f7ff fe66 	bl	80016fe <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
 8001a32:	1c6b      	adds	r3, r5, #1
 8001a34:	d114      	bne.n	8001a60 <xQueueGenericSendFromISR+0x8a>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001a36:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001a38:	2b00      	cmp	r3, #0
 8001a3a:	d101      	bne.n	8001a40 <xQueueGenericSendFromISR+0x6a>
            xReturn = pdPASS;
 8001a3c:	2501      	movs	r5, #1
 8001a3e:	e009      	b.n	8001a54 <xQueueGenericSendFromISR+0x7e>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001a40:	0020      	movs	r0, r4
 8001a42:	3024      	adds	r0, #36	; 0x24
 8001a44:	f000 fb78 	bl	8002138 <xTaskRemoveFromEventList>
 8001a48:	2800      	cmp	r0, #0
 8001a4a:	d0f7      	beq.n	8001a3c <xQueueGenericSendFromISR+0x66>
                                if( pxHigherPriorityTaskWoken != NULL )
 8001a4c:	2f00      	cmp	r7, #0
 8001a4e:	d0f5      	beq.n	8001a3c <xQueueGenericSendFromISR+0x66>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8001a50:	2501      	movs	r5, #1
 8001a52:	603d      	str	r5, [r7, #0]
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001a54:	9803      	ldr	r0, [sp, #12]
 8001a56:	f000 fee9 	bl	800282c <vClearInterruptMaskFromISR>
}
 8001a5a:	0028      	movs	r0, r5
 8001a5c:	b005      	add	sp, #20
 8001a5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                configASSERT( cTxLock != queueINT8_MAX );
 8001a60:	2d7f      	cmp	r5, #127	; 0x7f
 8001a62:	d101      	bne.n	8001a68 <xQueueGenericSendFromISR+0x92>
 8001a64:	b672      	cpsid	i
 8001a66:	e7fe      	b.n	8001a66 <xQueueGenericSendFromISR+0x90>
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001a68:	9b02      	ldr	r3, [sp, #8]
 8001a6a:	3501      	adds	r5, #1
 8001a6c:	b26d      	sxtb	r5, r5
 8001a6e:	701d      	strb	r5, [r3, #0]
 8001a70:	e7e4      	b.n	8001a3c <xQueueGenericSendFromISR+0x66>

08001a72 <xQueueReceive>:
{
 8001a72:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001a74:	b085      	sub	sp, #20
 8001a76:	0004      	movs	r4, r0
 8001a78:	000f      	movs	r7, r1
 8001a7a:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 8001a7c:	2800      	cmp	r0, #0
 8001a7e:	d101      	bne.n	8001a84 <xQueueReceive+0x12>
 8001a80:	b672      	cpsid	i
 8001a82:	e7fe      	b.n	8001a82 <xQueueReceive+0x10>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001a84:	2900      	cmp	r1, #0
 8001a86:	d104      	bne.n	8001a92 <xQueueReceive+0x20>
 8001a88:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001a8a:	2b00      	cmp	r3, #0
 8001a8c:	d001      	beq.n	8001a92 <xQueueReceive+0x20>
 8001a8e:	b672      	cpsid	i
 8001a90:	e7fe      	b.n	8001a90 <xQueueReceive+0x1e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001a92:	f000 fbd1 	bl	8002238 <xTaskGetSchedulerState>
 8001a96:	1e06      	subs	r6, r0, #0
 8001a98:	d104      	bne.n	8001aa4 <xQueueReceive+0x32>
 8001a9a:	9b01      	ldr	r3, [sp, #4]
 8001a9c:	2b00      	cmp	r3, #0
 8001a9e:	d041      	beq.n	8001b24 <xQueueReceive+0xb2>
 8001aa0:	b672      	cpsid	i
 8001aa2:	e7fe      	b.n	8001aa2 <xQueueReceive+0x30>
 8001aa4:	2600      	movs	r6, #0
 8001aa6:	e03d      	b.n	8001b24 <xQueueReceive+0xb2>
                if( xTicksToWait == ( TickType_t ) 0 )
 8001aa8:	9d01      	ldr	r5, [sp, #4]
 8001aaa:	2d00      	cmp	r5, #0
 8001aac:	d103      	bne.n	8001ab6 <xQueueReceive+0x44>
                    taskEXIT_CRITICAL();
 8001aae:	f000 feab 	bl	8002808 <vPortExitCritical>
                return errQUEUE_EMPTY;
 8001ab2:	2000      	movs	r0, #0
 8001ab4:	e04b      	b.n	8001b4e <xQueueReceive+0xdc>
                else if( xEntryTimeSet == pdFALSE )
 8001ab6:	2e00      	cmp	r6, #0
 8001ab8:	d102      	bne.n	8001ac0 <xQueueReceive+0x4e>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001aba:	a802      	add	r0, sp, #8
 8001abc:	f000 fb78 	bl	80021b0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 8001ac0:	f000 fea2 	bl	8002808 <vPortExitCritical>
        vTaskSuspendAll();
 8001ac4:	f000 fa06 	bl	8001ed4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001ac8:	f000 fe92 	bl	80027f0 <vPortEnterCritical>
 8001acc:	0022      	movs	r2, r4
 8001ace:	3244      	adds	r2, #68	; 0x44
 8001ad0:	7813      	ldrb	r3, [r2, #0]
 8001ad2:	b25b      	sxtb	r3, r3
 8001ad4:	3301      	adds	r3, #1
 8001ad6:	d101      	bne.n	8001adc <xQueueReceive+0x6a>
 8001ad8:	2300      	movs	r3, #0
 8001ada:	7013      	strb	r3, [r2, #0]
 8001adc:	0022      	movs	r2, r4
 8001ade:	3245      	adds	r2, #69	; 0x45
 8001ae0:	7813      	ldrb	r3, [r2, #0]
 8001ae2:	b25b      	sxtb	r3, r3
 8001ae4:	3301      	adds	r3, #1
 8001ae6:	d101      	bne.n	8001aec <xQueueReceive+0x7a>
 8001ae8:	2300      	movs	r3, #0
 8001aea:	7013      	strb	r3, [r2, #0]
 8001aec:	f000 fe8c 	bl	8002808 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001af0:	a901      	add	r1, sp, #4
 8001af2:	a802      	add	r0, sp, #8
 8001af4:	f000 fb68 	bl	80021c8 <xTaskCheckForTimeOut>
 8001af8:	2800      	cmp	r0, #0
 8001afa:	d130      	bne.n	8001b5e <xQueueReceive+0xec>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001afc:	0020      	movs	r0, r4
 8001afe:	f7ff fdf4 	bl	80016ea <prvIsQueueEmpty>
 8001b02:	2800      	cmp	r0, #0
 8001b04:	d025      	beq.n	8001b52 <xQueueReceive+0xe0>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001b06:	0020      	movs	r0, r4
 8001b08:	9901      	ldr	r1, [sp, #4]
 8001b0a:	3024      	adds	r0, #36	; 0x24
 8001b0c:	f000 faea 	bl	80020e4 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001b10:	0020      	movs	r0, r4
 8001b12:	f7ff fe41 	bl	8001798 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 8001b16:	f000 fa4d 	bl	8001fb4 <xTaskResumeAll>
 8001b1a:	2800      	cmp	r0, #0
 8001b1c:	d101      	bne.n	8001b22 <xQueueReceive+0xb0>
                    portYIELD_WITHIN_API();
 8001b1e:	f000 fe5b 	bl	80027d8 <vPortYield>
 8001b22:	2601      	movs	r6, #1
        taskENTER_CRITICAL();
 8001b24:	f000 fe64 	bl	80027f0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001b28:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001b2a:	2d00      	cmp	r5, #0
 8001b2c:	d0bc      	beq.n	8001aa8 <xQueueReceive+0x36>
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001b2e:	0039      	movs	r1, r7
 8001b30:	0020      	movs	r0, r4
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001b32:	3d01      	subs	r5, #1
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001b34:	f7ff fe1e 	bl	8001774 <prvCopyDataFromQueue>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001b38:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001b3a:	6923      	ldr	r3, [r4, #16]
 8001b3c:	2b00      	cmp	r3, #0
 8001b3e:	d003      	beq.n	8001b48 <xQueueReceive+0xd6>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001b40:	0020      	movs	r0, r4
 8001b42:	3010      	adds	r0, #16
 8001b44:	f000 faf8 	bl	8002138 <xTaskRemoveFromEventList>
                taskEXIT_CRITICAL();
 8001b48:	f000 fe5e 	bl	8002808 <vPortExitCritical>
                return pdPASS;
 8001b4c:	2001      	movs	r0, #1
}
 8001b4e:	b005      	add	sp, #20
 8001b50:	bdf0      	pop	{r4, r5, r6, r7, pc}
                prvUnlockQueue( pxQueue );
 8001b52:	0020      	movs	r0, r4
 8001b54:	f7ff fe20 	bl	8001798 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001b58:	f000 fa2c 	bl	8001fb4 <xTaskResumeAll>
 8001b5c:	e7e1      	b.n	8001b22 <xQueueReceive+0xb0>
            prvUnlockQueue( pxQueue );
 8001b5e:	0020      	movs	r0, r4
 8001b60:	f7ff fe1a 	bl	8001798 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8001b64:	f000 fa26 	bl	8001fb4 <xTaskResumeAll>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001b68:	0020      	movs	r0, r4
 8001b6a:	f7ff fdbe 	bl	80016ea <prvIsQueueEmpty>
 8001b6e:	2800      	cmp	r0, #0
 8001b70:	d0d7      	beq.n	8001b22 <xQueueReceive+0xb0>
 8001b72:	e79e      	b.n	8001ab2 <xQueueReceive+0x40>

08001b74 <vQueueAddToRegistry>:
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001b74:	2300      	movs	r3, #0
    {
 8001b76:	b570      	push	{r4, r5, r6, lr}
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8001b78:	4a06      	ldr	r2, [pc, #24]	; (8001b94 <vQueueAddToRegistry+0x20>)
 8001b7a:	00dd      	lsls	r5, r3, #3
 8001b7c:	18ac      	adds	r4, r5, r2
 8001b7e:	6826      	ldr	r6, [r4, #0]
 8001b80:	2e00      	cmp	r6, #0
 8001b82:	d102      	bne.n	8001b8a <vQueueAddToRegistry+0x16>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8001b84:	50a9      	str	r1, [r5, r2]
                xQueueRegistry[ ux ].xHandle = xQueue;
 8001b86:	6060      	str	r0, [r4, #4]
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 8001b88:	bd70      	pop	{r4, r5, r6, pc}
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001b8a:	3301      	adds	r3, #1
 8001b8c:	2b08      	cmp	r3, #8
 8001b8e:	d1f4      	bne.n	8001b7a <vQueueAddToRegistry+0x6>
 8001b90:	e7fa      	b.n	8001b88 <vQueueAddToRegistry+0x14>
 8001b92:	46c0      	nop			; (mov r8, r8)
 8001b94:	200008f8 	.word	0x200008f8

08001b98 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 8001b98:	b570      	push	{r4, r5, r6, lr}
 8001b9a:	0004      	movs	r4, r0
 8001b9c:	0016      	movs	r6, r2
 8001b9e:	000d      	movs	r5, r1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 8001ba0:	f000 fe26 	bl	80027f0 <vPortEnterCritical>
 8001ba4:	0022      	movs	r2, r4
 8001ba6:	3244      	adds	r2, #68	; 0x44
 8001ba8:	7813      	ldrb	r3, [r2, #0]
 8001baa:	b25b      	sxtb	r3, r3
 8001bac:	3301      	adds	r3, #1
 8001bae:	d101      	bne.n	8001bb4 <vQueueWaitForMessageRestricted+0x1c>
 8001bb0:	2300      	movs	r3, #0
 8001bb2:	7013      	strb	r3, [r2, #0]
 8001bb4:	0022      	movs	r2, r4
 8001bb6:	3245      	adds	r2, #69	; 0x45
 8001bb8:	7813      	ldrb	r3, [r2, #0]
 8001bba:	b25b      	sxtb	r3, r3
 8001bbc:	3301      	adds	r3, #1
 8001bbe:	d101      	bne.n	8001bc4 <vQueueWaitForMessageRestricted+0x2c>
 8001bc0:	2300      	movs	r3, #0
 8001bc2:	7013      	strb	r3, [r2, #0]
 8001bc4:	f000 fe20 	bl	8002808 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8001bc8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001bca:	2b00      	cmp	r3, #0
 8001bcc:	d105      	bne.n	8001bda <vQueueWaitForMessageRestricted+0x42>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8001bce:	0020      	movs	r0, r4
 8001bd0:	0032      	movs	r2, r6
 8001bd2:	0029      	movs	r1, r5
 8001bd4:	3024      	adds	r0, #36	; 0x24
 8001bd6:	f000 fa97 	bl	8002108 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
 8001bda:	0020      	movs	r0, r4
 8001bdc:	f7ff fddc 	bl	8001798 <prvUnlockQueue>
    }
 8001be0:	bd70      	pop	{r4, r5, r6, pc}
	...

08001be4 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001be4:	4a06      	ldr	r2, [pc, #24]	; (8001c00 <prvResetNextTaskUnblockTime+0x1c>)
 8001be6:	6813      	ldr	r3, [r2, #0]
 8001be8:	6819      	ldr	r1, [r3, #0]
 8001bea:	4b06      	ldr	r3, [pc, #24]	; (8001c04 <prvResetNextTaskUnblockTime+0x20>)
 8001bec:	2900      	cmp	r1, #0
 8001bee:	d103      	bne.n	8001bf8 <prvResetNextTaskUnblockTime+0x14>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 8001bf0:	2201      	movs	r2, #1
 8001bf2:	4252      	negs	r2, r2
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001bf4:	601a      	str	r2, [r3, #0]
    }
}
 8001bf6:	4770      	bx	lr
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001bf8:	6812      	ldr	r2, [r2, #0]
 8001bfa:	68d2      	ldr	r2, [r2, #12]
 8001bfc:	6812      	ldr	r2, [r2, #0]
 8001bfe:	e7f9      	b.n	8001bf4 <prvResetNextTaskUnblockTime+0x10>
 8001c00:	20000030 	.word	0x20000030
 8001c04:	200000dc 	.word	0x200000dc

08001c08 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8001c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001c0a:	0004      	movs	r4, r0
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8001c0c:	4b14      	ldr	r3, [pc, #80]	; (8001c60 <prvAddCurrentTaskToDelayedList+0x58>)
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001c0e:	4d15      	ldr	r5, [pc, #84]	; (8001c64 <prvAddCurrentTaskToDelayedList+0x5c>)
    const TickType_t xConstTickCount = xTickCount;
 8001c10:	681e      	ldr	r6, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001c12:	6828      	ldr	r0, [r5, #0]
{
 8001c14:	000f      	movs	r7, r1
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001c16:	3004      	adds	r0, #4
 8001c18:	f7ff fd57 	bl	80016ca <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001c1c:	1c63      	adds	r3, r4, #1
 8001c1e:	d107      	bne.n	8001c30 <prvAddCurrentTaskToDelayedList+0x28>
 8001c20:	2f00      	cmp	r7, #0
 8001c22:	d005      	beq.n	8001c30 <prvAddCurrentTaskToDelayedList+0x28>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001c24:	6829      	ldr	r1, [r5, #0]
 8001c26:	4810      	ldr	r0, [pc, #64]	; (8001c68 <prvAddCurrentTaskToDelayedList+0x60>)
 8001c28:	3104      	adds	r1, #4
 8001c2a:	f7ff fd2b 	bl	8001684 <vListInsertEnd>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 8001c2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001c30:	682b      	ldr	r3, [r5, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001c32:	1934      	adds	r4, r6, r4
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001c34:	605c      	str	r4, [r3, #4]
                if( xTimeToWake < xConstTickCount )
 8001c36:	42a6      	cmp	r6, r4
 8001c38:	d906      	bls.n	8001c48 <prvAddCurrentTaskToDelayedList+0x40>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001c3a:	4b0c      	ldr	r3, [pc, #48]	; (8001c6c <prvAddCurrentTaskToDelayedList+0x64>)
 8001c3c:	6818      	ldr	r0, [r3, #0]
 8001c3e:	6829      	ldr	r1, [r5, #0]
 8001c40:	3104      	adds	r1, #4
 8001c42:	f7ff fd2b 	bl	800169c <vListInsert>
 8001c46:	e7f2      	b.n	8001c2e <prvAddCurrentTaskToDelayedList+0x26>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001c48:	4b09      	ldr	r3, [pc, #36]	; (8001c70 <prvAddCurrentTaskToDelayedList+0x68>)
 8001c4a:	6818      	ldr	r0, [r3, #0]
 8001c4c:	6829      	ldr	r1, [r5, #0]
 8001c4e:	3104      	adds	r1, #4
 8001c50:	f7ff fd24 	bl	800169c <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001c54:	4b07      	ldr	r3, [pc, #28]	; (8001c74 <prvAddCurrentTaskToDelayedList+0x6c>)
 8001c56:	681a      	ldr	r2, [r3, #0]
 8001c58:	42a2      	cmp	r2, r4
 8001c5a:	d9e8      	bls.n	8001c2e <prvAddCurrentTaskToDelayedList+0x26>
                        xNextTaskUnblockTime = xTimeToWake;
 8001c5c:	601c      	str	r4, [r3, #0]
}
 8001c5e:	e7e6      	b.n	8001c2e <prvAddCurrentTaskToDelayedList+0x26>
 8001c60:	20000128 	.word	0x20000128
 8001c64:	2000002c 	.word	0x2000002c
 8001c68:	20000100 	.word	0x20000100
 8001c6c:	20000034 	.word	0x20000034
 8001c70:	20000030 	.word	0x20000030
 8001c74:	200000dc 	.word	0x200000dc

08001c78 <prvIdleTask>:
{
 8001c78:	b570      	push	{r4, r5, r6, lr}
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001c7a:	4c0f      	ldr	r4, [pc, #60]	; (8001cb8 <prvIdleTask+0x40>)
 8001c7c:	6823      	ldr	r3, [r4, #0]
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	d102      	bne.n	8001c88 <prvIdleTask+0x10>
                taskYIELD();
 8001c82:	f000 fda9 	bl	80027d8 <vPortYield>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001c86:	e7f8      	b.n	8001c7a <prvIdleTask+0x2>
                taskENTER_CRITICAL();
 8001c88:	f000 fdb2 	bl	80027f0 <vPortEnterCritical>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001c8c:	4b0b      	ldr	r3, [pc, #44]	; (8001cbc <prvIdleTask+0x44>)
 8001c8e:	68db      	ldr	r3, [r3, #12]
 8001c90:	68dd      	ldr	r5, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001c92:	1d28      	adds	r0, r5, #4
 8001c94:	f7ff fd19 	bl	80016ca <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8001c98:	4a09      	ldr	r2, [pc, #36]	; (8001cc0 <prvIdleTask+0x48>)
 8001c9a:	6813      	ldr	r3, [r2, #0]
 8001c9c:	3b01      	subs	r3, #1
 8001c9e:	6013      	str	r3, [r2, #0]
                    --uxDeletedTasksWaitingCleanUp;
 8001ca0:	6823      	ldr	r3, [r4, #0]
 8001ca2:	3b01      	subs	r3, #1
 8001ca4:	6023      	str	r3, [r4, #0]
                taskEXIT_CRITICAL();
 8001ca6:	f000 fdaf 	bl	8002808 <vPortExitCritical>
                vPortFree( pxTCB->pxStack );
 8001caa:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8001cac:	f000 fee2 	bl	8002a74 <vPortFree>
                vPortFree( pxTCB );
 8001cb0:	0028      	movs	r0, r5
 8001cb2:	f000 fedf 	bl	8002a74 <vPortFree>
    }
 8001cb6:	e7e0      	b.n	8001c7a <prvIdleTask+0x2>
 8001cb8:	200000a0 	.word	0x200000a0
 8001cbc:	20000114 	.word	0x20000114
 8001cc0:	2000009c 	.word	0x2000009c

08001cc4 <xTaskCreate>:
    {
 8001cc4:	b5f0      	push	{r4, r5, r6, r7, lr}
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001cc6:	0095      	lsls	r5, r2, #2
    {
 8001cc8:	b085      	sub	sp, #20
 8001cca:	9002      	str	r0, [sp, #8]
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001ccc:	0028      	movs	r0, r5
    {
 8001cce:	000c      	movs	r4, r1
 8001cd0:	9303      	str	r3, [sp, #12]
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001cd2:	f000 fe45 	bl	8002960 <pvPortMalloc>
 8001cd6:	1e06      	subs	r6, r0, #0
                if( pxStack != NULL )
 8001cd8:	d018      	beq.n	8001d0c <xTaskCreate+0x48>
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8001cda:	2054      	movs	r0, #84	; 0x54
 8001cdc:	f000 fe40 	bl	8002960 <pvPortMalloc>
 8001ce0:	1e07      	subs	r7, r0, #0
                    if( pxNewTCB != NULL )
 8001ce2:	d010      	beq.n	8001d06 <xTaskCreate+0x42>
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8001ce4:	002a      	movs	r2, r5
                        pxNewTCB->pxStack = pxStack;
 8001ce6:	6306      	str	r6, [r0, #48]	; 0x30
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8001ce8:	21a5      	movs	r1, #165	; 0xa5
 8001cea:	0030      	movs	r0, r6
 8001cec:	f000 ff19 	bl	8002b22 <memset>
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001cf0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001cf2:	003a      	movs	r2, r7
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001cf4:	9300      	str	r3, [sp, #0]
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001cf6:	2300      	movs	r3, #0
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001cf8:	3234      	adds	r2, #52	; 0x34
    if( pcName != NULL )
 8001cfa:	429c      	cmp	r4, r3
 8001cfc:	d109      	bne.n	8001d12 <xTaskCreate+0x4e>
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8001cfe:	003b      	movs	r3, r7
 8001d00:	3334      	adds	r3, #52	; 0x34
 8001d02:	701c      	strb	r4, [r3, #0]
 8001d04:	e011      	b.n	8001d2a <xTaskCreate+0x66>
                        vPortFree( pxStack );
 8001d06:	0030      	movs	r0, r6
 8001d08:	f000 feb4 	bl	8002a74 <vPortFree>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001d0c:	2001      	movs	r0, #1
 8001d0e:	4240      	negs	r0, r0
 8001d10:	e088      	b.n	8001e24 <xTaskCreate+0x160>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001d12:	5ce1      	ldrb	r1, [r4, r3]
 8001d14:	54d1      	strb	r1, [r2, r3]
            if( pcName[ x ] == ( char ) 0x00 )
 8001d16:	5ce1      	ldrb	r1, [r4, r3]
 8001d18:	2900      	cmp	r1, #0
 8001d1a:	d002      	beq.n	8001d22 <xTaskCreate+0x5e>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001d1c:	3301      	adds	r3, #1
 8001d1e:	2b05      	cmp	r3, #5
 8001d20:	d1f7      	bne.n	8001d12 <xTaskCreate+0x4e>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001d22:	003b      	movs	r3, r7
 8001d24:	2200      	movs	r2, #0
 8001d26:	3338      	adds	r3, #56	; 0x38
 8001d28:	701a      	strb	r2, [r3, #0]
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8001d2a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8001d2c:	2c04      	cmp	r4, #4
 8001d2e:	d900      	bls.n	8001d32 <xTaskCreate+0x6e>
 8001d30:	2404      	movs	r4, #4
            pxNewTCB->uxMutexesHeld = 0;
 8001d32:	2600      	movs	r6, #0
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001d34:	1d3b      	adds	r3, r7, #4
 8001d36:	0018      	movs	r0, r3
    pxNewTCB->uxPriority = uxPriority;
 8001d38:	62fc      	str	r4, [r7, #44]	; 0x2c
            pxNewTCB->uxBasePriority = uxPriority;
 8001d3a:	647c      	str	r4, [r7, #68]	; 0x44
            pxNewTCB->uxMutexesHeld = 0;
 8001d3c:	64be      	str	r6, [r7, #72]	; 0x48
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001d3e:	9301      	str	r3, [sp, #4]
 8001d40:	f7ff fc9d 	bl	800167e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8001d44:	0038      	movs	r0, r7
 8001d46:	3018      	adds	r0, #24
 8001d48:	f7ff fc99 	bl	800167e <vListInitialiseItem>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d4c:	2305      	movs	r3, #5
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001d4e:	0038      	movs	r0, r7
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d50:	1b1c      	subs	r4, r3, r4
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001d52:	2204      	movs	r2, #4
 8001d54:	0031      	movs	r1, r6
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8001d56:	613f      	str	r7, [r7, #16]
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001d58:	61bc      	str	r4, [r7, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8001d5a:	627f      	str	r7, [r7, #36]	; 0x24
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001d5c:	304c      	adds	r0, #76	; 0x4c
 8001d5e:	f000 fee0 	bl	8002b22 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 8001d62:	003b      	movs	r3, r7
 8001d64:	3350      	adds	r3, #80	; 0x50
 8001d66:	701e      	strb	r6, [r3, #0]
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001d68:	9b00      	ldr	r3, [sp, #0]
 8001d6a:	1f28      	subs	r0, r5, #4
 8001d6c:	1818      	adds	r0, r3, r0
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8001d6e:	2307      	movs	r3, #7
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001d70:	9a03      	ldr	r2, [sp, #12]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8001d72:	4398      	bics	r0, r3
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001d74:	9902      	ldr	r1, [sp, #8]
 8001d76:	f000 fd1d 	bl	80027b4 <pxPortInitialiseStack>
    if( pxCreatedTask != NULL )
 8001d7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001d7c:	6038      	str	r0, [r7, #0]
    if( pxCreatedTask != NULL )
 8001d7e:	42b3      	cmp	r3, r6
 8001d80:	d000      	beq.n	8001d84 <xTaskCreate+0xc0>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8001d82:	601f      	str	r7, [r3, #0]
    taskENTER_CRITICAL();
 8001d84:	f000 fd34 	bl	80027f0 <vPortEnterCritical>
        uxCurrentNumberOfTasks++;
 8001d88:	4b2c      	ldr	r3, [pc, #176]	; (8001e3c <xTaskCreate+0x178>)
        if( pxCurrentTCB == NULL )
 8001d8a:	4d2d      	ldr	r5, [pc, #180]	; (8001e40 <xTaskCreate+0x17c>)
        uxCurrentNumberOfTasks++;
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	4c2d      	ldr	r4, [pc, #180]	; (8001e44 <xTaskCreate+0x180>)
 8001d90:	3201      	adds	r2, #1
 8001d92:	601a      	str	r2, [r3, #0]
        if( pxCurrentTCB == NULL )
 8001d94:	682a      	ldr	r2, [r5, #0]
 8001d96:	4e2c      	ldr	r6, [pc, #176]	; (8001e48 <xTaskCreate+0x184>)
 8001d98:	2a00      	cmp	r2, #0
 8001d9a:	d145      	bne.n	8001e28 <xTaskCreate+0x164>
            pxCurrentTCB = pxNewTCB;
 8001d9c:	602f      	str	r7, [r5, #0]
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001d9e:	681b      	ldr	r3, [r3, #0]
 8001da0:	2b01      	cmp	r3, #1
 8001da2:	d127      	bne.n	8001df4 <xTaskCreate+0x130>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001da4:	0020      	movs	r0, r4
 8001da6:	f7ff fc5f 	bl	8001668 <vListInitialise>
 8001daa:	0020      	movs	r0, r4
 8001dac:	3014      	adds	r0, #20
 8001dae:	f7ff fc5b 	bl	8001668 <vListInitialise>
 8001db2:	0020      	movs	r0, r4
 8001db4:	3028      	adds	r0, #40	; 0x28
 8001db6:	f7ff fc57 	bl	8001668 <vListInitialise>
 8001dba:	0020      	movs	r0, r4
 8001dbc:	303c      	adds	r0, #60	; 0x3c
 8001dbe:	f7ff fc53 	bl	8001668 <vListInitialise>
 8001dc2:	0020      	movs	r0, r4
 8001dc4:	3050      	adds	r0, #80	; 0x50
 8001dc6:	f7ff fc4f 	bl	8001668 <vListInitialise>
    vListInitialise( &xDelayedTaskList1 );
 8001dca:	4820      	ldr	r0, [pc, #128]	; (8001e4c <xTaskCreate+0x188>)
 8001dcc:	f7ff fc4c 	bl	8001668 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8001dd0:	481f      	ldr	r0, [pc, #124]	; (8001e50 <xTaskCreate+0x18c>)
 8001dd2:	f7ff fc49 	bl	8001668 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8001dd6:	481f      	ldr	r0, [pc, #124]	; (8001e54 <xTaskCreate+0x190>)
 8001dd8:	f7ff fc46 	bl	8001668 <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
 8001ddc:	481e      	ldr	r0, [pc, #120]	; (8001e58 <xTaskCreate+0x194>)
 8001dde:	f7ff fc43 	bl	8001668 <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
 8001de2:	481e      	ldr	r0, [pc, #120]	; (8001e5c <xTaskCreate+0x198>)
 8001de4:	f7ff fc40 	bl	8001668 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
 8001de8:	4b1d      	ldr	r3, [pc, #116]	; (8001e60 <xTaskCreate+0x19c>)
 8001dea:	4a18      	ldr	r2, [pc, #96]	; (8001e4c <xTaskCreate+0x188>)
 8001dec:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8001dee:	4b1d      	ldr	r3, [pc, #116]	; (8001e64 <xTaskCreate+0x1a0>)
 8001df0:	4a17      	ldr	r2, [pc, #92]	; (8001e50 <xTaskCreate+0x18c>)
 8001df2:	601a      	str	r2, [r3, #0]
        uxTaskNumber++;
 8001df4:	4a1c      	ldr	r2, [pc, #112]	; (8001e68 <xTaskCreate+0x1a4>)
 8001df6:	6813      	ldr	r3, [r2, #0]
 8001df8:	3301      	adds	r3, #1
 8001dfa:	6013      	str	r3, [r2, #0]
        prvAddTaskToReadyList( pxNewTCB );
 8001dfc:	4a1b      	ldr	r2, [pc, #108]	; (8001e6c <xTaskCreate+0x1a8>)
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 8001dfe:	63fb      	str	r3, [r7, #60]	; 0x3c
        prvAddTaskToReadyList( pxNewTCB );
 8001e00:	6811      	ldr	r1, [r2, #0]
 8001e02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001e04:	428b      	cmp	r3, r1
 8001e06:	d900      	bls.n	8001e0a <xTaskCreate+0x146>
 8001e08:	6013      	str	r3, [r2, #0]
 8001e0a:	2014      	movs	r0, #20
 8001e0c:	4358      	muls	r0, r3
 8001e0e:	9901      	ldr	r1, [sp, #4]
 8001e10:	1820      	adds	r0, r4, r0
 8001e12:	f7ff fc37 	bl	8001684 <vListInsertEnd>
    taskEXIT_CRITICAL();
 8001e16:	f000 fcf7 	bl	8002808 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 8001e1a:	6833      	ldr	r3, [r6, #0]
            xReturn = pdPASS;
 8001e1c:	2001      	movs	r0, #1
    if( xSchedulerRunning != pdFALSE )
 8001e1e:	2b00      	cmp	r3, #0
 8001e20:	d000      	beq.n	8001e24 <xTaskCreate+0x160>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8001e22:	682b      	ldr	r3, [r5, #0]
    }
 8001e24:	b005      	add	sp, #20
 8001e26:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( xSchedulerRunning == pdFALSE )
 8001e28:	6833      	ldr	r3, [r6, #0]
 8001e2a:	2b00      	cmp	r3, #0
 8001e2c:	d1e2      	bne.n	8001df4 <xTaskCreate+0x130>
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001e2e:	682b      	ldr	r3, [r5, #0]
 8001e30:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001e32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e34:	4293      	cmp	r3, r2
 8001e36:	d8dd      	bhi.n	8001df4 <xTaskCreate+0x130>
                    pxCurrentTCB = pxNewTCB;
 8001e38:	602f      	str	r7, [r5, #0]
 8001e3a:	e7db      	b.n	8001df4 <xTaskCreate+0x130>
 8001e3c:	2000009c 	.word	0x2000009c
 8001e40:	2000002c 	.word	0x2000002c
 8001e44:	20000038 	.word	0x20000038
 8001e48:	200000fc 	.word	0x200000fc
 8001e4c:	200000b0 	.word	0x200000b0
 8001e50:	200000c4 	.word	0x200000c4
 8001e54:	200000e8 	.word	0x200000e8
 8001e58:	20000114 	.word	0x20000114
 8001e5c:	20000100 	.word	0x20000100
 8001e60:	20000030 	.word	0x20000030
 8001e64:	20000034 	.word	0x20000034
 8001e68:	200000a8 	.word	0x200000a8
 8001e6c:	200000ac 	.word	0x200000ac

08001e70 <vTaskStartScheduler>:
{
 8001e70:	b513      	push	{r0, r1, r4, lr}
            xReturn = xTaskCreate( prvIdleTask,
 8001e72:	2400      	movs	r4, #0
 8001e74:	4b10      	ldr	r3, [pc, #64]	; (8001eb8 <vTaskStartScheduler+0x48>)
 8001e76:	223c      	movs	r2, #60	; 0x3c
 8001e78:	9301      	str	r3, [sp, #4]
 8001e7a:	4910      	ldr	r1, [pc, #64]	; (8001ebc <vTaskStartScheduler+0x4c>)
 8001e7c:	0023      	movs	r3, r4
 8001e7e:	4810      	ldr	r0, [pc, #64]	; (8001ec0 <vTaskStartScheduler+0x50>)
 8001e80:	9400      	str	r4, [sp, #0]
 8001e82:	f7ff ff1f 	bl	8001cc4 <xTaskCreate>
            if( xReturn == pdPASS )
 8001e86:	2801      	cmp	r0, #1
 8001e88:	d111      	bne.n	8001eae <vTaskStartScheduler+0x3e>
                xReturn = xTimerCreateTimerTask();
 8001e8a:	f000 fb1d 	bl	80024c8 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 8001e8e:	2801      	cmp	r0, #1
 8001e90:	d10d      	bne.n	8001eae <vTaskStartScheduler+0x3e>
        portDISABLE_INTERRUPTS();
 8001e92:	b672      	cpsid	i
        xNextTaskUnblockTime = portMAX_DELAY;
 8001e94:	2201      	movs	r2, #1
 8001e96:	4b0b      	ldr	r3, [pc, #44]	; (8001ec4 <vTaskStartScheduler+0x54>)
 8001e98:	4252      	negs	r2, r2
 8001e9a:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8001e9c:	4b0a      	ldr	r3, [pc, #40]	; (8001ec8 <vTaskStartScheduler+0x58>)
 8001e9e:	6018      	str	r0, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8001ea0:	4b0a      	ldr	r3, [pc, #40]	; (8001ecc <vTaskStartScheduler+0x5c>)
 8001ea2:	601c      	str	r4, [r3, #0]
        if( xPortStartScheduler() != pdFALSE )
 8001ea4:	f000 fd1a 	bl	80028dc <xPortStartScheduler>
    ( void ) uxTopUsedPriority;
 8001ea8:	4b09      	ldr	r3, [pc, #36]	; (8001ed0 <vTaskStartScheduler+0x60>)
 8001eaa:	681b      	ldr	r3, [r3, #0]
}
 8001eac:	bd13      	pop	{r0, r1, r4, pc}
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001eae:	1c43      	adds	r3, r0, #1
 8001eb0:	d1fa      	bne.n	8001ea8 <vTaskStartScheduler+0x38>
 8001eb2:	b672      	cpsid	i
 8001eb4:	e7fe      	b.n	8001eb4 <vTaskStartScheduler+0x44>
 8001eb6:	46c0      	nop			; (mov r8, r8)
 8001eb8:	200000d8 	.word	0x200000d8
 8001ebc:	08002b92 	.word	0x08002b92
 8001ec0:	08001c79 	.word	0x08001c79
 8001ec4:	200000dc 	.word	0x200000dc
 8001ec8:	200000fc 	.word	0x200000fc
 8001ecc:	20000128 	.word	0x20000128
 8001ed0:	20000008 	.word	0x20000008

08001ed4 <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 8001ed4:	4a02      	ldr	r2, [pc, #8]	; (8001ee0 <vTaskSuspendAll+0xc>)
 8001ed6:	6813      	ldr	r3, [r2, #0]
 8001ed8:	3301      	adds	r3, #1
 8001eda:	6013      	str	r3, [r2, #0]
}
 8001edc:	4770      	bx	lr
 8001ede:	46c0      	nop			; (mov r8, r8)
 8001ee0:	200000a4 	.word	0x200000a4

08001ee4 <xTaskGetTickCount>:
        xTicks = xTickCount;
 8001ee4:	4b01      	ldr	r3, [pc, #4]	; (8001eec <xTaskGetTickCount+0x8>)
 8001ee6:	6818      	ldr	r0, [r3, #0]
}
 8001ee8:	4770      	bx	lr
 8001eea:	46c0      	nop			; (mov r8, r8)
 8001eec:	20000128 	.word	0x20000128

08001ef0 <xTaskIncrementTick>:
{
 8001ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001ef2:	4b27      	ldr	r3, [pc, #156]	; (8001f90 <xTaskIncrementTick+0xa0>)
 8001ef4:	681b      	ldr	r3, [r3, #0]
 8001ef6:	2b00      	cmp	r3, #0
 8001ef8:	d144      	bne.n	8001f84 <xTaskIncrementTick+0x94>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8001efa:	4b26      	ldr	r3, [pc, #152]	; (8001f94 <xTaskIncrementTick+0xa4>)
 8001efc:	681c      	ldr	r4, [r3, #0]
 8001efe:	3401      	adds	r4, #1
        xTickCount = xConstTickCount;
 8001f00:	601c      	str	r4, [r3, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8001f02:	2c00      	cmp	r4, #0
 8001f04:	d111      	bne.n	8001f2a <xTaskIncrementTick+0x3a>
            taskSWITCH_DELAYED_LISTS();
 8001f06:	4b24      	ldr	r3, [pc, #144]	; (8001f98 <xTaskIncrementTick+0xa8>)
 8001f08:	681a      	ldr	r2, [r3, #0]
 8001f0a:	6812      	ldr	r2, [r2, #0]
 8001f0c:	2a00      	cmp	r2, #0
 8001f0e:	d001      	beq.n	8001f14 <xTaskIncrementTick+0x24>
 8001f10:	b672      	cpsid	i
 8001f12:	e7fe      	b.n	8001f12 <xTaskIncrementTick+0x22>
 8001f14:	4a21      	ldr	r2, [pc, #132]	; (8001f9c <xTaskIncrementTick+0xac>)
 8001f16:	6819      	ldr	r1, [r3, #0]
 8001f18:	6810      	ldr	r0, [r2, #0]
 8001f1a:	6018      	str	r0, [r3, #0]
 8001f1c:	6011      	str	r1, [r2, #0]
 8001f1e:	4a20      	ldr	r2, [pc, #128]	; (8001fa0 <xTaskIncrementTick+0xb0>)
 8001f20:	6813      	ldr	r3, [r2, #0]
 8001f22:	3301      	adds	r3, #1
 8001f24:	6013      	str	r3, [r2, #0]
 8001f26:	f7ff fe5d 	bl	8001be4 <prvResetNextTaskUnblockTime>
        if( xConstTickCount >= xNextTaskUnblockTime )
 8001f2a:	4e1e      	ldr	r6, [pc, #120]	; (8001fa4 <xTaskIncrementTick+0xb4>)
 8001f2c:	6833      	ldr	r3, [r6, #0]
 8001f2e:	429c      	cmp	r4, r3
 8001f30:	d307      	bcc.n	8001f42 <xTaskIncrementTick+0x52>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001f32:	4b19      	ldr	r3, [pc, #100]	; (8001f98 <xTaskIncrementTick+0xa8>)
 8001f34:	681a      	ldr	r2, [r3, #0]
 8001f36:	6812      	ldr	r2, [r2, #0]
 8001f38:	2a00      	cmp	r2, #0
 8001f3a:	d104      	bne.n	8001f46 <xTaskIncrementTick+0x56>
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001f3c:	2301      	movs	r3, #1
 8001f3e:	425b      	negs	r3, r3
                        xNextTaskUnblockTime = xItemValue;
 8001f40:	6033      	str	r3, [r6, #0]
}
 8001f42:	2000      	movs	r0, #0
 8001f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001f46:	681b      	ldr	r3, [r3, #0]
 8001f48:	68db      	ldr	r3, [r3, #12]
 8001f4a:	68dd      	ldr	r5, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001f4c:	686b      	ldr	r3, [r5, #4]
                    if( xConstTickCount < xItemValue )
 8001f4e:	429c      	cmp	r4, r3
 8001f50:	d3f6      	bcc.n	8001f40 <xTaskIncrementTick+0x50>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001f52:	1d2f      	adds	r7, r5, #4
 8001f54:	0038      	movs	r0, r7
 8001f56:	f7ff fbb8 	bl	80016ca <uxListRemove>
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001f5a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001f5c:	2b00      	cmp	r3, #0
 8001f5e:	d003      	beq.n	8001f68 <xTaskIncrementTick+0x78>
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001f60:	0028      	movs	r0, r5
 8001f62:	3018      	adds	r0, #24
 8001f64:	f7ff fbb1 	bl	80016ca <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001f68:	4b0f      	ldr	r3, [pc, #60]	; (8001fa8 <xTaskIncrementTick+0xb8>)
 8001f6a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8001f6c:	681a      	ldr	r2, [r3, #0]
 8001f6e:	4290      	cmp	r0, r2
 8001f70:	d900      	bls.n	8001f74 <xTaskIncrementTick+0x84>
 8001f72:	6018      	str	r0, [r3, #0]
 8001f74:	2314      	movs	r3, #20
 8001f76:	4358      	muls	r0, r3
 8001f78:	4b0c      	ldr	r3, [pc, #48]	; (8001fac <xTaskIncrementTick+0xbc>)
 8001f7a:	0039      	movs	r1, r7
 8001f7c:	1818      	adds	r0, r3, r0
 8001f7e:	f7ff fb81 	bl	8001684 <vListInsertEnd>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001f82:	e7d6      	b.n	8001f32 <xTaskIncrementTick+0x42>
        ++xPendedTicks;
 8001f84:	4a0a      	ldr	r2, [pc, #40]	; (8001fb0 <xTaskIncrementTick+0xc0>)
 8001f86:	6813      	ldr	r3, [r2, #0]
 8001f88:	3301      	adds	r3, #1
 8001f8a:	6013      	str	r3, [r2, #0]
 8001f8c:	e7d9      	b.n	8001f42 <xTaskIncrementTick+0x52>
 8001f8e:	46c0      	nop			; (mov r8, r8)
 8001f90:	200000a4 	.word	0x200000a4
 8001f94:	20000128 	.word	0x20000128
 8001f98:	20000030 	.word	0x20000030
 8001f9c:	20000034 	.word	0x20000034
 8001fa0:	200000e0 	.word	0x200000e0
 8001fa4:	200000dc 	.word	0x200000dc
 8001fa8:	200000ac 	.word	0x200000ac
 8001fac:	20000038 	.word	0x20000038
 8001fb0:	200000e4 	.word	0x200000e4

08001fb4 <xTaskResumeAll>:
{
 8001fb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    configASSERT( uxSchedulerSuspended );
 8001fb6:	4c28      	ldr	r4, [pc, #160]	; (8002058 <xTaskResumeAll+0xa4>)
 8001fb8:	6823      	ldr	r3, [r4, #0]
 8001fba:	2b00      	cmp	r3, #0
 8001fbc:	d101      	bne.n	8001fc2 <xTaskResumeAll+0xe>
 8001fbe:	b672      	cpsid	i
 8001fc0:	e7fe      	b.n	8001fc0 <xTaskResumeAll+0xc>
    taskENTER_CRITICAL();
 8001fc2:	f000 fc15 	bl	80027f0 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8001fc6:	6823      	ldr	r3, [r4, #0]
 8001fc8:	3b01      	subs	r3, #1
 8001fca:	6023      	str	r3, [r4, #0]
        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001fcc:	6824      	ldr	r4, [r4, #0]
 8001fce:	2c00      	cmp	r4, #0
 8001fd0:	d103      	bne.n	8001fda <xTaskResumeAll+0x26>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8001fd2:	4b22      	ldr	r3, [pc, #136]	; (800205c <xTaskResumeAll+0xa8>)
 8001fd4:	681b      	ldr	r3, [r3, #0]
 8001fd6:	2b00      	cmp	r3, #0
 8001fd8:	d13b      	bne.n	8002052 <xTaskResumeAll+0x9e>
    taskEXIT_CRITICAL();
 8001fda:	f000 fc15 	bl	8002808 <vPortExitCritical>
}
 8001fde:	2000      	movs	r0, #0
 8001fe0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001fe2:	68db      	ldr	r3, [r3, #12]
 8001fe4:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001fe6:	0020      	movs	r0, r4
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001fe8:	1d25      	adds	r5, r4, #4
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001fea:	3018      	adds	r0, #24
 8001fec:	f7ff fb6d 	bl	80016ca <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001ff0:	0028      	movs	r0, r5
 8001ff2:	f7ff fb6a 	bl	80016ca <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001ff6:	4b1a      	ldr	r3, [pc, #104]	; (8002060 <xTaskResumeAll+0xac>)
 8001ff8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001ffa:	681a      	ldr	r2, [r3, #0]
 8001ffc:	4290      	cmp	r0, r2
 8001ffe:	d900      	bls.n	8002002 <xTaskResumeAll+0x4e>
 8002000:	6018      	str	r0, [r3, #0]
 8002002:	4370      	muls	r0, r6
 8002004:	4b17      	ldr	r3, [pc, #92]	; (8002064 <xTaskResumeAll+0xb0>)
 8002006:	0029      	movs	r1, r5
 8002008:	1818      	adds	r0, r3, r0
 800200a:	f7ff fb3b 	bl	8001684 <vListInsertEnd>
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800200e:	4b16      	ldr	r3, [pc, #88]	; (8002068 <xTaskResumeAll+0xb4>)
 8002010:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002012:	681b      	ldr	r3, [r3, #0]
 8002014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002016:	429a      	cmp	r2, r3
 8002018:	d301      	bcc.n	800201e <xTaskResumeAll+0x6a>
                        xYieldPending = pdTRUE;
 800201a:	4b14      	ldr	r3, [pc, #80]	; (800206c <xTaskResumeAll+0xb8>)
 800201c:	601f      	str	r7, [r3, #0]
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800201e:	4b14      	ldr	r3, [pc, #80]	; (8002070 <xTaskResumeAll+0xbc>)
 8002020:	681a      	ldr	r2, [r3, #0]
 8002022:	2a00      	cmp	r2, #0
 8002024:	d1dd      	bne.n	8001fe2 <xTaskResumeAll+0x2e>
                if( pxTCB != NULL )
 8002026:	2c00      	cmp	r4, #0
 8002028:	d001      	beq.n	800202e <xTaskResumeAll+0x7a>
                    prvResetNextTaskUnblockTime();
 800202a:	f7ff fddb 	bl	8001be4 <prvResetNextTaskUnblockTime>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 800202e:	4d11      	ldr	r5, [pc, #68]	; (8002074 <xTaskResumeAll+0xc0>)
 8002030:	682c      	ldr	r4, [r5, #0]
                    if( xPendedCounts > ( TickType_t ) 0U )
 8002032:	2c00      	cmp	r4, #0
 8002034:	d00a      	beq.n	800204c <xTaskResumeAll+0x98>
                                xYieldPending = pdTRUE;
 8002036:	2601      	movs	r6, #1
                            if( xTaskIncrementTick() != pdFALSE )
 8002038:	f7ff ff5a 	bl	8001ef0 <xTaskIncrementTick>
 800203c:	2800      	cmp	r0, #0
 800203e:	d001      	beq.n	8002044 <xTaskResumeAll+0x90>
                                xYieldPending = pdTRUE;
 8002040:	4b0a      	ldr	r3, [pc, #40]	; (800206c <xTaskResumeAll+0xb8>)
 8002042:	601e      	str	r6, [r3, #0]
                            --xPendedCounts;
 8002044:	3c01      	subs	r4, #1
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8002046:	2c00      	cmp	r4, #0
 8002048:	d1f6      	bne.n	8002038 <xTaskResumeAll+0x84>
                        xPendedTicks = 0;
 800204a:	602c      	str	r4, [r5, #0]
                if( xYieldPending != pdFALSE )
 800204c:	4b07      	ldr	r3, [pc, #28]	; (800206c <xTaskResumeAll+0xb8>)
 800204e:	681b      	ldr	r3, [r3, #0]
 8002050:	e7c3      	b.n	8001fda <xTaskResumeAll+0x26>
                    prvAddTaskToReadyList( pxTCB );
 8002052:	2614      	movs	r6, #20
                        xYieldPending = pdTRUE;
 8002054:	2701      	movs	r7, #1
 8002056:	e7e2      	b.n	800201e <xTaskResumeAll+0x6a>
 8002058:	200000a4 	.word	0x200000a4
 800205c:	2000009c 	.word	0x2000009c
 8002060:	200000ac 	.word	0x200000ac
 8002064:	20000038 	.word	0x20000038
 8002068:	2000002c 	.word	0x2000002c
 800206c:	2000012c 	.word	0x2000012c
 8002070:	200000e8 	.word	0x200000e8
 8002074:	200000e4 	.word	0x200000e4

08002078 <vTaskSwitchContext>:
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8002078:	4b15      	ldr	r3, [pc, #84]	; (80020d0 <vTaskSwitchContext+0x58>)
{
 800207a:	b530      	push	{r4, r5, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800207c:	681a      	ldr	r2, [r3, #0]
 800207e:	4b15      	ldr	r3, [pc, #84]	; (80020d4 <vTaskSwitchContext+0x5c>)
 8002080:	2a00      	cmp	r2, #0
 8002082:	d002      	beq.n	800208a <vTaskSwitchContext+0x12>
        xYieldPending = pdTRUE;
 8002084:	2201      	movs	r2, #1
 8002086:	601a      	str	r2, [r3, #0]
}
 8002088:	bd30      	pop	{r4, r5, pc}
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800208a:	2514      	movs	r5, #20
 800208c:	4812      	ldr	r0, [pc, #72]	; (80020d8 <vTaskSwitchContext+0x60>)
        xYieldPending = pdFALSE;
 800208e:	601a      	str	r2, [r3, #0]
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002090:	6802      	ldr	r2, [r0, #0]
 8002092:	4912      	ldr	r1, [pc, #72]	; (80020dc <vTaskSwitchContext+0x64>)
 8002094:	002b      	movs	r3, r5
 8002096:	4353      	muls	r3, r2
 8002098:	585c      	ldr	r4, [r3, r1]
 800209a:	2c00      	cmp	r4, #0
 800209c:	d012      	beq.n	80020c4 <vTaskSwitchContext+0x4c>
 800209e:	18cc      	adds	r4, r1, r3
 80020a0:	6865      	ldr	r5, [r4, #4]
 80020a2:	3308      	adds	r3, #8
 80020a4:	686d      	ldr	r5, [r5, #4]
 80020a6:	18cb      	adds	r3, r1, r3
 80020a8:	6065      	str	r5, [r4, #4]
 80020aa:	429d      	cmp	r5, r3
 80020ac:	d101      	bne.n	80020b2 <vTaskSwitchContext+0x3a>
 80020ae:	686b      	ldr	r3, [r5, #4]
 80020b0:	6063      	str	r3, [r4, #4]
 80020b2:	2314      	movs	r3, #20
 80020b4:	4353      	muls	r3, r2
 80020b6:	18c9      	adds	r1, r1, r3
 80020b8:	684b      	ldr	r3, [r1, #4]
 80020ba:	68d9      	ldr	r1, [r3, #12]
 80020bc:	4b08      	ldr	r3, [pc, #32]	; (80020e0 <vTaskSwitchContext+0x68>)
 80020be:	6019      	str	r1, [r3, #0]
 80020c0:	6002      	str	r2, [r0, #0]
}
 80020c2:	e7e1      	b.n	8002088 <vTaskSwitchContext+0x10>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80020c4:	2a00      	cmp	r2, #0
 80020c6:	d101      	bne.n	80020cc <vTaskSwitchContext+0x54>
 80020c8:	b672      	cpsid	i
 80020ca:	e7fe      	b.n	80020ca <vTaskSwitchContext+0x52>
 80020cc:	3a01      	subs	r2, #1
 80020ce:	e7e1      	b.n	8002094 <vTaskSwitchContext+0x1c>
 80020d0:	200000a4 	.word	0x200000a4
 80020d4:	2000012c 	.word	0x2000012c
 80020d8:	200000ac 	.word	0x200000ac
 80020dc:	20000038 	.word	0x20000038
 80020e0:	2000002c 	.word	0x2000002c

080020e4 <vTaskPlaceOnEventList>:
{
 80020e4:	b510      	push	{r4, lr}
 80020e6:	000c      	movs	r4, r1
    configASSERT( pxEventList );
 80020e8:	2800      	cmp	r0, #0
 80020ea:	d101      	bne.n	80020f0 <vTaskPlaceOnEventList+0xc>
 80020ec:	b672      	cpsid	i
 80020ee:	e7fe      	b.n	80020ee <vTaskPlaceOnEventList+0xa>
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80020f0:	4b04      	ldr	r3, [pc, #16]	; (8002104 <vTaskPlaceOnEventList+0x20>)
 80020f2:	6819      	ldr	r1, [r3, #0]
 80020f4:	3118      	adds	r1, #24
 80020f6:	f7ff fad1 	bl	800169c <vListInsert>
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80020fa:	2101      	movs	r1, #1
 80020fc:	0020      	movs	r0, r4
 80020fe:	f7ff fd83 	bl	8001c08 <prvAddCurrentTaskToDelayedList>
}
 8002102:	bd10      	pop	{r4, pc}
 8002104:	2000002c 	.word	0x2000002c

08002108 <vTaskPlaceOnEventListRestricted>:
    {
 8002108:	b570      	push	{r4, r5, r6, lr}
 800210a:	000c      	movs	r4, r1
 800210c:	0015      	movs	r5, r2
        configASSERT( pxEventList );
 800210e:	2800      	cmp	r0, #0
 8002110:	d101      	bne.n	8002116 <vTaskPlaceOnEventListRestricted+0xe>
 8002112:	b672      	cpsid	i
 8002114:	e7fe      	b.n	8002114 <vTaskPlaceOnEventListRestricted+0xc>
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002116:	4b07      	ldr	r3, [pc, #28]	; (8002134 <vTaskPlaceOnEventListRestricted+0x2c>)
 8002118:	6819      	ldr	r1, [r3, #0]
 800211a:	3118      	adds	r1, #24
 800211c:	f7ff fab2 	bl	8001684 <vListInsertEnd>
        if( xWaitIndefinitely != pdFALSE )
 8002120:	2d00      	cmp	r5, #0
 8002122:	d001      	beq.n	8002128 <vTaskPlaceOnEventListRestricted+0x20>
            xTicksToWait = portMAX_DELAY;
 8002124:	2401      	movs	r4, #1
 8002126:	4264      	negs	r4, r4
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002128:	0029      	movs	r1, r5
 800212a:	0020      	movs	r0, r4
 800212c:	f7ff fd6c 	bl	8001c08 <prvAddCurrentTaskToDelayedList>
    }
 8002130:	bd70      	pop	{r4, r5, r6, pc}
 8002132:	46c0      	nop			; (mov r8, r8)
 8002134:	2000002c 	.word	0x2000002c

08002138 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002138:	68c3      	ldr	r3, [r0, #12]
{
 800213a:	b570      	push	{r4, r5, r6, lr}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800213c:	68dc      	ldr	r4, [r3, #12]
    configASSERT( pxUnblockedTCB );
 800213e:	2c00      	cmp	r4, #0
 8002140:	d101      	bne.n	8002146 <xTaskRemoveFromEventList+0xe>
 8002142:	b672      	cpsid	i
 8002144:	e7fe      	b.n	8002144 <xTaskRemoveFromEventList+0xc>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8002146:	0025      	movs	r5, r4
 8002148:	3518      	adds	r5, #24
 800214a:	0028      	movs	r0, r5
 800214c:	f7ff fabd 	bl	80016ca <uxListRemove>
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002150:	4b11      	ldr	r3, [pc, #68]	; (8002198 <xTaskRemoveFromEventList+0x60>)
 8002152:	681b      	ldr	r3, [r3, #0]
 8002154:	2b00      	cmp	r3, #0
 8002156:	d11b      	bne.n	8002190 <xTaskRemoveFromEventList+0x58>
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8002158:	1d25      	adds	r5, r4, #4
 800215a:	0028      	movs	r0, r5
 800215c:	f7ff fab5 	bl	80016ca <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
 8002160:	4a0e      	ldr	r2, [pc, #56]	; (800219c <xTaskRemoveFromEventList+0x64>)
 8002162:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002164:	6811      	ldr	r1, [r2, #0]
 8002166:	428b      	cmp	r3, r1
 8002168:	d900      	bls.n	800216c <xTaskRemoveFromEventList+0x34>
 800216a:	6013      	str	r3, [r2, #0]
 800216c:	2014      	movs	r0, #20
 800216e:	0029      	movs	r1, r5
 8002170:	4343      	muls	r3, r0
 8002172:	480b      	ldr	r0, [pc, #44]	; (80021a0 <xTaskRemoveFromEventList+0x68>)
 8002174:	18c0      	adds	r0, r0, r3
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002176:	f7ff fa85 	bl	8001684 <vListInsertEnd>
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800217a:	4b0a      	ldr	r3, [pc, #40]	; (80021a4 <xTaskRemoveFromEventList+0x6c>)
 800217c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800217e:	681b      	ldr	r3, [r3, #0]
        xReturn = pdFALSE;
 8002180:	2000      	movs	r0, #0
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8002182:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002184:	429a      	cmp	r2, r3
 8002186:	d902      	bls.n	800218e <xTaskRemoveFromEventList+0x56>
        xYieldPending = pdTRUE;
 8002188:	4b07      	ldr	r3, [pc, #28]	; (80021a8 <xTaskRemoveFromEventList+0x70>)
 800218a:	3001      	adds	r0, #1
 800218c:	6018      	str	r0, [r3, #0]
}
 800218e:	bd70      	pop	{r4, r5, r6, pc}
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002190:	0029      	movs	r1, r5
 8002192:	4806      	ldr	r0, [pc, #24]	; (80021ac <xTaskRemoveFromEventList+0x74>)
 8002194:	e7ef      	b.n	8002176 <xTaskRemoveFromEventList+0x3e>
 8002196:	46c0      	nop			; (mov r8, r8)
 8002198:	200000a4 	.word	0x200000a4
 800219c:	200000ac 	.word	0x200000ac
 80021a0:	20000038 	.word	0x20000038
 80021a4:	2000002c 	.word	0x2000002c
 80021a8:	2000012c 	.word	0x2000012c
 80021ac:	200000e8 	.word	0x200000e8

080021b0 <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 80021b0:	4b03      	ldr	r3, [pc, #12]	; (80021c0 <vTaskInternalSetTimeOutState+0x10>)
 80021b2:	681b      	ldr	r3, [r3, #0]
 80021b4:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 80021b6:	4b03      	ldr	r3, [pc, #12]	; (80021c4 <vTaskInternalSetTimeOutState+0x14>)
 80021b8:	681b      	ldr	r3, [r3, #0]
 80021ba:	6043      	str	r3, [r0, #4]
}
 80021bc:	4770      	bx	lr
 80021be:	46c0      	nop			; (mov r8, r8)
 80021c0:	200000e0 	.word	0x200000e0
 80021c4:	20000128 	.word	0x20000128

080021c8 <xTaskCheckForTimeOut>:
{
 80021c8:	b570      	push	{r4, r5, r6, lr}
 80021ca:	0004      	movs	r4, r0
 80021cc:	000d      	movs	r5, r1
    configASSERT( pxTimeOut );
 80021ce:	2800      	cmp	r0, #0
 80021d0:	d101      	bne.n	80021d6 <xTaskCheckForTimeOut+0xe>
 80021d2:	b672      	cpsid	i
 80021d4:	e7fe      	b.n	80021d4 <xTaskCheckForTimeOut+0xc>
    configASSERT( pxTicksToWait );
 80021d6:	2900      	cmp	r1, #0
 80021d8:	d101      	bne.n	80021de <xTaskCheckForTimeOut+0x16>
 80021da:	b672      	cpsid	i
 80021dc:	e7fe      	b.n	80021dc <xTaskCheckForTimeOut+0x14>
    taskENTER_CRITICAL();
 80021de:	f000 fb07 	bl	80027f0 <vPortEnterCritical>
        const TickType_t xConstTickCount = xTickCount;
 80021e2:	4b10      	ldr	r3, [pc, #64]	; (8002224 <xTaskCheckForTimeOut+0x5c>)
                xReturn = pdFALSE;
 80021e4:	2600      	movs	r6, #0
        const TickType_t xConstTickCount = xTickCount;
 80021e6:	6819      	ldr	r1, [r3, #0]
            if( *pxTicksToWait == portMAX_DELAY )
 80021e8:	682b      	ldr	r3, [r5, #0]
 80021ea:	1c5a      	adds	r2, r3, #1
 80021ec:	d00a      	beq.n	8002204 <xTaskCheckForTimeOut+0x3c>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80021ee:	480e      	ldr	r0, [pc, #56]	; (8002228 <xTaskCheckForTimeOut+0x60>)
 80021f0:	6826      	ldr	r6, [r4, #0]
 80021f2:	6800      	ldr	r0, [r0, #0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80021f4:	6862      	ldr	r2, [r4, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80021f6:	4286      	cmp	r6, r0
 80021f8:	d008      	beq.n	800220c <xTaskCheckForTimeOut+0x44>
 80021fa:	428a      	cmp	r2, r1
 80021fc:	d806      	bhi.n	800220c <xTaskCheckForTimeOut+0x44>
            *pxTicksToWait = ( TickType_t ) 0;
 80021fe:	2300      	movs	r3, #0
            xReturn = pdTRUE;
 8002200:	2601      	movs	r6, #1
            *pxTicksToWait = ( TickType_t ) 0;
 8002202:	602b      	str	r3, [r5, #0]
    taskEXIT_CRITICAL();
 8002204:	f000 fb00 	bl	8002808 <vPortExitCritical>
}
 8002208:	0030      	movs	r0, r6
 800220a:	bd70      	pop	{r4, r5, r6, pc}
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800220c:	1a88      	subs	r0, r1, r2
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800220e:	4283      	cmp	r3, r0
 8002210:	d9f5      	bls.n	80021fe <xTaskCheckForTimeOut+0x36>
            *pxTicksToWait -= xElapsedTime;
 8002212:	1a5b      	subs	r3, r3, r1
 8002214:	189b      	adds	r3, r3, r2
            vTaskInternalSetTimeOutState( pxTimeOut );
 8002216:	0020      	movs	r0, r4
            *pxTicksToWait -= xElapsedTime;
 8002218:	602b      	str	r3, [r5, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
 800221a:	f7ff ffc9 	bl	80021b0 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 800221e:	2600      	movs	r6, #0
 8002220:	e7f0      	b.n	8002204 <xTaskCheckForTimeOut+0x3c>
 8002222:	46c0      	nop			; (mov r8, r8)
 8002224:	20000128 	.word	0x20000128
 8002228:	200000e0 	.word	0x200000e0

0800222c <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 800222c:	2201      	movs	r2, #1
 800222e:	4b01      	ldr	r3, [pc, #4]	; (8002234 <vTaskMissedYield+0x8>)
 8002230:	601a      	str	r2, [r3, #0]
}
 8002232:	4770      	bx	lr
 8002234:	2000012c 	.word	0x2000012c

08002238 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 8002238:	4b05      	ldr	r3, [pc, #20]	; (8002250 <xTaskGetSchedulerState+0x18>)
            xReturn = taskSCHEDULER_NOT_STARTED;
 800223a:	2001      	movs	r0, #1
        if( xSchedulerRunning == pdFALSE )
 800223c:	681b      	ldr	r3, [r3, #0]
 800223e:	2b00      	cmp	r3, #0
 8002240:	d004      	beq.n	800224c <xTaskGetSchedulerState+0x14>
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002242:	4b04      	ldr	r3, [pc, #16]	; (8002254 <xTaskGetSchedulerState+0x1c>)
 8002244:	6818      	ldr	r0, [r3, #0]
                xReturn = taskSCHEDULER_SUSPENDED;
 8002246:	4243      	negs	r3, r0
 8002248:	4158      	adcs	r0, r3
 800224a:	0040      	lsls	r0, r0, #1
    }
 800224c:	4770      	bx	lr
 800224e:	46c0      	nop			; (mov r8, r8)
 8002250:	200000fc 	.word	0x200000fc
 8002254:	200000a4 	.word	0x200000a4

08002258 <xTaskPriorityDisinherit>:
    {
 8002258:	b570      	push	{r4, r5, r6, lr}
        if( pxMutexHolder != NULL )
 800225a:	2800      	cmp	r0, #0
 800225c:	d101      	bne.n	8002262 <xTaskPriorityDisinherit+0xa>
        BaseType_t xReturn = pdFALSE;
 800225e:	2000      	movs	r0, #0
    }
 8002260:	bd70      	pop	{r4, r5, r6, pc}
            configASSERT( pxTCB == pxCurrentTCB );
 8002262:	4b15      	ldr	r3, [pc, #84]	; (80022b8 <xTaskPriorityDisinherit+0x60>)
 8002264:	681c      	ldr	r4, [r3, #0]
 8002266:	4284      	cmp	r4, r0
 8002268:	d001      	beq.n	800226e <xTaskPriorityDisinherit+0x16>
 800226a:	b672      	cpsid	i
 800226c:	e7fe      	b.n	800226c <xTaskPriorityDisinherit+0x14>
            configASSERT( pxTCB->uxMutexesHeld );
 800226e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002270:	2b00      	cmp	r3, #0
 8002272:	d101      	bne.n	8002278 <xTaskPriorityDisinherit+0x20>
 8002274:	b672      	cpsid	i
 8002276:	e7fe      	b.n	8002276 <xTaskPriorityDisinherit+0x1e>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002278:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800227a:	6c61      	ldr	r1, [r4, #68]	; 0x44
            ( pxTCB->uxMutexesHeld )--;
 800227c:	3b01      	subs	r3, #1
 800227e:	64a3      	str	r3, [r4, #72]	; 0x48
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002280:	428a      	cmp	r2, r1
 8002282:	d0ec      	beq.n	800225e <xTaskPriorityDisinherit+0x6>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8002284:	2b00      	cmp	r3, #0
 8002286:	d1ea      	bne.n	800225e <xTaskPriorityDisinherit+0x6>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002288:	1d25      	adds	r5, r4, #4
 800228a:	0028      	movs	r0, r5
 800228c:	f7ff fa1d 	bl	80016ca <uxListRemove>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002290:	2305      	movs	r3, #5
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002292:	6c60      	ldr	r0, [r4, #68]	; 0x44
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002294:	1a1b      	subs	r3, r3, r0
 8002296:	61a3      	str	r3, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
 8002298:	4b08      	ldr	r3, [pc, #32]	; (80022bc <xTaskPriorityDisinherit+0x64>)
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 800229a:	62e0      	str	r0, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxTCB );
 800229c:	681a      	ldr	r2, [r3, #0]
 800229e:	4290      	cmp	r0, r2
 80022a0:	d900      	bls.n	80022a4 <xTaskPriorityDisinherit+0x4c>
 80022a2:	6018      	str	r0, [r3, #0]
 80022a4:	2314      	movs	r3, #20
 80022a6:	4343      	muls	r3, r0
 80022a8:	4805      	ldr	r0, [pc, #20]	; (80022c0 <xTaskPriorityDisinherit+0x68>)
 80022aa:	0029      	movs	r1, r5
 80022ac:	18c0      	adds	r0, r0, r3
 80022ae:	f7ff f9e9 	bl	8001684 <vListInsertEnd>
                    xReturn = pdTRUE;
 80022b2:	2001      	movs	r0, #1
        return xReturn;
 80022b4:	e7d4      	b.n	8002260 <xTaskPriorityDisinherit+0x8>
 80022b6:	46c0      	nop			; (mov r8, r8)
 80022b8:	2000002c 	.word	0x2000002c
 80022bc:	200000ac 	.word	0x200000ac
 80022c0:	20000038 	.word	0x20000038

080022c4 <xTaskGenericNotifyWait>:
    {
 80022c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80022c6:	000f      	movs	r7, r1
 80022c8:	0016      	movs	r6, r2
 80022ca:	001d      	movs	r5, r3
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80022cc:	2800      	cmp	r0, #0
 80022ce:	d001      	beq.n	80022d4 <xTaskGenericNotifyWait+0x10>
 80022d0:	b672      	cpsid	i
 80022d2:	e7fe      	b.n	80022d2 <xTaskGenericNotifyWait+0xe>
        taskENTER_CRITICAL();
 80022d4:	f000 fa8c 	bl	80027f0 <vPortEnterCritical>
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 80022d8:	4c18      	ldr	r4, [pc, #96]	; (800233c <xTaskGenericNotifyWait+0x78>)
 80022da:	6823      	ldr	r3, [r4, #0]
 80022dc:	3350      	adds	r3, #80	; 0x50
 80022de:	781b      	ldrb	r3, [r3, #0]
 80022e0:	2b02      	cmp	r3, #2
 80022e2:	d00f      	beq.n	8002304 <xTaskGenericNotifyWait+0x40>
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 80022e4:	2101      	movs	r1, #1
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 80022e6:	6822      	ldr	r2, [r4, #0]
 80022e8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80022ea:	43bb      	bics	r3, r7
 80022ec:	64d3      	str	r3, [r2, #76]	; 0x4c
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 80022ee:	6823      	ldr	r3, [r4, #0]
 80022f0:	3350      	adds	r3, #80	; 0x50
 80022f2:	7019      	strb	r1, [r3, #0]
                if( xTicksToWait > ( TickType_t ) 0 )
 80022f4:	9b06      	ldr	r3, [sp, #24]
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d004      	beq.n	8002304 <xTaskGenericNotifyWait+0x40>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80022fa:	0018      	movs	r0, r3
 80022fc:	f7ff fc84 	bl	8001c08 <prvAddCurrentTaskToDelayedList>
                    portYIELD_WITHIN_API();
 8002300:	f000 fa6a 	bl	80027d8 <vPortYield>
        taskEXIT_CRITICAL();
 8002304:	f000 fa80 	bl	8002808 <vPortExitCritical>
        taskENTER_CRITICAL();
 8002308:	f000 fa72 	bl	80027f0 <vPortEnterCritical>
            if( pulNotificationValue != NULL )
 800230c:	2d00      	cmp	r5, #0
 800230e:	d002      	beq.n	8002316 <xTaskGenericNotifyWait+0x52>
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 8002310:	6823      	ldr	r3, [r4, #0]
 8002312:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002314:	602b      	str	r3, [r5, #0]
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 8002316:	6823      	ldr	r3, [r4, #0]
                xReturn = pdFALSE;
 8002318:	2500      	movs	r5, #0
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 800231a:	3350      	adds	r3, #80	; 0x50
 800231c:	781b      	ldrb	r3, [r3, #0]
 800231e:	2b02      	cmp	r3, #2
 8002320:	d104      	bne.n	800232c <xTaskGenericNotifyWait+0x68>
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 8002322:	6822      	ldr	r2, [r4, #0]
                xReturn = pdTRUE;
 8002324:	3501      	adds	r5, #1
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 8002326:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8002328:	43b3      	bics	r3, r6
 800232a:	64d3      	str	r3, [r2, #76]	; 0x4c
            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 800232c:	2200      	movs	r2, #0
 800232e:	6823      	ldr	r3, [r4, #0]
 8002330:	3350      	adds	r3, #80	; 0x50
 8002332:	701a      	strb	r2, [r3, #0]
        taskEXIT_CRITICAL();
 8002334:	f000 fa68 	bl	8002808 <vPortExitCritical>
    }
 8002338:	0028      	movs	r0, r5
 800233a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800233c:	2000002c 	.word	0x2000002c

08002340 <xTaskGenericNotifyFromISR>:
    {
 8002340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002342:	0004      	movs	r4, r0
 8002344:	0017      	movs	r7, r2
 8002346:	001d      	movs	r5, r3
        configASSERT( xTaskToNotify );
 8002348:	2800      	cmp	r0, #0
 800234a:	d101      	bne.n	8002350 <xTaskGenericNotifyFromISR+0x10>
 800234c:	b672      	cpsid	i
 800234e:	e7fe      	b.n	800234e <xTaskGenericNotifyFromISR+0xe>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8002350:	2900      	cmp	r1, #0
 8002352:	d001      	beq.n	8002358 <xTaskGenericNotifyFromISR+0x18>
 8002354:	b672      	cpsid	i
 8002356:	e7fe      	b.n	8002356 <xTaskGenericNotifyFromISR+0x16>
        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8002358:	f000 fa64 	bl	8002824 <ulSetInterruptMaskFromISR>
            if( pulPreviousNotificationValue != NULL )
 800235c:	9b06      	ldr	r3, [sp, #24]
        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800235e:	0006      	movs	r6, r0
            if( pulPreviousNotificationValue != NULL )
 8002360:	2b00      	cmp	r3, #0
 8002362:	d002      	beq.n	800236a <xTaskGenericNotifyFromISR+0x2a>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 8002364:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8002366:	9a06      	ldr	r2, [sp, #24]
 8002368:	6013      	str	r3, [r2, #0]
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 800236a:	0022      	movs	r2, r4
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 800236c:	2102      	movs	r1, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 800236e:	3250      	adds	r2, #80	; 0x50
 8002370:	7813      	ldrb	r3, [r2, #0]
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8002372:	7011      	strb	r1, [r2, #0]
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8002374:	b2db      	uxtb	r3, r3
            switch( eAction )
 8002376:	2d04      	cmp	r5, #4
 8002378:	d817      	bhi.n	80023aa <xTaskGenericNotifyFromISR+0x6a>
 800237a:	0028      	movs	r0, r5
 800237c:	f7fd fece 	bl	800011c <__gnu_thumb1_case_uqi>
 8002380:	130e0306 	.word	0x130e0306
 8002384:	11          	.byte	0x11
 8002385:	00          	.byte	0x00
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 8002386:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8002388:	433a      	orrs	r2, r7
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 800238a:	64e2      	str	r2, [r4, #76]	; 0x4c
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800238c:	2b01      	cmp	r3, #1
 800238e:	d012      	beq.n	80023b6 <xTaskGenericNotifyFromISR+0x76>
 8002390:	2401      	movs	r4, #1
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8002392:	0030      	movs	r0, r6
 8002394:	f000 fa4a 	bl	800282c <vClearInterruptMaskFromISR>
    }
 8002398:	0020      	movs	r0, r4
 800239a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 800239c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800239e:	3201      	adds	r2, #1
 80023a0:	e7f3      	b.n	800238a <xTaskGenericNotifyFromISR+0x4a>
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 80023a2:	2b02      	cmp	r3, #2
 80023a4:	d033      	beq.n	800240e <xTaskGenericNotifyFromISR+0xce>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 80023a6:	64e7      	str	r7, [r4, #76]	; 0x4c
 80023a8:	e7f0      	b.n	800238c <xTaskGenericNotifyFromISR+0x4c>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
 80023aa:	4a1a      	ldr	r2, [pc, #104]	; (8002414 <xTaskGenericNotifyFromISR+0xd4>)
 80023ac:	6812      	ldr	r2, [r2, #0]
 80023ae:	2a00      	cmp	r2, #0
 80023b0:	d0ec      	beq.n	800238c <xTaskGenericNotifyFromISR+0x4c>
 80023b2:	b672      	cpsid	i
 80023b4:	e7fe      	b.n	80023b4 <xTaskGenericNotifyFromISR+0x74>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80023b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80023b8:	2b00      	cmp	r3, #0
 80023ba:	d001      	beq.n	80023c0 <xTaskGenericNotifyFromISR+0x80>
 80023bc:	b672      	cpsid	i
 80023be:	e7fe      	b.n	80023be <xTaskGenericNotifyFromISR+0x7e>
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80023c0:	4b15      	ldr	r3, [pc, #84]	; (8002418 <xTaskGenericNotifyFromISR+0xd8>)
 80023c2:	681b      	ldr	r3, [r3, #0]
 80023c4:	2b00      	cmp	r3, #0
 80023c6:	d11e      	bne.n	8002406 <xTaskGenericNotifyFromISR+0xc6>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80023c8:	1d25      	adds	r5, r4, #4
 80023ca:	0028      	movs	r0, r5
 80023cc:	f7ff f97d 	bl	80016ca <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 80023d0:	4a12      	ldr	r2, [pc, #72]	; (800241c <xTaskGenericNotifyFromISR+0xdc>)
 80023d2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80023d4:	6811      	ldr	r1, [r2, #0]
 80023d6:	428b      	cmp	r3, r1
 80023d8:	d900      	bls.n	80023dc <xTaskGenericNotifyFromISR+0x9c>
 80023da:	6013      	str	r3, [r2, #0]
 80023dc:	2014      	movs	r0, #20
 80023de:	0029      	movs	r1, r5
 80023e0:	4343      	muls	r3, r0
 80023e2:	480f      	ldr	r0, [pc, #60]	; (8002420 <xTaskGenericNotifyFromISR+0xe0>)
 80023e4:	18c0      	adds	r0, r0, r3
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80023e6:	f7ff f94d 	bl	8001684 <vListInsertEnd>
                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80023ea:	4b0e      	ldr	r3, [pc, #56]	; (8002424 <xTaskGenericNotifyFromISR+0xe4>)
 80023ec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80023ee:	681b      	ldr	r3, [r3, #0]
 80023f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023f2:	429a      	cmp	r2, r3
 80023f4:	d9cc      	bls.n	8002390 <xTaskGenericNotifyFromISR+0x50>
                    if( pxHigherPriorityTaskWoken != NULL )
 80023f6:	9a07      	ldr	r2, [sp, #28]
 80023f8:	2301      	movs	r3, #1
 80023fa:	2a00      	cmp	r2, #0
 80023fc:	d000      	beq.n	8002400 <xTaskGenericNotifyFromISR+0xc0>
                        *pxHigherPriorityTaskWoken = pdTRUE;
 80023fe:	6013      	str	r3, [r2, #0]
                    xYieldPending = pdTRUE;
 8002400:	4a09      	ldr	r2, [pc, #36]	; (8002428 <xTaskGenericNotifyFromISR+0xe8>)
 8002402:	6013      	str	r3, [r2, #0]
 8002404:	e7c4      	b.n	8002390 <xTaskGenericNotifyFromISR+0x50>
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8002406:	0021      	movs	r1, r4
 8002408:	4808      	ldr	r0, [pc, #32]	; (800242c <xTaskGenericNotifyFromISR+0xec>)
 800240a:	3118      	adds	r1, #24
 800240c:	e7eb      	b.n	80023e6 <xTaskGenericNotifyFromISR+0xa6>
                        xReturn = pdFAIL;
 800240e:	2400      	movs	r4, #0
 8002410:	e7bf      	b.n	8002392 <xTaskGenericNotifyFromISR+0x52>
 8002412:	46c0      	nop			; (mov r8, r8)
 8002414:	20000128 	.word	0x20000128
 8002418:	200000a4 	.word	0x200000a4
 800241c:	200000ac 	.word	0x200000ac
 8002420:	20000038 	.word	0x20000038
 8002424:	2000002c 	.word	0x2000002c
 8002428:	2000012c 	.word	0x2000012c
 800242c:	200000e8 	.word	0x200000e8

08002430 <prvCheckForValidListAndQueue>:
        pxOverflowTimerList = pxTemp;
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 8002430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 8002432:	f000 f9dd 	bl	80027f0 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 8002436:	4c0f      	ldr	r4, [pc, #60]	; (8002474 <prvCheckForValidListAndQueue+0x44>)
 8002438:	6825      	ldr	r5, [r4, #0]
 800243a:	2d00      	cmp	r5, #0
 800243c:	d116      	bne.n	800246c <prvCheckForValidListAndQueue+0x3c>
            {
                vListInitialise( &xActiveTimerList1 );
 800243e:	4f0e      	ldr	r7, [pc, #56]	; (8002478 <prvCheckForValidListAndQueue+0x48>)
 8002440:	0038      	movs	r0, r7
 8002442:	f7ff f911 	bl	8001668 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 8002446:	4e0d      	ldr	r6, [pc, #52]	; (800247c <prvCheckForValidListAndQueue+0x4c>)
 8002448:	0030      	movs	r0, r6
 800244a:	f7ff f90d 	bl	8001668 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 800244e:	4b0c      	ldr	r3, [pc, #48]	; (8002480 <prvCheckForValidListAndQueue+0x50>)

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002450:	002a      	movs	r2, r5
                pxCurrentTimerList = &xActiveTimerList1;
 8002452:	601f      	str	r7, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 8002454:	4b0b      	ldr	r3, [pc, #44]	; (8002484 <prvCheckForValidListAndQueue+0x54>)
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002456:	210c      	movs	r1, #12
 8002458:	2005      	movs	r0, #5
                pxOverflowTimerList = &xActiveTimerList2;
 800245a:	601e      	str	r6, [r3, #0]
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 800245c:	f7ff fa01 	bl	8001862 <xQueueGenericCreate>
 8002460:	6020      	str	r0, [r4, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
 8002462:	2800      	cmp	r0, #0
 8002464:	d002      	beq.n	800246c <prvCheckForValidListAndQueue+0x3c>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8002466:	4908      	ldr	r1, [pc, #32]	; (8002488 <prvCheckForValidListAndQueue+0x58>)
 8002468:	f7ff fb84 	bl	8001b74 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 800246c:	f000 f9cc 	bl	8002808 <vPortExitCritical>
    }
 8002470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002472:	46c0      	nop			; (mov r8, r8)
 8002474:	20000164 	.word	0x20000164
 8002478:	20000138 	.word	0x20000138
 800247c:	2000014c 	.word	0x2000014c
 8002480:	20000130 	.word	0x20000130
 8002484:	20000134 	.word	0x20000134
 8002488:	08002b97 	.word	0x08002b97

0800248c <prvInsertTimerInActiveList>:
    {
 800248c:	b510      	push	{r4, lr}
 800248e:	0004      	movs	r4, r0
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002490:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002492:	6100      	str	r0, [r0, #16]
        if( xNextExpiryTime <= xTimeNow )
 8002494:	4291      	cmp	r1, r2
 8002496:	d80b      	bhi.n	80024b0 <prvInsertTimerInActiveList+0x24>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002498:	1ad2      	subs	r2, r2, r3
 800249a:	69a3      	ldr	r3, [r4, #24]
                xProcessTimerNow = pdTRUE;
 800249c:	2001      	movs	r0, #1
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800249e:	429a      	cmp	r2, r3
 80024a0:	d205      	bcs.n	80024ae <prvInsertTimerInActiveList+0x22>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80024a2:	4b07      	ldr	r3, [pc, #28]	; (80024c0 <prvInsertTimerInActiveList+0x34>)
 80024a4:	1d21      	adds	r1, r4, #4
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80024a6:	6818      	ldr	r0, [r3, #0]
 80024a8:	f7ff f8f8 	bl	800169c <vListInsert>
        BaseType_t xProcessTimerNow = pdFALSE;
 80024ac:	2000      	movs	r0, #0
    }
 80024ae:	bd10      	pop	{r4, pc}
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80024b0:	429a      	cmp	r2, r3
 80024b2:	d202      	bcs.n	80024ba <prvInsertTimerInActiveList+0x2e>
                xProcessTimerNow = pdTRUE;
 80024b4:	2001      	movs	r0, #1
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80024b6:	4299      	cmp	r1, r3
 80024b8:	d2f9      	bcs.n	80024ae <prvInsertTimerInActiveList+0x22>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80024ba:	4b02      	ldr	r3, [pc, #8]	; (80024c4 <prvInsertTimerInActiveList+0x38>)
 80024bc:	1d21      	adds	r1, r4, #4
 80024be:	e7f2      	b.n	80024a6 <prvInsertTimerInActiveList+0x1a>
 80024c0:	20000134 	.word	0x20000134
 80024c4:	20000130 	.word	0x20000130

080024c8 <xTimerCreateTimerTask>:
    {
 80024c8:	b507      	push	{r0, r1, r2, lr}
        prvCheckForValidListAndQueue();
 80024ca:	f7ff ffb1 	bl	8002430 <prvCheckForValidListAndQueue>
        if( xTimerQueue != NULL )
 80024ce:	4b09      	ldr	r3, [pc, #36]	; (80024f4 <xTimerCreateTimerTask+0x2c>)
 80024d0:	681b      	ldr	r3, [r3, #0]
 80024d2:	2b00      	cmp	r3, #0
 80024d4:	d101      	bne.n	80024da <xTimerCreateTimerTask+0x12>
        configASSERT( xReturn );
 80024d6:	b672      	cpsid	i
 80024d8:	e7fe      	b.n	80024d8 <xTimerCreateTimerTask+0x10>
                    xReturn = xTaskCreate( prvTimerTask,
 80024da:	4b07      	ldr	r3, [pc, #28]	; (80024f8 <xTimerCreateTimerTask+0x30>)
 80024dc:	2250      	movs	r2, #80	; 0x50
 80024de:	9301      	str	r3, [sp, #4]
 80024e0:	2302      	movs	r3, #2
 80024e2:	4906      	ldr	r1, [pc, #24]	; (80024fc <xTimerCreateTimerTask+0x34>)
 80024e4:	9300      	str	r3, [sp, #0]
 80024e6:	4806      	ldr	r0, [pc, #24]	; (8002500 <xTimerCreateTimerTask+0x38>)
 80024e8:	2300      	movs	r3, #0
 80024ea:	f7ff fbeb 	bl	8001cc4 <xTaskCreate>
        configASSERT( xReturn );
 80024ee:	2800      	cmp	r0, #0
 80024f0:	d0f1      	beq.n	80024d6 <xTimerCreateTimerTask+0xe>
    }
 80024f2:	bd0e      	pop	{r1, r2, r3, pc}
 80024f4:	20000164 	.word	0x20000164
 80024f8:	20000168 	.word	0x20000168
 80024fc:	08002b9c 	.word	0x08002b9c
 8002500:	080025bd 	.word	0x080025bd

08002504 <xTimerGenericCommand>:
    {
 8002504:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002506:	0017      	movs	r7, r2
 8002508:	0004      	movs	r4, r0
 800250a:	001a      	movs	r2, r3
 800250c:	b085      	sub	sp, #20
        configASSERT( xTimer );
 800250e:	2800      	cmp	r0, #0
 8002510:	d101      	bne.n	8002516 <xTimerGenericCommand+0x12>
 8002512:	b672      	cpsid	i
 8002514:	e7fe      	b.n	8002514 <xTimerGenericCommand+0x10>
        if( xTimerQueue != NULL )
 8002516:	4d0d      	ldr	r5, [pc, #52]	; (800254c <xTimerGenericCommand+0x48>)
 8002518:	682e      	ldr	r6, [r5, #0]
        BaseType_t xReturn = pdFAIL;
 800251a:	1e30      	subs	r0, r6, #0
        if( xTimerQueue != NULL )
 800251c:	d00f      	beq.n	800253e <xTimerGenericCommand+0x3a>
            xMessage.xMessageID = xCommandID;
 800251e:	9101      	str	r1, [sp, #4]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8002520:	9702      	str	r7, [sp, #8]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 8002522:	9403      	str	r4, [sp, #12]
            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8002524:	2905      	cmp	r1, #5
 8002526:	dc0c      	bgt.n	8002542 <xTimerGenericCommand+0x3e>
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002528:	f7ff fe86 	bl	8002238 <xTaskGetSchedulerState>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800252c:	2300      	movs	r3, #0
 800252e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002530:	2802      	cmp	r0, #2
 8002532:	d000      	beq.n	8002536 <xTimerGenericCommand+0x32>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8002534:	001a      	movs	r2, r3
 8002536:	6828      	ldr	r0, [r5, #0]
 8002538:	a901      	add	r1, sp, #4
 800253a:	f7ff f9c0 	bl	80018be <xQueueGenericSend>
    }
 800253e:	b005      	add	sp, #20
 8002540:	bdf0      	pop	{r4, r5, r6, r7, pc}
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8002542:	2300      	movs	r3, #0
 8002544:	a901      	add	r1, sp, #4
 8002546:	f7ff fa46 	bl	80019d6 <xQueueGenericSendFromISR>
 800254a:	e7f8      	b.n	800253e <xTimerGenericCommand+0x3a>
 800254c:	20000164 	.word	0x20000164

08002550 <prvSwitchTimerLists>:
    {
 8002550:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002552:	4d18      	ldr	r5, [pc, #96]	; (80025b4 <prvSwitchTimerLists+0x64>)
 8002554:	682b      	ldr	r3, [r5, #0]
 8002556:	681a      	ldr	r2, [r3, #0]
 8002558:	2a00      	cmp	r2, #0
 800255a:	d104      	bne.n	8002566 <prvSwitchTimerLists+0x16>
        pxCurrentTimerList = pxOverflowTimerList;
 800255c:	4a16      	ldr	r2, [pc, #88]	; (80025b8 <prvSwitchTimerLists+0x68>)
 800255e:	6811      	ldr	r1, [r2, #0]
        pxOverflowTimerList = pxTemp;
 8002560:	6013      	str	r3, [r2, #0]
        pxCurrentTimerList = pxOverflowTimerList;
 8002562:	6029      	str	r1, [r5, #0]
    }
 8002564:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002566:	68db      	ldr	r3, [r3, #12]
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002568:	68dc      	ldr	r4, [r3, #12]
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800256a:	681e      	ldr	r6, [r3, #0]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800256c:	1d27      	adds	r7, r4, #4
 800256e:	0038      	movs	r0, r7
 8002570:	f7ff f8ab 	bl	80016ca <uxListRemove>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002574:	6a23      	ldr	r3, [r4, #32]
 8002576:	0020      	movs	r0, r4
 8002578:	4798      	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800257a:	0023      	movs	r3, r4
 800257c:	2204      	movs	r2, #4
 800257e:	3328      	adds	r3, #40	; 0x28
 8002580:	781b      	ldrb	r3, [r3, #0]
 8002582:	4213      	tst	r3, r2
 8002584:	d0e5      	beq.n	8002552 <prvSwitchTimerLists+0x2>
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8002586:	69a3      	ldr	r3, [r4, #24]
 8002588:	18f3      	adds	r3, r6, r3
                if( xReloadTime > xNextExpireTime )
 800258a:	429e      	cmp	r6, r3
 800258c:	d206      	bcs.n	800259c <prvSwitchTimerLists+0x4c>
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800258e:	0039      	movs	r1, r7
 8002590:	6828      	ldr	r0, [r5, #0]
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8002592:	6063      	str	r3, [r4, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002594:	6124      	str	r4, [r4, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002596:	f7ff f881 	bl	800169c <vListInsert>
 800259a:	e7da      	b.n	8002552 <prvSwitchTimerLists+0x2>
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800259c:	2100      	movs	r1, #0
 800259e:	0032      	movs	r2, r6
 80025a0:	000b      	movs	r3, r1
 80025a2:	0020      	movs	r0, r4
 80025a4:	9100      	str	r1, [sp, #0]
 80025a6:	f7ff ffad 	bl	8002504 <xTimerGenericCommand>
                    configASSERT( xResult );
 80025aa:	2800      	cmp	r0, #0
 80025ac:	d1d1      	bne.n	8002552 <prvSwitchTimerLists+0x2>
 80025ae:	b672      	cpsid	i
 80025b0:	e7fe      	b.n	80025b0 <prvSwitchTimerLists+0x60>
 80025b2:	46c0      	nop			; (mov r8, r8)
 80025b4:	20000130 	.word	0x20000130
 80025b8:	20000134 	.word	0x20000134

080025bc <prvTimerTask>:
    {
 80025bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025be:	b089      	sub	sp, #36	; 0x24
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80025c0:	4f60      	ldr	r7, [pc, #384]	; (8002744 <prvTimerTask+0x188>)
 80025c2:	2601      	movs	r6, #1
 80025c4:	683b      	ldr	r3, [r7, #0]
 80025c6:	681c      	ldr	r4, [r3, #0]
 80025c8:	2c00      	cmp	r4, #0
 80025ca:	d002      	beq.n	80025d2 <prvTimerTask+0x16>
 80025cc:	2600      	movs	r6, #0
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80025ce:	68db      	ldr	r3, [r3, #12]
 80025d0:	681c      	ldr	r4, [r3, #0]
        vTaskSuspendAll();
 80025d2:	f7ff fc7f 	bl	8001ed4 <vTaskSuspendAll>
        xTimeNow = xTaskGetTickCount();
 80025d6:	f7ff fc85 	bl	8001ee4 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 80025da:	4b5b      	ldr	r3, [pc, #364]	; (8002748 <prvTimerTask+0x18c>)
        xTimeNow = xTaskGetTickCount();
 80025dc:	0005      	movs	r5, r0
        if( xTimeNow < xLastTime )
 80025de:	681b      	ldr	r3, [r3, #0]
 80025e0:	9303      	str	r3, [sp, #12]
 80025e2:	4298      	cmp	r0, r3
 80025e4:	d315      	bcc.n	8002612 <prvTimerTask+0x56>
        xLastTime = xTimeNow;
 80025e6:	4b58      	ldr	r3, [pc, #352]	; (8002748 <prvTimerTask+0x18c>)
 80025e8:	6018      	str	r0, [r3, #0]
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80025ea:	2e00      	cmp	r6, #0
 80025ec:	d019      	beq.n	8002622 <prvTimerTask+0x66>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80025ee:	4b57      	ldr	r3, [pc, #348]	; (800274c <prvTimerTask+0x190>)
 80025f0:	681b      	ldr	r3, [r3, #0]
 80025f2:	681e      	ldr	r6, [r3, #0]
 80025f4:	4273      	negs	r3, r6
 80025f6:	415e      	adcs	r6, r3
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 80025f8:	4b55      	ldr	r3, [pc, #340]	; (8002750 <prvTimerTask+0x194>)
 80025fa:	0032      	movs	r2, r6
 80025fc:	6818      	ldr	r0, [r3, #0]
 80025fe:	1b61      	subs	r1, r4, r5
 8002600:	f7ff faca 	bl	8001b98 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 8002604:	f7ff fcd6 	bl	8001fb4 <xTaskResumeAll>
 8002608:	2800      	cmp	r0, #0
 800260a:	d108      	bne.n	800261e <prvTimerTask+0x62>
                        portYIELD_WITHIN_API();
 800260c:	f000 f8e4 	bl	80027d8 <vPortYield>
 8002610:	e005      	b.n	800261e <prvTimerTask+0x62>
            prvSwitchTimerLists();
 8002612:	f7ff ff9d 	bl	8002550 <prvSwitchTimerLists>
        xLastTime = xTimeNow;
 8002616:	4b4c      	ldr	r3, [pc, #304]	; (8002748 <prvTimerTask+0x18c>)
 8002618:	601d      	str	r5, [r3, #0]
                ( void ) xTaskResumeAll();
 800261a:	f7ff fccb 	bl	8001fb4 <xTaskResumeAll>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800261e:	2702      	movs	r7, #2
 8002620:	e05a      	b.n	80026d8 <prvTimerTask+0x11c>
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8002622:	4284      	cmp	r4, r0
 8002624:	d8e8      	bhi.n	80025f8 <prvTimerTask+0x3c>
                    ( void ) xTaskResumeAll();
 8002626:	f7ff fcc5 	bl	8001fb4 <xTaskResumeAll>
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800262a:	683b      	ldr	r3, [r7, #0]
 800262c:	68db      	ldr	r3, [r3, #12]
 800262e:	68df      	ldr	r7, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002630:	1d38      	adds	r0, r7, #4
 8002632:	f7ff f84a 	bl	80016ca <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8002636:	003a      	movs	r2, r7
 8002638:	2104      	movs	r1, #4
 800263a:	3228      	adds	r2, #40	; 0x28
 800263c:	7813      	ldrb	r3, [r2, #0]
 800263e:	420b      	tst	r3, r1
 8002640:	d013      	beq.n	800266a <prvTimerTask+0xae>
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8002642:	69bb      	ldr	r3, [r7, #24]
 8002644:	002a      	movs	r2, r5
 8002646:	18e1      	adds	r1, r4, r3
 8002648:	0038      	movs	r0, r7
 800264a:	0023      	movs	r3, r4
 800264c:	f7ff ff1e 	bl	800248c <prvInsertTimerInActiveList>
 8002650:	2800      	cmp	r0, #0
 8002652:	d00d      	beq.n	8002670 <prvTimerTask+0xb4>
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002654:	0033      	movs	r3, r6
 8002656:	0022      	movs	r2, r4
 8002658:	0031      	movs	r1, r6
 800265a:	0038      	movs	r0, r7
 800265c:	9600      	str	r6, [sp, #0]
 800265e:	f7ff ff51 	bl	8002504 <xTimerGenericCommand>
                configASSERT( xResult );
 8002662:	2800      	cmp	r0, #0
 8002664:	d104      	bne.n	8002670 <prvTimerTask+0xb4>
 8002666:	b672      	cpsid	i
 8002668:	e7fe      	b.n	8002668 <prvTimerTask+0xac>
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800266a:	2101      	movs	r1, #1
 800266c:	438b      	bics	r3, r1
 800266e:	7013      	strb	r3, [r2, #0]
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002670:	0038      	movs	r0, r7
 8002672:	6a3b      	ldr	r3, [r7, #32]
 8002674:	4798      	blx	r3
    }
 8002676:	e7d2      	b.n	800261e <prvTimerTask+0x62>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8002678:	2201      	movs	r2, #1
 800267a:	4313      	orrs	r3, r2
 800267c:	702b      	strb	r3, [r5, #0]
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800267e:	69a2      	ldr	r2, [r4, #24]
 8002680:	9b06      	ldr	r3, [sp, #24]
 8002682:	0020      	movs	r0, r4
 8002684:	1899      	adds	r1, r3, r2
 8002686:	0032      	movs	r2, r6
 8002688:	9303      	str	r3, [sp, #12]
 800268a:	f7ff feff 	bl	800248c <prvInsertTimerInActiveList>
 800268e:	2800      	cmp	r0, #0
 8002690:	d022      	beq.n	80026d8 <prvTimerTask+0x11c>
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002692:	6a23      	ldr	r3, [r4, #32]
 8002694:	0020      	movs	r0, r4
 8002696:	4798      	blx	r3
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8002698:	2204      	movs	r2, #4
 800269a:	782b      	ldrb	r3, [r5, #0]
 800269c:	4213      	tst	r3, r2
 800269e:	d01b      	beq.n	80026d8 <prvTimerTask+0x11c>
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80026a0:	2100      	movs	r1, #0
 80026a2:	69a3      	ldr	r3, [r4, #24]
 80026a4:	9a06      	ldr	r2, [sp, #24]
 80026a6:	0020      	movs	r0, r4
 80026a8:	18d2      	adds	r2, r2, r3
 80026aa:	9100      	str	r1, [sp, #0]
 80026ac:	000b      	movs	r3, r1
 80026ae:	f7ff ff29 	bl	8002504 <xTimerGenericCommand>
                                configASSERT( xResult );
 80026b2:	2800      	cmp	r0, #0
 80026b4:	d110      	bne.n	80026d8 <prvTimerTask+0x11c>
 80026b6:	b672      	cpsid	i
 80026b8:	e7fe      	b.n	80026b8 <prvTimerTask+0xfc>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80026ba:	2201      	movs	r2, #1
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80026bc:	9906      	ldr	r1, [sp, #24]
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80026be:	4313      	orrs	r3, r2
 80026c0:	702b      	strb	r3, [r5, #0]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80026c2:	61a1      	str	r1, [r4, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80026c4:	2900      	cmp	r1, #0
 80026c6:	d101      	bne.n	80026cc <prvTimerTask+0x110>
 80026c8:	b672      	cpsid	i
 80026ca:	e7fe      	b.n	80026ca <prvTimerTask+0x10e>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80026cc:	0033      	movs	r3, r6
 80026ce:	0032      	movs	r2, r6
 80026d0:	0020      	movs	r0, r4
 80026d2:	1989      	adds	r1, r1, r6
 80026d4:	f7ff feda 	bl	800248c <prvInsertTimerInActiveList>
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80026d8:	4b1d      	ldr	r3, [pc, #116]	; (8002750 <prvTimerTask+0x194>)
 80026da:	2200      	movs	r2, #0
 80026dc:	6818      	ldr	r0, [r3, #0]
 80026de:	a905      	add	r1, sp, #20
 80026e0:	f7ff f9c7 	bl	8001a72 <xQueueReceive>
 80026e4:	2800      	cmp	r0, #0
 80026e6:	d100      	bne.n	80026ea <prvTimerTask+0x12e>
 80026e8:	e76a      	b.n	80025c0 <prvTimerTask+0x4>
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 80026ea:	9b05      	ldr	r3, [sp, #20]
 80026ec:	2b00      	cmp	r3, #0
 80026ee:	dbf3      	blt.n	80026d8 <prvTimerTask+0x11c>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 80026f0:	9c07      	ldr	r4, [sp, #28]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 80026f2:	6963      	ldr	r3, [r4, #20]
 80026f4:	2b00      	cmp	r3, #0
 80026f6:	d002      	beq.n	80026fe <prvTimerTask+0x142>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80026f8:	1d20      	adds	r0, r4, #4
 80026fa:	f7fe ffe6 	bl	80016ca <uxListRemove>
        xTimeNow = xTaskGetTickCount();
 80026fe:	f7ff fbf1 	bl	8001ee4 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 8002702:	4b11      	ldr	r3, [pc, #68]	; (8002748 <prvTimerTask+0x18c>)
        xTimeNow = xTaskGetTickCount();
 8002704:	0006      	movs	r6, r0
        if( xTimeNow < xLastTime )
 8002706:	681b      	ldr	r3, [r3, #0]
 8002708:	9303      	str	r3, [sp, #12]
 800270a:	4298      	cmp	r0, r3
 800270c:	d201      	bcs.n	8002712 <prvTimerTask+0x156>
            prvSwitchTimerLists();
 800270e:	f7ff ff1f 	bl	8002550 <prvSwitchTimerLists>
        xLastTime = xTimeNow;
 8002712:	4b0d      	ldr	r3, [pc, #52]	; (8002748 <prvTimerTask+0x18c>)
 8002714:	9805      	ldr	r0, [sp, #20]
 8002716:	601e      	str	r6, [r3, #0]
                switch( xMessage.xMessageID )
 8002718:	2809      	cmp	r0, #9
 800271a:	d8dd      	bhi.n	80026d8 <prvTimerTask+0x11c>
 800271c:	0025      	movs	r5, r4
 800271e:	3528      	adds	r5, #40	; 0x28
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8002720:	782b      	ldrb	r3, [r5, #0]
 8002722:	f7fd fcf1 	bl	8000108 <__gnu_thumb1_case_sqi>
 8002726:	a9a9      	.short	0xa9a9
 8002728:	05ca0ba9 	.word	0x05ca0ba9
 800272c:	ca0ba9a9 	.word	0xca0ba9a9
 8002730:	423b      	tst	r3, r7
 8002732:	d103      	bne.n	800273c <prvTimerTask+0x180>
                                    vPortFree( pxTimer );
 8002734:	0020      	movs	r0, r4
 8002736:	f000 f99d 	bl	8002a74 <vPortFree>
 800273a:	e7cd      	b.n	80026d8 <prvTimerTask+0x11c>
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800273c:	2201      	movs	r2, #1
 800273e:	4393      	bics	r3, r2
 8002740:	702b      	strb	r3, [r5, #0]
 8002742:	e7c9      	b.n	80026d8 <prvTimerTask+0x11c>
 8002744:	20000130 	.word	0x20000130
 8002748:	20000160 	.word	0x20000160
 800274c:	20000134 	.word	0x20000134
 8002750:	20000164 	.word	0x20000164

08002754 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    volatile uint32_t ulDummy = 0UL;
 8002754:	2300      	movs	r3, #0
{
 8002756:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0UL;
 8002758:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 800275a:	4b06      	ldr	r3, [pc, #24]	; (8002774 <prvTaskExitError+0x20>)
 800275c:	681b      	ldr	r3, [r3, #0]
 800275e:	3301      	adds	r3, #1
 8002760:	d001      	beq.n	8002766 <prvTaskExitError+0x12>
 8002762:	b672      	cpsid	i
 8002764:	e7fe      	b.n	8002764 <prvTaskExitError+0x10>
    portDISABLE_INTERRUPTS();
 8002766:	b672      	cpsid	i

    while( ulDummy == 0 )
 8002768:	9b01      	ldr	r3, [sp, #4]
 800276a:	2b00      	cmp	r3, #0
 800276c:	d0fc      	beq.n	8002768 <prvTaskExitError+0x14>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 800276e:	b002      	add	sp, #8
 8002770:	4770      	bx	lr
 8002772:	46c0      	nop			; (mov r8, r8)
 8002774:	2000000c 	.word	0x2000000c
	...

08002780 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
 8002780:	4a0b      	ldr	r2, [pc, #44]	; (80027b0 <pxCurrentTCBConst2>)
 8002782:	6813      	ldr	r3, [r2, #0]
 8002784:	6818      	ldr	r0, [r3, #0]
 8002786:	3020      	adds	r0, #32
 8002788:	f380 8809 	msr	PSP, r0
 800278c:	2002      	movs	r0, #2
 800278e:	f380 8814 	msr	CONTROL, r0
 8002792:	f3bf 8f6f 	isb	sy
 8002796:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 8002798:	46ae      	mov	lr, r5
 800279a:	bc08      	pop	{r3}
 800279c:	bc04      	pop	{r2}
 800279e:	b662      	cpsie	i
 80027a0:	4718      	bx	r3
 80027a2:	46c0      	nop			; (mov r8, r8)
 80027a4:	46c0      	nop			; (mov r8, r8)
 80027a6:	46c0      	nop			; (mov r8, r8)
 80027a8:	46c0      	nop			; (mov r8, r8)
 80027aa:	46c0      	nop			; (mov r8, r8)
 80027ac:	46c0      	nop			; (mov r8, r8)
 80027ae:	46c0      	nop			; (mov r8, r8)

080027b0 <pxCurrentTCBConst2>:
 80027b0:	2000002c 	.word	0x2000002c

080027b4 <pxPortInitialiseStack>:
{
 80027b4:	b510      	push	{r4, lr}
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
 80027b6:	2480      	movs	r4, #128	; 0x80
 80027b8:	1f03      	subs	r3, r0, #4
 80027ba:	0464      	lsls	r4, r4, #17
 80027bc:	601c      	str	r4, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
 80027be:	3b04      	subs	r3, #4
 80027c0:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
 80027c2:	4903      	ldr	r1, [pc, #12]	; (80027d0 <pxPortInitialiseStack+0x1c>)
 80027c4:	3b04      	subs	r3, #4
 80027c6:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 80027c8:	3b14      	subs	r3, #20
    pxTopOfStack -= 8;                                       /* R11..R4. */
 80027ca:	3840      	subs	r0, #64	; 0x40
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 80027cc:	601a      	str	r2, [r3, #0]
}
 80027ce:	bd10      	pop	{r4, pc}
 80027d0:	08002755 	.word	0x08002755

080027d4 <SVC_Handler>:
}
 80027d4:	4770      	bx	lr
	...

080027d8 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80027d8:	2280      	movs	r2, #128	; 0x80
 80027da:	4b04      	ldr	r3, [pc, #16]	; (80027ec <vPortYield+0x14>)
 80027dc:	0552      	lsls	r2, r2, #21
 80027de:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
 80027e0:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 80027e4:	f3bf 8f6f 	isb	sy
}
 80027e8:	4770      	bx	lr
 80027ea:	46c0      	nop			; (mov r8, r8)
 80027ec:	e000ed04 	.word	0xe000ed04

080027f0 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 80027f0:	b672      	cpsid	i
    uxCriticalNesting++;
 80027f2:	4a04      	ldr	r2, [pc, #16]	; (8002804 <vPortEnterCritical+0x14>)
 80027f4:	6813      	ldr	r3, [r2, #0]
 80027f6:	3301      	adds	r3, #1
 80027f8:	6013      	str	r3, [r2, #0]
    __asm volatile ( "dsb" ::: "memory" );
 80027fa:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 80027fe:	f3bf 8f6f 	isb	sy
}
 8002802:	4770      	bx	lr
 8002804:	2000000c 	.word	0x2000000c

08002808 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
 8002808:	4a05      	ldr	r2, [pc, #20]	; (8002820 <vPortExitCritical+0x18>)
 800280a:	6813      	ldr	r3, [r2, #0]
 800280c:	2b00      	cmp	r3, #0
 800280e:	d101      	bne.n	8002814 <vPortExitCritical+0xc>
 8002810:	b672      	cpsid	i
 8002812:	e7fe      	b.n	8002812 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 8002814:	3b01      	subs	r3, #1
 8002816:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
 8002818:	2b00      	cmp	r3, #0
 800281a:	d100      	bne.n	800281e <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800281c:	b662      	cpsie	i
    }
}
 800281e:	4770      	bx	lr
 8002820:	2000000c 	.word	0x2000000c

08002824 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
 8002824:	f3ef 8010 	mrs	r0, PRIMASK
 8002828:	b672      	cpsid	i
 800282a:	4770      	bx	lr

0800282c <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
 800282c:	f380 8810 	msr	PRIMASK, r0
 8002830:	4770      	bx	lr
	...

08002840 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
 8002840:	f3ef 8009 	mrs	r0, PSP
 8002844:	4b0e      	ldr	r3, [pc, #56]	; (8002880 <pxCurrentTCBConst>)
 8002846:	681a      	ldr	r2, [r3, #0]
 8002848:	3820      	subs	r0, #32
 800284a:	6010      	str	r0, [r2, #0]
 800284c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800284e:	4644      	mov	r4, r8
 8002850:	464d      	mov	r5, r9
 8002852:	4656      	mov	r6, sl
 8002854:	465f      	mov	r7, fp
 8002856:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8002858:	b508      	push	{r3, lr}
 800285a:	b672      	cpsid	i
 800285c:	f7ff fc0c 	bl	8002078 <vTaskSwitchContext>
 8002860:	b662      	cpsie	i
 8002862:	bc0c      	pop	{r2, r3}
 8002864:	6811      	ldr	r1, [r2, #0]
 8002866:	6808      	ldr	r0, [r1, #0]
 8002868:	3010      	adds	r0, #16
 800286a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800286c:	46a0      	mov	r8, r4
 800286e:	46a9      	mov	r9, r5
 8002870:	46b2      	mov	sl, r6
 8002872:	46bb      	mov	fp, r7
 8002874:	f380 8809 	msr	PSP, r0
 8002878:	3820      	subs	r0, #32
 800287a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800287c:	4718      	bx	r3
 800287e:	46c0      	nop			; (mov r8, r8)

08002880 <pxCurrentTCBConst>:
 8002880:	2000002c 	.word	0x2000002c

08002884 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8002884:	b510      	push	{r4, lr}
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 8002886:	f7ff ffcd 	bl	8002824 <ulSetInterruptMaskFromISR>
 800288a:	0004      	movs	r4, r0
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
 800288c:	f7ff fb30 	bl	8001ef0 <xTaskIncrementTick>
 8002890:	2800      	cmp	r0, #0
 8002892:	d003      	beq.n	800289c <SysTick_Handler+0x18>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002894:	2280      	movs	r2, #128	; 0x80
 8002896:	4b03      	ldr	r3, [pc, #12]	; (80028a4 <SysTick_Handler+0x20>)
 8002898:	0552      	lsls	r2, r2, #21
 800289a:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800289c:	0020      	movs	r0, r4
 800289e:	f7ff ffc5 	bl	800282c <vClearInterruptMaskFromISR>
}
 80028a2:	bd10      	pop	{r4, pc}
 80028a4:	e000ed04 	.word	0xe000ed04

080028a8 <vPortSetupTimerInterrupt>:
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 80028a8:	2300      	movs	r3, #0
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80028aa:	21fa      	movs	r1, #250	; 0xfa
{
 80028ac:	b510      	push	{r4, lr}
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80028ae:	4a07      	ldr	r2, [pc, #28]	; (80028cc <vPortSetupTimerInterrupt+0x24>)
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 80028b0:	4c07      	ldr	r4, [pc, #28]	; (80028d0 <vPortSetupTimerInterrupt+0x28>)
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80028b2:	0089      	lsls	r1, r1, #2
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 80028b4:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 80028b6:	6013      	str	r3, [r2, #0]
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80028b8:	4b06      	ldr	r3, [pc, #24]	; (80028d4 <vPortSetupTimerInterrupt+0x2c>)
 80028ba:	6818      	ldr	r0, [r3, #0]
 80028bc:	f7fd fc38 	bl	8000130 <__udivsi3>
 80028c0:	4b05      	ldr	r3, [pc, #20]	; (80028d8 <vPortSetupTimerInterrupt+0x30>)
 80028c2:	3801      	subs	r0, #1
 80028c4:	6018      	str	r0, [r3, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 80028c6:	2307      	movs	r3, #7
 80028c8:	6023      	str	r3, [r4, #0]
}
 80028ca:	bd10      	pop	{r4, pc}
 80028cc:	e000e018 	.word	0xe000e018
 80028d0:	e000e010 	.word	0xe000e010
 80028d4:	20000000 	.word	0x20000000
 80028d8:	e000e014 	.word	0xe000e014

080028dc <xPortStartScheduler>:
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 80028dc:	22ff      	movs	r2, #255	; 0xff
 80028de:	4b0c      	ldr	r3, [pc, #48]	; (8002910 <xPortStartScheduler+0x34>)
 80028e0:	0412      	lsls	r2, r2, #16
 80028e2:	6819      	ldr	r1, [r3, #0]
{
 80028e4:	b510      	push	{r4, lr}
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 80028e6:	430a      	orrs	r2, r1
 80028e8:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 80028ea:	22ff      	movs	r2, #255	; 0xff
    uxCriticalNesting = 0;
 80028ec:	2400      	movs	r4, #0
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 80028ee:	6819      	ldr	r1, [r3, #0]
 80028f0:	0612      	lsls	r2, r2, #24
 80028f2:	430a      	orrs	r2, r1
 80028f4:	601a      	str	r2, [r3, #0]
    vPortSetupTimerInterrupt();
 80028f6:	f7ff ffd7 	bl	80028a8 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 80028fa:	4b06      	ldr	r3, [pc, #24]	; (8002914 <xPortStartScheduler+0x38>)
 80028fc:	601c      	str	r4, [r3, #0]
    vPortStartFirstTask();
 80028fe:	f7ff ff3f 	bl	8002780 <vPortStartFirstTask>
    vTaskSwitchContext();
 8002902:	f7ff fbb9 	bl	8002078 <vTaskSwitchContext>
    prvTaskExitError();
 8002906:	f7ff ff25 	bl	8002754 <prvTaskExitError>
}
 800290a:	0020      	movs	r0, r4
 800290c:	bd10      	pop	{r4, pc}
 800290e:	46c0      	nop			; (mov r8, r8)
 8002910:	e000ed20 	.word	0xe000ed20
 8002914:	2000000c 	.word	0x2000000c

08002918 <prvInsertBlockIntoFreeList>:
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
 8002918:	b510      	push	{r4, lr}
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800291a:	4b0f      	ldr	r3, [pc, #60]	; (8002958 <prvInsertBlockIntoFreeList+0x40>)
 800291c:	001a      	movs	r2, r3
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	4283      	cmp	r3, r0
 8002922:	d3fb      	bcc.n	800291c <prvInsertBlockIntoFreeList+0x4>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8002924:	6854      	ldr	r4, [r2, #4]
 8002926:	1911      	adds	r1, r2, r4
 8002928:	4288      	cmp	r0, r1
 800292a:	d103      	bne.n	8002934 <prvInsertBlockIntoFreeList+0x1c>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800292c:	6841      	ldr	r1, [r0, #4]
 800292e:	0010      	movs	r0, r2
 8002930:	1909      	adds	r1, r1, r4
 8002932:	6051      	str	r1, [r2, #4]

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8002934:	6841      	ldr	r1, [r0, #4]
 8002936:	1844      	adds	r4, r0, r1
 8002938:	42a3      	cmp	r3, r4
 800293a:	d107      	bne.n	800294c <prvInsertBlockIntoFreeList+0x34>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
 800293c:	4c07      	ldr	r4, [pc, #28]	; (800295c <prvInsertBlockIntoFreeList+0x44>)
 800293e:	6824      	ldr	r4, [r4, #0]
 8002940:	42a3      	cmp	r3, r4
 8002942:	d003      	beq.n	800294c <prvInsertBlockIntoFreeList+0x34>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8002944:	685c      	ldr	r4, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8002946:	681b      	ldr	r3, [r3, #0]
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8002948:	1861      	adds	r1, r4, r1
 800294a:	6041      	str	r1, [r0, #4]
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800294c:	6003      	str	r3, [r0, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 800294e:	4290      	cmp	r0, r2
 8002950:	d000      	beq.n	8002954 <prvInsertBlockIntoFreeList+0x3c>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8002952:	6010      	str	r0, [r2, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 8002954:	bd10      	pop	{r4, pc}
 8002956:	46c0      	nop			; (mov r8, r8)
 8002958:	20000760 	.word	0x20000760
 800295c:	2000016c 	.word	0x2000016c

08002960 <pvPortMalloc>:
{
 8002960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002962:	0004      	movs	r4, r0
    vTaskSuspendAll();
 8002964:	f7ff fab6 	bl	8001ed4 <vTaskSuspendAll>
        if( pxEnd == NULL )
 8002968:	4a3a      	ldr	r2, [pc, #232]	; (8002a54 <pvPortMalloc+0xf4>)
 800296a:	4d3b      	ldr	r5, [pc, #236]	; (8002a58 <pvPortMalloc+0xf8>)
 800296c:	6813      	ldr	r3, [r2, #0]
 800296e:	2b00      	cmp	r3, #0
 8002970:	d11b      	bne.n	80029aa <pvPortMalloc+0x4a>
    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8002972:	2007      	movs	r0, #7
    uxAddress = ( size_t ) ucHeap;
 8002974:	4b39      	ldr	r3, [pc, #228]	; (8002a5c <pvPortMalloc+0xfc>)
    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8002976:	0019      	movs	r1, r3
 8002978:	4203      	tst	r3, r0
 800297a:	d001      	beq.n	8002980 <pvPortMalloc+0x20>
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800297c:	1819      	adds	r1, r3, r0
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800297e:	4381      	bics	r1, r0
    xStart.xBlockSize = ( size_t ) 0;
 8002980:	2000      	movs	r0, #0
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002982:	4e37      	ldr	r6, [pc, #220]	; (8002a60 <pvPortMalloc+0x100>)
    xStart.xBlockSize = ( size_t ) 0;
 8002984:	6070      	str	r0, [r6, #4]
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002986:	6031      	str	r1, [r6, #0]
    uxAddress -= xHeapStructSize;
 8002988:	4e36      	ldr	r6, [pc, #216]	; (8002a64 <pvPortMalloc+0x104>)
 800298a:	199b      	adds	r3, r3, r6
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800298c:	2607      	movs	r6, #7
 800298e:	43b3      	bics	r3, r6
    pxEnd->pxNextFreeBlock = NULL;
 8002990:	6018      	str	r0, [r3, #0]
    pxEnd->xBlockSize = 0;
 8002992:	6058      	str	r0, [r3, #4]
    pxEnd = ( void * ) uxAddress;
 8002994:	6013      	str	r3, [r2, #0]
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8002996:	1a58      	subs	r0, r3, r1
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8002998:	600b      	str	r3, [r1, #0]
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800299a:	4b33      	ldr	r3, [pc, #204]	; (8002a68 <pvPortMalloc+0x108>)
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800299c:	6048      	str	r0, [r1, #4]
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800299e:	6018      	str	r0, [r3, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80029a0:	4b32      	ldr	r3, [pc, #200]	; (8002a6c <pvPortMalloc+0x10c>)
 80029a2:	6018      	str	r0, [r3, #0]
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80029a4:	2380      	movs	r3, #128	; 0x80
 80029a6:	061b      	lsls	r3, r3, #24
 80029a8:	602b      	str	r3, [r5, #0]
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80029aa:	682e      	ldr	r6, [r5, #0]
 80029ac:	0025      	movs	r5, r4
 80029ae:	4035      	ands	r5, r6
 80029b0:	4234      	tst	r4, r6
 80029b2:	d14b      	bne.n	8002a4c <pvPortMalloc+0xec>
            if( ( xWantedSize > 0 ) && 
 80029b4:	1e63      	subs	r3, r4, #1
 80029b6:	330a      	adds	r3, #10
 80029b8:	d80a      	bhi.n	80029d0 <pvPortMalloc+0x70>
                xWantedSize += xHeapStructSize;
 80029ba:	0023      	movs	r3, r4
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80029bc:	2107      	movs	r1, #7
                xWantedSize += xHeapStructSize;
 80029be:	3308      	adds	r3, #8
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80029c0:	420b      	tst	r3, r1
 80029c2:	d03f      	beq.n	8002a44 <pvPortMalloc+0xe4>
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
 80029c4:	0018      	movs	r0, r3
 80029c6:	4388      	bics	r0, r1
 80029c8:	0001      	movs	r1, r0
 80029ca:	3108      	adds	r1, #8
 80029cc:	4299      	cmp	r1, r3
 80029ce:	d838      	bhi.n	8002a42 <pvPortMalloc+0xe2>
    ( void ) xTaskResumeAll();
 80029d0:	f7ff faf0 	bl	8001fb4 <xTaskResumeAll>
    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80029d4:	076b      	lsls	r3, r5, #29
 80029d6:	d03b      	beq.n	8002a50 <pvPortMalloc+0xf0>
 80029d8:	b672      	cpsid	i
 80029da:	e7fe      	b.n	80029da <pvPortMalloc+0x7a>
                pxBlock = xStart.pxNextFreeBlock;
 80029dc:	4920      	ldr	r1, [pc, #128]	; (8002a60 <pvPortMalloc+0x100>)
 80029de:	680c      	ldr	r4, [r1, #0]
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80029e0:	6860      	ldr	r0, [r4, #4]
 80029e2:	4298      	cmp	r0, r3
 80029e4:	d203      	bcs.n	80029ee <pvPortMalloc+0x8e>
 80029e6:	6827      	ldr	r7, [r4, #0]
 80029e8:	46bc      	mov	ip, r7
 80029ea:	2f00      	cmp	r7, #0
 80029ec:	d10e      	bne.n	8002a0c <pvPortMalloc+0xac>
                if( pxBlock != pxEnd )
 80029ee:	6812      	ldr	r2, [r2, #0]
 80029f0:	42a2      	cmp	r2, r4
 80029f2:	d02b      	beq.n	8002a4c <pvPortMalloc+0xec>
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80029f4:	680a      	ldr	r2, [r1, #0]
 80029f6:	0017      	movs	r7, r2
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80029f8:	6822      	ldr	r2, [r4, #0]
 80029fa:	600a      	str	r2, [r1, #0]
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80029fc:	1ac2      	subs	r2, r0, r3
 80029fe:	2a10      	cmp	r2, #16
 8002a00:	d90b      	bls.n	8002a1a <pvPortMalloc+0xba>
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8002a02:	18e0      	adds	r0, r4, r3
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8002a04:	0741      	lsls	r1, r0, #29
 8002a06:	d004      	beq.n	8002a12 <pvPortMalloc+0xb2>
 8002a08:	b672      	cpsid	i
 8002a0a:	e7fe      	b.n	8002a0a <pvPortMalloc+0xaa>
 8002a0c:	0021      	movs	r1, r4
 8002a0e:	4664      	mov	r4, ip
 8002a10:	e7e6      	b.n	80029e0 <pvPortMalloc+0x80>
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8002a12:	6042      	str	r2, [r0, #4]
                        pxBlock->xBlockSize = xWantedSize;
 8002a14:	6063      	str	r3, [r4, #4]
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
 8002a16:	f7ff ff7f 	bl	8002918 <prvInsertBlockIntoFreeList>
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002a1a:	6863      	ldr	r3, [r4, #4]
 8002a1c:	4a13      	ldr	r2, [pc, #76]	; (8002a6c <pvPortMalloc+0x10c>)
 8002a1e:	1aed      	subs	r5, r5, r3
 8002a20:	6015      	str	r5, [r2, #0]
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002a22:	4a11      	ldr	r2, [pc, #68]	; (8002a68 <pvPortMalloc+0x108>)
 8002a24:	6811      	ldr	r1, [r2, #0]
 8002a26:	428d      	cmp	r5, r1
 8002a28:	d200      	bcs.n	8002a2c <pvPortMalloc+0xcc>
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8002a2a:	6015      	str	r5, [r2, #0]
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002a2c:	431e      	orrs	r6, r3
                    pxBlock->pxNextFreeBlock = NULL;
 8002a2e:	2300      	movs	r3, #0
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002a30:	003d      	movs	r5, r7
                    xNumberOfSuccessfulAllocations++;
 8002a32:	4a0f      	ldr	r2, [pc, #60]	; (8002a70 <pvPortMalloc+0x110>)
                    pxBlock->pxNextFreeBlock = NULL;
 8002a34:	6023      	str	r3, [r4, #0]
                    xNumberOfSuccessfulAllocations++;
 8002a36:	6813      	ldr	r3, [r2, #0]
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002a38:	3508      	adds	r5, #8
                    xNumberOfSuccessfulAllocations++;
 8002a3a:	3301      	adds	r3, #1
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002a3c:	6066      	str	r6, [r4, #4]
                    xNumberOfSuccessfulAllocations++;
 8002a3e:	6013      	str	r3, [r2, #0]
 8002a40:	e7c6      	b.n	80029d0 <pvPortMalloc+0x70>
 8002a42:	000b      	movs	r3, r1
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8002a44:	4909      	ldr	r1, [pc, #36]	; (8002a6c <pvPortMalloc+0x10c>)
 8002a46:	680d      	ldr	r5, [r1, #0]
 8002a48:	429d      	cmp	r5, r3
 8002a4a:	d2c7      	bcs.n	80029dc <pvPortMalloc+0x7c>
    void * pvReturn = NULL;
 8002a4c:	2500      	movs	r5, #0
 8002a4e:	e7bf      	b.n	80029d0 <pvPortMalloc+0x70>
}
 8002a50:	0028      	movs	r0, r5
 8002a52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a54:	2000016c 	.word	0x2000016c
 8002a58:	2000074c 	.word	0x2000074c
 8002a5c:	20000170 	.word	0x20000170
 8002a60:	20000760 	.word	0x20000760
 8002a64:	000005d4 	.word	0x000005d4
 8002a68:	20000754 	.word	0x20000754
 8002a6c:	20000750 	.word	0x20000750
 8002a70:	20000758 	.word	0x20000758

08002a74 <vPortFree>:
{
 8002a74:	b510      	push	{r4, lr}
    if( pv != NULL )
 8002a76:	2800      	cmp	r0, #0
 8002a78:	d01f      	beq.n	8002aba <vPortFree+0x46>
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8002a7a:	4a10      	ldr	r2, [pc, #64]	; (8002abc <vPortFree+0x48>)
 8002a7c:	3808      	subs	r0, #8
 8002a7e:	6843      	ldr	r3, [r0, #4]
 8002a80:	6812      	ldr	r2, [r2, #0]
 8002a82:	0004      	movs	r4, r0
 8002a84:	421a      	tst	r2, r3
 8002a86:	d101      	bne.n	8002a8c <vPortFree+0x18>
 8002a88:	b672      	cpsid	i
 8002a8a:	e7fe      	b.n	8002a8a <vPortFree+0x16>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 8002a8c:	6801      	ldr	r1, [r0, #0]
 8002a8e:	2900      	cmp	r1, #0
 8002a90:	d001      	beq.n	8002a96 <vPortFree+0x22>
 8002a92:	b672      	cpsid	i
 8002a94:	e7fe      	b.n	8002a94 <vPortFree+0x20>
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8002a96:	4393      	bics	r3, r2
 8002a98:	6043      	str	r3, [r0, #4]
                vTaskSuspendAll();
 8002a9a:	f7ff fa1b 	bl	8001ed4 <vTaskSuspendAll>
                    xFreeBytesRemaining += pxLink->xBlockSize;
 8002a9e:	4a08      	ldr	r2, [pc, #32]	; (8002ac0 <vPortFree+0x4c>)
 8002aa0:	6863      	ldr	r3, [r4, #4]
 8002aa2:	6811      	ldr	r1, [r2, #0]
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002aa4:	0020      	movs	r0, r4
                    xFreeBytesRemaining += pxLink->xBlockSize;
 8002aa6:	185b      	adds	r3, r3, r1
 8002aa8:	6013      	str	r3, [r2, #0]
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002aaa:	f7ff ff35 	bl	8002918 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
 8002aae:	4a05      	ldr	r2, [pc, #20]	; (8002ac4 <vPortFree+0x50>)
 8002ab0:	6813      	ldr	r3, [r2, #0]
 8002ab2:	3301      	adds	r3, #1
 8002ab4:	6013      	str	r3, [r2, #0]
                ( void ) xTaskResumeAll();
 8002ab6:	f7ff fa7d 	bl	8001fb4 <xTaskResumeAll>
}
 8002aba:	bd10      	pop	{r4, pc}
 8002abc:	2000074c 	.word	0x2000074c
 8002ac0:	20000750 	.word	0x20000750
 8002ac4:	2000075c 	.word	0x2000075c

08002ac8 <__libc_init_array>:
 8002ac8:	b570      	push	{r4, r5, r6, lr}
 8002aca:	2600      	movs	r6, #0
 8002acc:	4d0c      	ldr	r5, [pc, #48]	; (8002b00 <__libc_init_array+0x38>)
 8002ace:	4c0d      	ldr	r4, [pc, #52]	; (8002b04 <__libc_init_array+0x3c>)
 8002ad0:	1b64      	subs	r4, r4, r5
 8002ad2:	10a4      	asrs	r4, r4, #2
 8002ad4:	42a6      	cmp	r6, r4
 8002ad6:	d109      	bne.n	8002aec <__libc_init_array+0x24>
 8002ad8:	2600      	movs	r6, #0
 8002ada:	f000 f82b 	bl	8002b34 <_init>
 8002ade:	4d0a      	ldr	r5, [pc, #40]	; (8002b08 <__libc_init_array+0x40>)
 8002ae0:	4c0a      	ldr	r4, [pc, #40]	; (8002b0c <__libc_init_array+0x44>)
 8002ae2:	1b64      	subs	r4, r4, r5
 8002ae4:	10a4      	asrs	r4, r4, #2
 8002ae6:	42a6      	cmp	r6, r4
 8002ae8:	d105      	bne.n	8002af6 <__libc_init_array+0x2e>
 8002aea:	bd70      	pop	{r4, r5, r6, pc}
 8002aec:	00b3      	lsls	r3, r6, #2
 8002aee:	58eb      	ldr	r3, [r5, r3]
 8002af0:	4798      	blx	r3
 8002af2:	3601      	adds	r6, #1
 8002af4:	e7ee      	b.n	8002ad4 <__libc_init_array+0xc>
 8002af6:	00b3      	lsls	r3, r6, #2
 8002af8:	58eb      	ldr	r3, [r5, r3]
 8002afa:	4798      	blx	r3
 8002afc:	3601      	adds	r6, #1
 8002afe:	e7f2      	b.n	8002ae6 <__libc_init_array+0x1e>
 8002b00:	08002ba4 	.word	0x08002ba4
 8002b04:	08002ba4 	.word	0x08002ba4
 8002b08:	08002ba4 	.word	0x08002ba4
 8002b0c:	08002ba8 	.word	0x08002ba8

08002b10 <memcpy>:
 8002b10:	2300      	movs	r3, #0
 8002b12:	b510      	push	{r4, lr}
 8002b14:	429a      	cmp	r2, r3
 8002b16:	d100      	bne.n	8002b1a <memcpy+0xa>
 8002b18:	bd10      	pop	{r4, pc}
 8002b1a:	5ccc      	ldrb	r4, [r1, r3]
 8002b1c:	54c4      	strb	r4, [r0, r3]
 8002b1e:	3301      	adds	r3, #1
 8002b20:	e7f8      	b.n	8002b14 <memcpy+0x4>

08002b22 <memset>:
 8002b22:	0003      	movs	r3, r0
 8002b24:	1882      	adds	r2, r0, r2
 8002b26:	4293      	cmp	r3, r2
 8002b28:	d100      	bne.n	8002b2c <memset+0xa>
 8002b2a:	4770      	bx	lr
 8002b2c:	7019      	strb	r1, [r3, #0]
 8002b2e:	3301      	adds	r3, #1
 8002b30:	e7f9      	b.n	8002b26 <memset+0x4>
	...

08002b34 <_init>:
 8002b34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b36:	46c0      	nop			; (mov r8, r8)
 8002b38:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002b3a:	bc08      	pop	{r3}
 8002b3c:	469e      	mov	lr, r3
 8002b3e:	4770      	bx	lr

08002b40 <_fini>:
 8002b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b42:	46c0      	nop			; (mov r8, r8)
 8002b44:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002b46:	bc08      	pop	{r3}
 8002b48:	469e      	mov	lr, r3
 8002b4a:	4770      	bx	lr
