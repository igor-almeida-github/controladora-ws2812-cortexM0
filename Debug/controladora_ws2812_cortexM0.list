
controladora_ws2812_cortexM0.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000283c  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000058  080028fc  080028fc  000128fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08002954  08002954  00020010  2**0
                  CONTENTS
  4 .ARM          00000000  08002954  08002954  00020010  2**0
                  CONTENTS
  5 .preinit_array 00000000  08002954  08002954  00020010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08002954  08002954  00012954  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08002958  08002958  00012958  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20000000  0800295c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000890  20000010  0800296c  00020010  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200008a0  0800296c  000208a0  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001744c  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000360a  00000000  00000000  00037484  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0000ed12  00000000  00000000  0003aa8e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00000d98  00000000  00000000  000497a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 000016a0  00000000  00000000  0004a538  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00010da2  00000000  00000000  0004bbd8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00017972  00000000  00000000  0005c97a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00069256  00000000  00000000  000742ec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000053  00000000  00000000  000dd542  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00002998  00000000  00000000  000dd598  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000010 	.word	0x20000010
 80000e0:	00000000 	.word	0x00000000
 80000e4:	080028e4 	.word	0x080028e4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000014 	.word	0x20000014
 8000104:	080028e4 	.word	0x080028e4

08000108 <__gnu_thumb1_case_sqi>:
 8000108:	b402      	push	{r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0049      	lsls	r1, r1, #1
 8000110:	5609      	ldrsb	r1, [r1, r0]
 8000112:	0049      	lsls	r1, r1, #1
 8000114:	448e      	add	lr, r1
 8000116:	bc02      	pop	{r1}
 8000118:	4770      	bx	lr
 800011a:	46c0      	nop			; (mov r8, r8)

0800011c <__udivsi3>:
 800011c:	2200      	movs	r2, #0
 800011e:	0843      	lsrs	r3, r0, #1
 8000120:	428b      	cmp	r3, r1
 8000122:	d374      	bcc.n	800020e <__udivsi3+0xf2>
 8000124:	0903      	lsrs	r3, r0, #4
 8000126:	428b      	cmp	r3, r1
 8000128:	d35f      	bcc.n	80001ea <__udivsi3+0xce>
 800012a:	0a03      	lsrs	r3, r0, #8
 800012c:	428b      	cmp	r3, r1
 800012e:	d344      	bcc.n	80001ba <__udivsi3+0x9e>
 8000130:	0b03      	lsrs	r3, r0, #12
 8000132:	428b      	cmp	r3, r1
 8000134:	d328      	bcc.n	8000188 <__udivsi3+0x6c>
 8000136:	0c03      	lsrs	r3, r0, #16
 8000138:	428b      	cmp	r3, r1
 800013a:	d30d      	bcc.n	8000158 <__udivsi3+0x3c>
 800013c:	22ff      	movs	r2, #255	; 0xff
 800013e:	0209      	lsls	r1, r1, #8
 8000140:	ba12      	rev	r2, r2
 8000142:	0c03      	lsrs	r3, r0, #16
 8000144:	428b      	cmp	r3, r1
 8000146:	d302      	bcc.n	800014e <__udivsi3+0x32>
 8000148:	1212      	asrs	r2, r2, #8
 800014a:	0209      	lsls	r1, r1, #8
 800014c:	d065      	beq.n	800021a <__udivsi3+0xfe>
 800014e:	0b03      	lsrs	r3, r0, #12
 8000150:	428b      	cmp	r3, r1
 8000152:	d319      	bcc.n	8000188 <__udivsi3+0x6c>
 8000154:	e000      	b.n	8000158 <__udivsi3+0x3c>
 8000156:	0a09      	lsrs	r1, r1, #8
 8000158:	0bc3      	lsrs	r3, r0, #15
 800015a:	428b      	cmp	r3, r1
 800015c:	d301      	bcc.n	8000162 <__udivsi3+0x46>
 800015e:	03cb      	lsls	r3, r1, #15
 8000160:	1ac0      	subs	r0, r0, r3
 8000162:	4152      	adcs	r2, r2
 8000164:	0b83      	lsrs	r3, r0, #14
 8000166:	428b      	cmp	r3, r1
 8000168:	d301      	bcc.n	800016e <__udivsi3+0x52>
 800016a:	038b      	lsls	r3, r1, #14
 800016c:	1ac0      	subs	r0, r0, r3
 800016e:	4152      	adcs	r2, r2
 8000170:	0b43      	lsrs	r3, r0, #13
 8000172:	428b      	cmp	r3, r1
 8000174:	d301      	bcc.n	800017a <__udivsi3+0x5e>
 8000176:	034b      	lsls	r3, r1, #13
 8000178:	1ac0      	subs	r0, r0, r3
 800017a:	4152      	adcs	r2, r2
 800017c:	0b03      	lsrs	r3, r0, #12
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__udivsi3+0x6a>
 8000182:	030b      	lsls	r3, r1, #12
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0ac3      	lsrs	r3, r0, #11
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__udivsi3+0x76>
 800018e:	02cb      	lsls	r3, r1, #11
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0a83      	lsrs	r3, r0, #10
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__udivsi3+0x82>
 800019a:	028b      	lsls	r3, r1, #10
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0a43      	lsrs	r3, r0, #9
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__udivsi3+0x8e>
 80001a6:	024b      	lsls	r3, r1, #9
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0a03      	lsrs	r3, r0, #8
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__udivsi3+0x9a>
 80001b2:	020b      	lsls	r3, r1, #8
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	d2cd      	bcs.n	8000156 <__udivsi3+0x3a>
 80001ba:	09c3      	lsrs	r3, r0, #7
 80001bc:	428b      	cmp	r3, r1
 80001be:	d301      	bcc.n	80001c4 <__udivsi3+0xa8>
 80001c0:	01cb      	lsls	r3, r1, #7
 80001c2:	1ac0      	subs	r0, r0, r3
 80001c4:	4152      	adcs	r2, r2
 80001c6:	0983      	lsrs	r3, r0, #6
 80001c8:	428b      	cmp	r3, r1
 80001ca:	d301      	bcc.n	80001d0 <__udivsi3+0xb4>
 80001cc:	018b      	lsls	r3, r1, #6
 80001ce:	1ac0      	subs	r0, r0, r3
 80001d0:	4152      	adcs	r2, r2
 80001d2:	0943      	lsrs	r3, r0, #5
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d301      	bcc.n	80001dc <__udivsi3+0xc0>
 80001d8:	014b      	lsls	r3, r1, #5
 80001da:	1ac0      	subs	r0, r0, r3
 80001dc:	4152      	adcs	r2, r2
 80001de:	0903      	lsrs	r3, r0, #4
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__udivsi3+0xcc>
 80001e4:	010b      	lsls	r3, r1, #4
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	08c3      	lsrs	r3, r0, #3
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__udivsi3+0xd8>
 80001f0:	00cb      	lsls	r3, r1, #3
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0883      	lsrs	r3, r0, #2
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__udivsi3+0xe4>
 80001fc:	008b      	lsls	r3, r1, #2
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0843      	lsrs	r3, r0, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__udivsi3+0xf0>
 8000208:	004b      	lsls	r3, r1, #1
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	1a41      	subs	r1, r0, r1
 8000210:	d200      	bcs.n	8000214 <__udivsi3+0xf8>
 8000212:	4601      	mov	r1, r0
 8000214:	4152      	adcs	r2, r2
 8000216:	4610      	mov	r0, r2
 8000218:	4770      	bx	lr
 800021a:	e7ff      	b.n	800021c <__udivsi3+0x100>
 800021c:	b501      	push	{r0, lr}
 800021e:	2000      	movs	r0, #0
 8000220:	f000 f806 	bl	8000230 <__aeabi_idiv0>
 8000224:	bd02      	pop	{r1, pc}
 8000226:	46c0      	nop			; (mov r8, r8)

08000228 <__aeabi_uidivmod>:
 8000228:	2900      	cmp	r1, #0
 800022a:	d0f7      	beq.n	800021c <__udivsi3+0x100>
 800022c:	e776      	b.n	800011c <__udivsi3>
 800022e:	4770      	bx	lr

08000230 <__aeabi_idiv0>:
 8000230:	4770      	bx	lr
 8000232:	46c0      	nop			; (mov r8, r8)

08000234 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000234:	b570      	push	{r4, r5, r6, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000236:	2610      	movs	r6, #16
{
 8000238:	b090      	sub	sp, #64	; 0x40
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800023a:	221c      	movs	r2, #28
 800023c:	2100      	movs	r1, #0
 800023e:	a805      	add	r0, sp, #20
 8000240:	f002 fb47 	bl	80028d2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000244:	0032      	movs	r2, r6
 8000246:	2100      	movs	r1, #0
 8000248:	4668      	mov	r0, sp
 800024a:	f002 fb42 	bl	80028d2 <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 800024e:	2280      	movs	r2, #128	; 0x80
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000250:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000252:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000254:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 8000256:	0392      	lsls	r2, r2, #14
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000258:	a804      	add	r0, sp, #16
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 800025a:	9404      	str	r4, [sp, #16]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800025c:	9507      	str	r5, [sp, #28]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800025e:	9608      	str	r6, [sp, #32]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000260:	940c      	str	r4, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 8000262:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL10;
 8000264:	920e      	str	r2, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 8000266:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000268:	f000 fb30 	bl	80008cc <HAL_RCC_OscConfig>
 800026c:	2800      	cmp	r0, #0
 800026e:	d001      	beq.n	8000274 <SystemClock_Config+0x40>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000270:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000272:	e7fe      	b.n	8000272 <SystemClock_Config+0x3e>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000274:	2307      	movs	r3, #7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000276:	9002      	str	r0, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000278:	9003      	str	r0, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 800027a:	0029      	movs	r1, r5
 800027c:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800027e:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000280:	9401      	str	r4, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000282:	f000 fd55 	bl	8000d30 <HAL_RCC_ClockConfig>
 8000286:	2800      	cmp	r0, #0
 8000288:	d001      	beq.n	800028e <SystemClock_Config+0x5a>
 800028a:	b672      	cpsid	i
  while (1)
 800028c:	e7fe      	b.n	800028c <SystemClock_Config+0x58>
}
 800028e:	b010      	add	sp, #64	; 0x40
 8000290:	bd70      	pop	{r4, r5, r6, pc}
	...

08000294 <main>:
{
 8000294:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_Init();
 8000296:	f000 f951 	bl	800053c <HAL_Init>
  SystemClock_Config();
 800029a:	f7ff ffcb 	bl	8000234 <SystemClock_Config>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800029e:	2080      	movs	r0, #128	; 0x80
 80002a0:	4b23      	ldr	r3, [pc, #140]	; (8000330 <main+0x9c>)
 80002a2:	0280      	lsls	r0, r0, #10
 80002a4:	6959      	ldr	r1, [r3, #20]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 80002a6:	2402      	movs	r4, #2
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80002a8:	4301      	orrs	r1, r0
 80002aa:	6159      	str	r1, [r3, #20]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002ac:	2101      	movs	r1, #1
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80002ae:	695a      	ldr	r2, [r3, #20]
 80002b0:	4002      	ands	r2, r0
 80002b2:	9203      	str	r2, [sp, #12]
 80002b4:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002b6:	695a      	ldr	r2, [r3, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002b8:	200a      	movs	r0, #10
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002ba:	430a      	orrs	r2, r1
 80002bc:	615a      	str	r2, [r3, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002be:	2200      	movs	r2, #0
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002c0:	695b      	ldr	r3, [r3, #20]
 80002c2:	400b      	ands	r3, r1
 80002c4:	9302      	str	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002c6:	0011      	movs	r1, r2
  __HAL_RCC_DMA1_CLK_ENABLE();
 80002c8:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 80002ca:	f000 f959 	bl	8000580 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_3_IRQn);
 80002ce:	200a      	movs	r0, #10
 80002d0:	f000 f980 	bl	80005d4 <HAL_NVIC_EnableIRQ>
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002d4:	22e0      	movs	r2, #224	; 0xe0
  hspi1.Instance = SPI1;
 80002d6:	4817      	ldr	r0, [pc, #92]	; (8000334 <main+0xa0>)
 80002d8:	4b17      	ldr	r3, [pc, #92]	; (8000338 <main+0xa4>)
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002da:	00d2      	lsls	r2, r2, #3
  hspi1.Instance = SPI1;
 80002dc:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80002de:	2382      	movs	r3, #130	; 0x82
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 80002e0:	60c2      	str	r2, [r0, #12]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80002e2:	2280      	movs	r2, #128	; 0x80
  hspi1.Init.Mode = SPI_MODE_MASTER;
 80002e4:	005b      	lsls	r3, r3, #1
 80002e6:	6043      	str	r3, [r0, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80002e8:	2300      	movs	r3, #0
  hspi1.Init.NSS = SPI_NSS_SOFT;
 80002ea:	0092      	lsls	r2, r2, #2
 80002ec:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80002ee:	3ae9      	subs	r2, #233	; 0xe9
 80002f0:	3aff      	subs	r2, #255	; 0xff
 80002f2:	61c2      	str	r2, [r0, #28]
  hspi1.Init.CRCPolynomial = 7;
 80002f4:	3a11      	subs	r2, #17
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 80002f6:	6083      	str	r3, [r0, #8]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 80002f8:	6143      	str	r3, [r0, #20]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 80002fa:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 80002fc:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80002fe:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8000300:	6303      	str	r3, [r0, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
 8000302:	6343      	str	r3, [r0, #52]	; 0x34
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
 8000304:	6104      	str	r4, [r0, #16]
  hspi1.Init.CRCPolynomial = 7;
 8000306:	62c2      	str	r2, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000308:	f000 feae 	bl	8001068 <HAL_SPI_Init>
 800030c:	1e03      	subs	r3, r0, #0
 800030e:	d001      	beq.n	8000314 <main+0x80>
 8000310:	b672      	cpsid	i
  while (1)
 8000312:	e7fe      	b.n	8000312 <main+0x7e>
  status = xTaskCreate(&ws2812_task, "ws2812-task", 100, NULL, 2, &ws2812_task_handle);
 8000314:	4a09      	ldr	r2, [pc, #36]	; (800033c <main+0xa8>)
 8000316:	490a      	ldr	r1, [pc, #40]	; (8000340 <main+0xac>)
 8000318:	9201      	str	r2, [sp, #4]
 800031a:	480a      	ldr	r0, [pc, #40]	; (8000344 <main+0xb0>)
 800031c:	2264      	movs	r2, #100	; 0x64
 800031e:	9400      	str	r4, [sp, #0]
 8000320:	f001 fc60 	bl	8001be4 <xTaskCreate>
  if(status != pdPASS) while(1);  // Traps the code if the above function returns an unexpected status
 8000324:	2801      	cmp	r0, #1
 8000326:	d000      	beq.n	800032a <main+0x96>
 8000328:	e7fe      	b.n	8000328 <main+0x94>
  vTaskStartScheduler();
 800032a:	f001 fd31 	bl	8001d90 <vTaskStartScheduler>
  while (1)
 800032e:	e7fe      	b.n	800032e <main+0x9a>
 8000330:	40021000 	.word	0x40021000
 8000334:	2000076c 	.word	0x2000076c
 8000338:	40013000 	.word	0x40013000
 800033c:	20000768 	.word	0x20000768
 8000340:	080028fc 	.word	0x080028fc
 8000344:	080004cd 	.word	0x080004cd

08000348 <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM14) {
 8000348:	4b03      	ldr	r3, [pc, #12]	; (8000358 <HAL_TIM_PeriodElapsedCallback+0x10>)
 800034a:	6802      	ldr	r2, [r0, #0]
{
 800034c:	b510      	push	{r4, lr}
  if (htim->Instance == TIM14) {
 800034e:	429a      	cmp	r2, r3
 8000350:	d101      	bne.n	8000356 <HAL_TIM_PeriodElapsedCallback+0xe>
    HAL_IncTick();
 8000352:	f000 f903 	bl	800055c <HAL_IncTick>
}
 8000356:	bd10      	pop	{r4, pc}
 8000358:	40002000 	.word	0x40002000

0800035c <Error_Handler>:
 800035c:	b672      	cpsid	i
  while (1)
 800035e:	e7fe      	b.n	800035e <Error_Handler+0x2>

08000360 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000360:	2001      	movs	r0, #1
 8000362:	4b0a      	ldr	r3, [pc, #40]	; (800038c <HAL_MspInit+0x2c>)
{
 8000364:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000366:	6999      	ldr	r1, [r3, #24]
 8000368:	4301      	orrs	r1, r0
 800036a:	6199      	str	r1, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 800036c:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800036e:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000370:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000372:	4002      	ands	r2, r0
 8000374:	9200      	str	r2, [sp, #0]
 8000376:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000378:	69da      	ldr	r2, [r3, #28]
 800037a:	430a      	orrs	r2, r1
 800037c:	61da      	str	r2, [r3, #28]
 800037e:	69db      	ldr	r3, [r3, #28]
 8000380:	400b      	ands	r3, r1
 8000382:	9301      	str	r3, [sp, #4]
 8000384:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000386:	b002      	add	sp, #8
 8000388:	4770      	bx	lr
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	40021000 	.word	0x40021000

08000390 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8000390:	b570      	push	{r4, r5, r6, lr}
 8000392:	0006      	movs	r6, r0
 8000394:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000396:	2214      	movs	r2, #20
 8000398:	2100      	movs	r1, #0
 800039a:	a803      	add	r0, sp, #12
 800039c:	f002 fa99 	bl	80028d2 <memset>
  if(hspi->Instance==SPI1)
 80003a0:	4b1d      	ldr	r3, [pc, #116]	; (8000418 <HAL_SPI_MspInit+0x88>)
 80003a2:	6832      	ldr	r2, [r6, #0]
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d135      	bne.n	8000414 <HAL_SPI_MspInit+0x84>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003a8:	2080      	movs	r0, #128	; 0x80
 80003aa:	4b1c      	ldr	r3, [pc, #112]	; (800041c <HAL_SPI_MspInit+0x8c>)
 80003ac:	0140      	lsls	r0, r0, #5
 80003ae:	6999      	ldr	r1, [r3, #24]
    PA5     ------> SPI1_SCK
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003b0:	2500      	movs	r5, #0
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003b2:	4301      	orrs	r1, r0
 80003b4:	6199      	str	r1, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003b6:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003b8:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003ba:	0289      	lsls	r1, r1, #10
    __HAL_RCC_SPI1_CLK_ENABLE();
 80003bc:	4002      	ands	r2, r0
 80003be:	9201      	str	r2, [sp, #4]
 80003c0:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003c2:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80003c4:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003c6:	430a      	orrs	r2, r1
 80003c8:	615a      	str	r2, [r3, #20]
 80003ca:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80003cc:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80003ce:	400b      	ands	r3, r1
 80003d0:	9302      	str	r3, [sp, #8]
 80003d2:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 80003d4:	23a0      	movs	r3, #160	; 0xa0
 80003d6:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80003d8:	3b9e      	subs	r3, #158	; 0x9e
 80003da:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80003dc:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80003de:	3301      	adds	r3, #1
 80003e0:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003e2:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
 80003e4:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80003e6:	f000 f9bb 	bl	8000760 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Channel3;
 80003ea:	4c0d      	ldr	r4, [pc, #52]	; (8000420 <HAL_SPI_MspInit+0x90>)
 80003ec:	4b0d      	ldr	r3, [pc, #52]	; (8000424 <HAL_SPI_MspInit+0x94>)
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 80003ee:	0020      	movs	r0, r4
    hdma_spi1_tx.Instance = DMA1_Channel3;
 80003f0:	6023      	str	r3, [r4, #0]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80003f2:	2310      	movs	r3, #16
 80003f4:	6063      	str	r3, [r4, #4]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80003f6:	3370      	adds	r3, #112	; 0x70
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80003f8:	60a5      	str	r5, [r4, #8]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 80003fa:	60e3      	str	r3, [r4, #12]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80003fc:	6125      	str	r5, [r4, #16]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80003fe:	6165      	str	r5, [r4, #20]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 8000400:	61a5      	str	r5, [r4, #24]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8000402:	61e5      	str	r5, [r4, #28]
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8000404:	f000 f8f2 	bl	80005ec <HAL_DMA_Init>
 8000408:	42a8      	cmp	r0, r5
 800040a:	d001      	beq.n	8000410 <HAL_SPI_MspInit+0x80>
    {
      Error_Handler();
 800040c:	f7ff ffa6 	bl	800035c <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 8000410:	6574      	str	r4, [r6, #84]	; 0x54
 8000412:	6266      	str	r6, [r4, #36]	; 0x24
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 8000414:	b008      	add	sp, #32
 8000416:	bd70      	pop	{r4, r5, r6, pc}
 8000418:	40013000 	.word	0x40013000
 800041c:	40021000 	.word	0x40021000
 8000420:	200007d0 	.word	0x200007d0
 8000424:	40020030 	.word	0x40020030

08000428 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000428:	b510      	push	{r4, lr}
 800042a:	0001      	movs	r1, r0
 800042c:	b086      	sub	sp, #24
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM14 IRQ priority */
  HAL_NVIC_SetPriority(TIM14_IRQn, TickPriority ,0);
 800042e:	2200      	movs	r2, #0
 8000430:	2013      	movs	r0, #19
 8000432:	f000 f8a5 	bl	8000580 <HAL_NVIC_SetPriority>

  /* Enable the TIM14 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM14_IRQn);
 8000436:	2013      	movs	r0, #19
 8000438:	f000 f8cc 	bl	80005d4 <HAL_NVIC_EnableIRQ>
  /* Enable TIM14 clock */
  __HAL_RCC_TIM14_CLK_ENABLE();
 800043c:	2080      	movs	r0, #128	; 0x80
 800043e:	4a14      	ldr	r2, [pc, #80]	; (8000490 <HAL_InitTick+0x68>)
 8000440:	0040      	lsls	r0, r0, #1
 8000442:	69d1      	ldr	r1, [r2, #28]
 8000444:	4301      	orrs	r1, r0
 8000446:	61d1      	str	r1, [r2, #28]
 8000448:	69d3      	ldr	r3, [r2, #28]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800044a:	4669      	mov	r1, sp
  __HAL_RCC_TIM14_CLK_ENABLE();
 800044c:	4003      	ands	r3, r0
 800044e:	9301      	str	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000450:	a802      	add	r0, sp, #8
  __HAL_RCC_TIM14_CLK_ENABLE();
 8000452:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8000454:	f000 fd00 	bl	8000e58 <HAL_RCC_GetClockConfig>

  /* Compute TIM14 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 8000458:	f000 fcee 	bl	8000e38 <HAL_RCC_GetPCLK1Freq>
  /* Compute the prescaler value to have TIM14 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM14 */
  htim14.Instance = TIM14;
 800045c:	4c0d      	ldr	r4, [pc, #52]	; (8000494 <HAL_InitTick+0x6c>)
 800045e:	4b0e      	ldr	r3, [pc, #56]	; (8000498 <HAL_InitTick+0x70>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000460:	490e      	ldr	r1, [pc, #56]	; (800049c <HAL_InitTick+0x74>)
  htim14.Instance = TIM14;
 8000462:	6023      	str	r3, [r4, #0]
  + Period = [(TIM14CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim14.Init.Period = (1000000U / 1000U) - 1U;
 8000464:	4b0e      	ldr	r3, [pc, #56]	; (80004a0 <HAL_InitTick+0x78>)
 8000466:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8000468:	f7ff fe58 	bl	800011c <__udivsi3>
  htim14.Init.Prescaler = uwPrescalerValue;
  htim14.Init.ClockDivision = 0;
 800046c:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800046e:	3801      	subs	r0, #1
  htim14.Init.Prescaler = uwPrescalerValue;
 8000470:	6060      	str	r0, [r4, #4]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 8000472:	0020      	movs	r0, r4
  htim14.Init.ClockDivision = 0;
 8000474:	6123      	str	r3, [r4, #16]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000476:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 8000478:	f001 f85c 	bl	8001534 <HAL_TIM_Base_Init>
 800047c:	0003      	movs	r3, r0
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim14);
  }

  /* Return function status */
  return HAL_ERROR;
 800047e:	2001      	movs	r0, #1
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
 8000480:	2b00      	cmp	r3, #0
 8000482:	d102      	bne.n	800048a <HAL_InitTick+0x62>
    return HAL_TIM_Base_Start_IT(&htim14);
 8000484:	0020      	movs	r0, r4
 8000486:	f000 ff45 	bl	8001314 <HAL_TIM_Base_Start_IT>
}
 800048a:	b006      	add	sp, #24
 800048c:	bd10      	pop	{r4, pc}
 800048e:	46c0      	nop			; (mov r8, r8)
 8000490:	40021000 	.word	0x40021000
 8000494:	20000814 	.word	0x20000814
 8000498:	40002000 	.word	0x40002000
 800049c:	000f4240 	.word	0x000f4240
 80004a0:	000003e7 	.word	0x000003e7

080004a4 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80004a4:	e7fe      	b.n	80004a4 <NMI_Handler>

080004a6 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80004a6:	e7fe      	b.n	80004a6 <HardFault_Handler>

080004a8 <DMA1_Channel2_3_IRQHandler>:

/**
  * @brief This function handles DMA1 channel 2 and 3 interrupts.
  */
void DMA1_Channel2_3_IRQHandler(void)
{
 80004a8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 0 */

  /* USER CODE END DMA1_Channel2_3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 80004aa:	4802      	ldr	r0, [pc, #8]	; (80004b4 <DMA1_Channel2_3_IRQHandler+0xc>)
 80004ac:	f000 f90e 	bl	80006cc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 1 */

  /* USER CODE END DMA1_Channel2_3_IRQn 1 */
}
 80004b0:	bd10      	pop	{r4, pc}
 80004b2:	46c0      	nop			; (mov r8, r8)
 80004b4:	200007d0 	.word	0x200007d0

080004b8 <TIM14_IRQHandler>:

/**
  * @brief This function handles TIM14 global interrupt.
  */
void TIM14_IRQHandler(void)
{
 80004b8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM14_IRQn 0 */

  /* USER CODE END TIM14_IRQn 0 */
  HAL_TIM_IRQHandler(&htim14);
 80004ba:	4802      	ldr	r0, [pc, #8]	; (80004c4 <TIM14_IRQHandler+0xc>)
 80004bc:	f000 ff56 	bl	800136c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM14_IRQn 1 */

  /* USER CODE END TIM14_IRQn 1 */
}
 80004c0:	bd10      	pop	{r4, pc}
 80004c2:	46c0      	nop			; (mov r8, r8)
 80004c4:	20000814 	.word	0x20000814

080004c8 <SystemInit>:
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 80004c8:	4770      	bx	lr
	...

080004cc <ws2812_task>:
 * @brief
 * @note
 * @param
 * @retval
 */
void ws2812_task(void *parameters){
 80004cc:	b507      	push	{r0, r1, r2, lr}
	BaseType_t status;

	uint32_t ws2812_led_byte = 0xF1ACAAAA;
 80004ce:	4b04      	ldr	r3, [pc, #16]	; (80004e0 <ws2812_task+0x14>)
	HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)&ws2812_led_byte, 4);
 80004d0:	2204      	movs	r2, #4
 80004d2:	4804      	ldr	r0, [pc, #16]	; (80004e4 <ws2812_task+0x18>)
 80004d4:	a901      	add	r1, sp, #4
	uint32_t ws2812_led_byte = 0xF1ACAAAA;
 80004d6:	9301      	str	r3, [sp, #4]
	HAL_SPI_Transmit_DMA(&hspi1, (uint8_t *)&ws2812_led_byte, 4);
 80004d8:	f000 fe3e 	bl	8001158 <HAL_SPI_Transmit_DMA>

	/* Main loop */
	while(1){
 80004dc:	e7fe      	b.n	80004dc <ws2812_task+0x10>
 80004de:	46c0      	nop			; (mov r8, r8)
 80004e0:	f1acaaaa 	.word	0xf1acaaaa
 80004e4:	2000076c 	.word	0x2000076c

080004e8 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80004e8:	480d      	ldr	r0, [pc, #52]	; (8000520 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80004ea:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80004ec:	480d      	ldr	r0, [pc, #52]	; (8000524 <LoopForever+0x6>)
  ldr r1, =_edata
 80004ee:	490e      	ldr	r1, [pc, #56]	; (8000528 <LoopForever+0xa>)
  ldr r2, =_sidata
 80004f0:	4a0e      	ldr	r2, [pc, #56]	; (800052c <LoopForever+0xe>)
  movs r3, #0
 80004f2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80004f4:	e002      	b.n	80004fc <LoopCopyDataInit>

080004f6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80004f6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80004f8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80004fa:	3304      	adds	r3, #4

080004fc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80004fc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80004fe:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000500:	d3f9      	bcc.n	80004f6 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000502:	4a0b      	ldr	r2, [pc, #44]	; (8000530 <LoopForever+0x12>)
  ldr r4, =_ebss
 8000504:	4c0b      	ldr	r4, [pc, #44]	; (8000534 <LoopForever+0x16>)
  movs r3, #0
 8000506:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000508:	e001      	b.n	800050e <LoopFillZerobss>

0800050a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800050a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800050c:	3204      	adds	r2, #4

0800050e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800050e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000510:	d3fb      	bcc.n	800050a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8000512:	f7ff ffd9 	bl	80004c8 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8000516:	f002 f9af 	bl	8002878 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800051a:	f7ff febb 	bl	8000294 <main>

0800051e <LoopForever>:

LoopForever:
    b LoopForever
 800051e:	e7fe      	b.n	800051e <LoopForever>
  ldr   r0, =_estack
 8000520:	20001000 	.word	0x20001000
  ldr r0, =_sdata
 8000524:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000528:	20000010 	.word	0x20000010
  ldr r2, =_sidata
 800052c:	0800295c 	.word	0x0800295c
  ldr r2, =_sbss
 8000530:	20000010 	.word	0x20000010
  ldr r4, =_ebss
 8000534:	200008a0 	.word	0x200008a0

08000538 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000538:	e7fe      	b.n	8000538 <ADC1_IRQHandler>
	...

0800053c <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800053c:	2310      	movs	r3, #16
 800053e:	4a06      	ldr	r2, [pc, #24]	; (8000558 <HAL_Init+0x1c>)
{
 8000540:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000542:	6811      	ldr	r1, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 8000544:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000546:	430b      	orrs	r3, r1
 8000548:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 800054a:	f7ff ff6d 	bl	8000428 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800054e:	f7ff ff07 	bl	8000360 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8000552:	2000      	movs	r0, #0
 8000554:	bd10      	pop	{r4, pc}
 8000556:	46c0      	nop			; (mov r8, r8)
 8000558:	40022000 	.word	0x40022000

0800055c <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800055c:	4a03      	ldr	r2, [pc, #12]	; (800056c <HAL_IncTick+0x10>)
 800055e:	4b04      	ldr	r3, [pc, #16]	; (8000570 <HAL_IncTick+0x14>)
 8000560:	6811      	ldr	r1, [r2, #0]
 8000562:	781b      	ldrb	r3, [r3, #0]
 8000564:	185b      	adds	r3, r3, r1
 8000566:	6013      	str	r3, [r2, #0]
}
 8000568:	4770      	bx	lr
 800056a:	46c0      	nop			; (mov r8, r8)
 800056c:	2000085c 	.word	0x2000085c
 8000570:	20000004 	.word	0x20000004

08000574 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000574:	4b01      	ldr	r3, [pc, #4]	; (800057c <HAL_GetTick+0x8>)
 8000576:	6818      	ldr	r0, [r3, #0]
}
 8000578:	4770      	bx	lr
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	2000085c 	.word	0x2000085c

08000580 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000580:	b530      	push	{r4, r5, lr}
 8000582:	25ff      	movs	r5, #255	; 0xff
 8000584:	2403      	movs	r4, #3
 8000586:	002a      	movs	r2, r5
 8000588:	4004      	ands	r4, r0
 800058a:	00e4      	lsls	r4, r4, #3
 800058c:	40a2      	lsls	r2, r4
 800058e:	0189      	lsls	r1, r1, #6
 8000590:	4029      	ands	r1, r5
 8000592:	43d2      	mvns	r2, r2
 8000594:	40a1      	lsls	r1, r4
 8000596:	b2c3      	uxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8000598:	2800      	cmp	r0, #0
 800059a:	db0a      	blt.n	80005b2 <HAL_NVIC_SetPriority+0x32>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800059c:	24c0      	movs	r4, #192	; 0xc0
 800059e:	4b0b      	ldr	r3, [pc, #44]	; (80005cc <HAL_NVIC_SetPriority+0x4c>)
 80005a0:	0880      	lsrs	r0, r0, #2
 80005a2:	0080      	lsls	r0, r0, #2
 80005a4:	18c0      	adds	r0, r0, r3
 80005a6:	00a4      	lsls	r4, r4, #2
 80005a8:	5903      	ldr	r3, [r0, r4]
 80005aa:	401a      	ands	r2, r3
 80005ac:	4311      	orrs	r1, r2
 80005ae:	5101      	str	r1, [r0, r4]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 80005b0:	bd30      	pop	{r4, r5, pc}
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80005b2:	200f      	movs	r0, #15
 80005b4:	4003      	ands	r3, r0
 80005b6:	3b08      	subs	r3, #8
 80005b8:	4805      	ldr	r0, [pc, #20]	; (80005d0 <HAL_NVIC_SetPriority+0x50>)
 80005ba:	089b      	lsrs	r3, r3, #2
 80005bc:	009b      	lsls	r3, r3, #2
 80005be:	181b      	adds	r3, r3, r0
 80005c0:	69d8      	ldr	r0, [r3, #28]
 80005c2:	4002      	ands	r2, r0
 80005c4:	4311      	orrs	r1, r2
 80005c6:	61d9      	str	r1, [r3, #28]
 80005c8:	e7f2      	b.n	80005b0 <HAL_NVIC_SetPriority+0x30>
 80005ca:	46c0      	nop			; (mov r8, r8)
 80005cc:	e000e100 	.word	0xe000e100
 80005d0:	e000ed00 	.word	0xe000ed00

080005d4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80005d4:	2800      	cmp	r0, #0
 80005d6:	db05      	blt.n	80005e4 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80005d8:	231f      	movs	r3, #31
 80005da:	4018      	ands	r0, r3
 80005dc:	3b1e      	subs	r3, #30
 80005de:	4083      	lsls	r3, r0
 80005e0:	4a01      	ldr	r2, [pc, #4]	; (80005e8 <HAL_NVIC_EnableIRQ+0x14>)
 80005e2:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80005e4:	4770      	bx	lr
 80005e6:	46c0      	nop			; (mov r8, r8)
 80005e8:	e000e100 	.word	0xe000e100

080005ec <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 80005ec:	b570      	push	{r4, r5, r6, lr}
 80005ee:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 80005f0:	2001      	movs	r0, #1
  if(NULL == hdma)
 80005f2:	2c00      	cmp	r4, #0
 80005f4:	d024      	beq.n	8000640 <HAL_DMA_Init+0x54>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80005f6:	2302      	movs	r3, #2
 80005f8:	1ca5      	adds	r5, r4, #2
 80005fa:	77eb      	strb	r3, [r5, #31]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 80005fc:	6820      	ldr	r0, [r4, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80005fe:	4b11      	ldr	r3, [pc, #68]	; (8000644 <HAL_DMA_Init+0x58>)
  tmp = hdma->Instance->CCR;
 8000600:	6802      	ldr	r2, [r0, #0]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8000602:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8000604:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 8000606:	6863      	ldr	r3, [r4, #4]
 8000608:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800060a:	68e1      	ldr	r1, [r4, #12]
 800060c:	430b      	orrs	r3, r1
 800060e:	6921      	ldr	r1, [r4, #16]
 8000610:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000612:	6961      	ldr	r1, [r4, #20]
 8000614:	430b      	orrs	r3, r1
 8000616:	69a1      	ldr	r1, [r4, #24]
 8000618:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 800061a:	69e1      	ldr	r1, [r4, #28]
 800061c:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 800061e:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8000620:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8000622:	4b09      	ldr	r3, [pc, #36]	; (8000648 <HAL_DMA_Init+0x5c>)
 8000624:	2114      	movs	r1, #20
 8000626:	18c0      	adds	r0, r0, r3
 8000628:	f7ff fd78 	bl	800011c <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 800062c:	4b07      	ldr	r3, [pc, #28]	; (800064c <HAL_DMA_Init+0x60>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800062e:	0080      	lsls	r0, r0, #2
 8000630:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 8000632:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000634:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 8000636:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000638:	63a0      	str	r0, [r4, #56]	; 0x38
  hdma->Lock = HAL_UNLOCKED;
 800063a:	18e4      	adds	r4, r4, r3
  hdma->State = HAL_DMA_STATE_READY;
 800063c:	77eb      	strb	r3, [r5, #31]
  hdma->Lock = HAL_UNLOCKED;
 800063e:	77e0      	strb	r0, [r4, #31]
}  
 8000640:	bd70      	pop	{r4, r5, r6, pc}
 8000642:	46c0      	nop			; (mov r8, r8)
 8000644:	ffffc00f 	.word	0xffffc00f
 8000648:	bffdfff8 	.word	0xbffdfff8
 800064c:	40020000 	.word	0x40020000

08000650 <HAL_DMA_Start_IT>:
{
 8000650:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 8000652:	1c45      	adds	r5, r0, #1
{
 8000654:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hdma);
 8000656:	7feb      	ldrb	r3, [r5, #31]
{
 8000658:	0004      	movs	r4, r0
  __HAL_LOCK(hdma);
 800065a:	2002      	movs	r0, #2
 800065c:	2b01      	cmp	r3, #1
 800065e:	d027      	beq.n	80006b0 <HAL_DMA_Start_IT+0x60>
 8000660:	2301      	movs	r3, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8000662:	1827      	adds	r7, r4, r0
  __HAL_LOCK(hdma);
 8000664:	77eb      	strb	r3, [r5, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8000666:	7ffb      	ldrb	r3, [r7, #31]
 8000668:	2600      	movs	r6, #0
 800066a:	469c      	mov	ip, r3
 800066c:	4660      	mov	r0, ip
 800066e:	b2db      	uxtb	r3, r3
 8000670:	2801      	cmp	r0, #1
 8000672:	d128      	bne.n	80006c6 <HAL_DMA_Start_IT+0x76>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8000674:	3001      	adds	r0, #1
 8000676:	77f8      	strb	r0, [r7, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000678:	6820      	ldr	r0, [r4, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800067a:	63a6      	str	r6, [r4, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800067c:	6805      	ldr	r5, [r0, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800067e:	6c26      	ldr	r6, [r4, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000680:	439d      	bics	r5, r3
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8000682:	40b3      	lsls	r3, r6
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8000684:	6005      	str	r5, [r0, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8000686:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8000688:	606b      	str	r3, [r5, #4]
  hdma->Instance->CNDTR = DataLength;
 800068a:	9b01      	ldr	r3, [sp, #4]
 800068c:	6043      	str	r3, [r0, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800068e:	6863      	ldr	r3, [r4, #4]
 8000690:	2b10      	cmp	r3, #16
 8000692:	d10e      	bne.n	80006b2 <HAL_DMA_Start_IT+0x62>
    hdma->Instance->CPAR = DstAddress;
 8000694:	6082      	str	r2, [r0, #8]
    hdma->Instance->CMAR = SrcAddress;
 8000696:	60c1      	str	r1, [r0, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8000698:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800069a:	6802      	ldr	r2, [r0, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 800069c:	2b00      	cmp	r3, #0
 800069e:	d00b      	beq.n	80006b8 <HAL_DMA_Start_IT+0x68>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80006a0:	230e      	movs	r3, #14
 80006a2:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80006a4:	6003      	str	r3, [r0, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 80006a6:	2301      	movs	r3, #1
 80006a8:	6802      	ldr	r2, [r0, #0]
 80006aa:	4313      	orrs	r3, r2
 80006ac:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 80006ae:	2000      	movs	r0, #0
} 
 80006b0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 80006b2:	6081      	str	r1, [r0, #8]
    hdma->Instance->CMAR = DstAddress;
 80006b4:	60c2      	str	r2, [r0, #12]
 80006b6:	e7ef      	b.n	8000698 <HAL_DMA_Start_IT+0x48>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 80006b8:	230a      	movs	r3, #10
 80006ba:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80006bc:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 80006be:	6003      	str	r3, [r0, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80006c0:	6803      	ldr	r3, [r0, #0]
 80006c2:	4393      	bics	r3, r2
 80006c4:	e7ee      	b.n	80006a4 <HAL_DMA_Start_IT+0x54>
    status = HAL_BUSY;
 80006c6:	2002      	movs	r0, #2
    __HAL_UNLOCK(hdma); 
 80006c8:	77ee      	strb	r6, [r5, #31]
    status = HAL_BUSY;
 80006ca:	e7f1      	b.n	80006b0 <HAL_DMA_Start_IT+0x60>

080006cc <HAL_DMA_IRQHandler>:
{
 80006cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80006ce:	2704      	movs	r7, #4
 80006d0:	003e      	movs	r6, r7
 80006d2:	6c01      	ldr	r1, [r0, #64]	; 0x40
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80006d4:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80006d6:	408e      	lsls	r6, r1
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80006d8:	6815      	ldr	r5, [r2, #0]
  uint32_t source_it = hdma->Instance->CCR;
 80006da:	6803      	ldr	r3, [r0, #0]
 80006dc:	681c      	ldr	r4, [r3, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80006de:	4235      	tst	r5, r6
 80006e0:	d00d      	beq.n	80006fe <HAL_DMA_IRQHandler+0x32>
 80006e2:	423c      	tst	r4, r7
 80006e4:	d00b      	beq.n	80006fe <HAL_DMA_IRQHandler+0x32>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80006e6:	6819      	ldr	r1, [r3, #0]
 80006e8:	0689      	lsls	r1, r1, #26
 80006ea:	d402      	bmi.n	80006f2 <HAL_DMA_IRQHandler+0x26>
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80006ec:	6819      	ldr	r1, [r3, #0]
 80006ee:	43b9      	bics	r1, r7
 80006f0:	6019      	str	r1, [r3, #0]
  	if(hdma->XferHalfCpltCallback != NULL)
 80006f2:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
 80006f4:	6056      	str	r6, [r2, #4]
  	if(hdma->XferHalfCpltCallback != NULL)
 80006f6:	2b00      	cmp	r3, #0
 80006f8:	d019      	beq.n	800072e <HAL_DMA_IRQHandler+0x62>
    	hdma->XferErrorCallback(hdma);
 80006fa:	4798      	blx	r3
}  
 80006fc:	e017      	b.n	800072e <HAL_DMA_IRQHandler+0x62>
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 80006fe:	2702      	movs	r7, #2
 8000700:	003e      	movs	r6, r7
 8000702:	408e      	lsls	r6, r1
 8000704:	4235      	tst	r5, r6
 8000706:	d013      	beq.n	8000730 <HAL_DMA_IRQHandler+0x64>
 8000708:	423c      	tst	r4, r7
 800070a:	d011      	beq.n	8000730 <HAL_DMA_IRQHandler+0x64>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800070c:	6819      	ldr	r1, [r3, #0]
 800070e:	0689      	lsls	r1, r1, #26
 8000710:	d406      	bmi.n	8000720 <HAL_DMA_IRQHandler+0x54>
  		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
 8000712:	240a      	movs	r4, #10
 8000714:	6819      	ldr	r1, [r3, #0]
 8000716:	43a1      	bics	r1, r4
 8000718:	6019      	str	r1, [r3, #0]
  		hdma->State = HAL_DMA_STATE_READY;
 800071a:	2101      	movs	r1, #1
 800071c:	19c3      	adds	r3, r0, r7
 800071e:	77d9      	strb	r1, [r3, #31]
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
 8000720:	6056      	str	r6, [r2, #4]
  	__HAL_UNLOCK(hdma);
 8000722:	2200      	movs	r2, #0
 8000724:	1c43      	adds	r3, r0, #1
 8000726:	77da      	strb	r2, [r3, #31]
  	if(hdma->XferCpltCallback != NULL)
 8000728:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(hdma->XferErrorCallback != NULL)
 800072a:	4293      	cmp	r3, r2
 800072c:	d1e5      	bne.n	80006fa <HAL_DMA_IRQHandler+0x2e>
}  
 800072e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8000730:	2608      	movs	r6, #8
 8000732:	0037      	movs	r7, r6
 8000734:	408f      	lsls	r7, r1
 8000736:	423d      	tst	r5, r7
 8000738:	d0f9      	beq.n	800072e <HAL_DMA_IRQHandler+0x62>
 800073a:	4234      	tst	r4, r6
 800073c:	d0f7      	beq.n	800072e <HAL_DMA_IRQHandler+0x62>
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800073e:	250e      	movs	r5, #14
 8000740:	681c      	ldr	r4, [r3, #0]
 8000742:	43ac      	bics	r4, r5
 8000744:	601c      	str	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8000746:	2301      	movs	r3, #1
 8000748:	001c      	movs	r4, r3
 800074a:	408c      	lsls	r4, r1
 800074c:	6054      	str	r4, [r2, #4]
    hdma->State = HAL_DMA_STATE_READY;    
 800074e:	1c82      	adds	r2, r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8000750:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;    
 8000752:	77d3      	strb	r3, [r2, #31]
    __HAL_UNLOCK(hdma); 
 8000754:	2200      	movs	r2, #0
 8000756:	18c3      	adds	r3, r0, r3
 8000758:	77da      	strb	r2, [r3, #31]
    if(hdma->XferErrorCallback != NULL)
 800075a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800075c:	e7e5      	b.n	800072a <HAL_DMA_IRQHandler+0x5e>
	...

08000760 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0x00u;
 8000760:	2300      	movs	r3, #0
{
 8000762:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000764:	b087      	sub	sp, #28
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000766:	680a      	ldr	r2, [r1, #0]
 8000768:	0014      	movs	r4, r2
 800076a:	40dc      	lsrs	r4, r3
 800076c:	d101      	bne.n	8000772 <HAL_GPIO_Init+0x12>
      }
    }

    position++;
  } 
}
 800076e:	b007      	add	sp, #28
 8000770:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8000772:	2501      	movs	r5, #1
 8000774:	0014      	movs	r4, r2
 8000776:	409d      	lsls	r5, r3
 8000778:	402c      	ands	r4, r5
 800077a:	9401      	str	r4, [sp, #4]
    if (iocurrent != 0x00u)
 800077c:	422a      	tst	r2, r5
 800077e:	d100      	bne.n	8000782 <HAL_GPIO_Init+0x22>
 8000780:	e095      	b.n	80008ae <HAL_GPIO_Init+0x14e>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 8000782:	684a      	ldr	r2, [r1, #4]
 8000784:	005e      	lsls	r6, r3, #1
 8000786:	4694      	mov	ip, r2
 8000788:	2203      	movs	r2, #3
 800078a:	4664      	mov	r4, ip
 800078c:	4022      	ands	r2, r4
 800078e:	2403      	movs	r4, #3
 8000790:	40b4      	lsls	r4, r6
 8000792:	43e4      	mvns	r4, r4
 8000794:	9402      	str	r4, [sp, #8]
 8000796:	1e54      	subs	r4, r2, #1
 8000798:	2c01      	cmp	r4, #1
 800079a:	d82a      	bhi.n	80007f2 <HAL_GPIO_Init+0x92>
        temp = GPIOx->OSPEEDR;
 800079c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800079e:	9c02      	ldr	r4, [sp, #8]
 80007a0:	4027      	ands	r7, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 80007a2:	68cc      	ldr	r4, [r1, #12]
 80007a4:	40b4      	lsls	r4, r6
 80007a6:	433c      	orrs	r4, r7
        GPIOx->OSPEEDR = temp;
 80007a8:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 80007aa:	6844      	ldr	r4, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80007ac:	2701      	movs	r7, #1
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80007ae:	43ac      	bics	r4, r5
 80007b0:	0025      	movs	r5, r4
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80007b2:	4664      	mov	r4, ip
 80007b4:	0924      	lsrs	r4, r4, #4
 80007b6:	403c      	ands	r4, r7
 80007b8:	409c      	lsls	r4, r3
 80007ba:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 80007bc:	6044      	str	r4, [r0, #4]
        temp = GPIOx->PUPDR;
 80007be:	68c5      	ldr	r5, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 80007c0:	9c02      	ldr	r4, [sp, #8]
 80007c2:	4025      	ands	r5, r4
        temp |= ((GPIO_Init->Pull) << (position * 2u));
 80007c4:	688c      	ldr	r4, [r1, #8]
 80007c6:	40b4      	lsls	r4, r6
 80007c8:	432c      	orrs	r4, r5
        GPIOx->PUPDR = temp;
 80007ca:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80007cc:	2a02      	cmp	r2, #2
 80007ce:	d112      	bne.n	80007f6 <HAL_GPIO_Init+0x96>
        temp = GPIOx->AFR[position >> 3u];
 80007d0:	08dc      	lsrs	r4, r3, #3
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80007d2:	2507      	movs	r5, #7
 80007d4:	00a4      	lsls	r4, r4, #2
 80007d6:	1904      	adds	r4, r0, r4
        temp = GPIOx->AFR[position >> 3u];
 80007d8:	6a27      	ldr	r7, [r4, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80007da:	9403      	str	r4, [sp, #12]
 80007dc:	240f      	movs	r4, #15
 80007de:	401d      	ands	r5, r3
 80007e0:	00ad      	lsls	r5, r5, #2
 80007e2:	40ac      	lsls	r4, r5
 80007e4:	43a7      	bics	r7, r4
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80007e6:	690c      	ldr	r4, [r1, #16]
 80007e8:	40ac      	lsls	r4, r5
 80007ea:	4327      	orrs	r7, r4
        GPIOx->AFR[position >> 3u] = temp;
 80007ec:	9c03      	ldr	r4, [sp, #12]
 80007ee:	6227      	str	r7, [r4, #32]
 80007f0:	e001      	b.n	80007f6 <HAL_GPIO_Init+0x96>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80007f2:	2a03      	cmp	r2, #3
 80007f4:	d1e3      	bne.n	80007be <HAL_GPIO_Init+0x5e>
      temp = GPIOx->MODER;
 80007f6:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 80007f8:	9d02      	ldr	r5, [sp, #8]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80007fa:	40b2      	lsls	r2, r6
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 80007fc:	4025      	ands	r5, r4
 80007fe:	002c      	movs	r4, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 8000800:	4314      	orrs	r4, r2
      GPIOx->MODER = temp;
 8000802:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8000804:	24c0      	movs	r4, #192	; 0xc0
 8000806:	4662      	mov	r2, ip
 8000808:	02a4      	lsls	r4, r4, #10
 800080a:	4222      	tst	r2, r4
 800080c:	d04f      	beq.n	80008ae <HAL_GPIO_Init+0x14e>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800080e:	2501      	movs	r5, #1
 8000810:	4a28      	ldr	r2, [pc, #160]	; (80008b4 <HAL_GPIO_Init+0x154>)
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8000812:	2790      	movs	r7, #144	; 0x90
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000814:	6994      	ldr	r4, [r2, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8000816:	05ff      	lsls	r7, r7, #23
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000818:	432c      	orrs	r4, r5
 800081a:	6194      	str	r4, [r2, #24]
 800081c:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2u];
 800081e:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000820:	402a      	ands	r2, r5
 8000822:	9205      	str	r2, [sp, #20]
 8000824:	9a05      	ldr	r2, [sp, #20]
        temp = SYSCFG->EXTICR[position >> 2u];
 8000826:	4a24      	ldr	r2, [pc, #144]	; (80008b8 <HAL_GPIO_Init+0x158>)
 8000828:	00a4      	lsls	r4, r4, #2
 800082a:	18a4      	adds	r4, r4, r2
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800082c:	220f      	movs	r2, #15
 800082e:	3502      	adds	r5, #2
 8000830:	401d      	ands	r5, r3
 8000832:	00ad      	lsls	r5, r5, #2
 8000834:	40aa      	lsls	r2, r5
        temp = SYSCFG->EXTICR[position >> 2u];
 8000836:	68a6      	ldr	r6, [r4, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8000838:	4396      	bics	r6, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800083a:	2200      	movs	r2, #0
 800083c:	42b8      	cmp	r0, r7
 800083e:	d00c      	beq.n	800085a <HAL_GPIO_Init+0xfa>
 8000840:	4f1e      	ldr	r7, [pc, #120]	; (80008bc <HAL_GPIO_Init+0x15c>)
 8000842:	3201      	adds	r2, #1
 8000844:	42b8      	cmp	r0, r7
 8000846:	d008      	beq.n	800085a <HAL_GPIO_Init+0xfa>
 8000848:	4f1d      	ldr	r7, [pc, #116]	; (80008c0 <HAL_GPIO_Init+0x160>)
 800084a:	3201      	adds	r2, #1
 800084c:	42b8      	cmp	r0, r7
 800084e:	d004      	beq.n	800085a <HAL_GPIO_Init+0xfa>
 8000850:	4f1c      	ldr	r7, [pc, #112]	; (80008c4 <HAL_GPIO_Init+0x164>)
 8000852:	3201      	adds	r2, #1
 8000854:	42b8      	cmp	r0, r7
 8000856:	d000      	beq.n	800085a <HAL_GPIO_Init+0xfa>
 8000858:	3202      	adds	r2, #2
 800085a:	40aa      	lsls	r2, r5
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800085c:	4667      	mov	r7, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800085e:	4332      	orrs	r2, r6
        SYSCFG->EXTICR[position >> 2u] = temp;
 8000860:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 8000862:	4a19      	ldr	r2, [pc, #100]	; (80008c8 <HAL_GPIO_Init+0x168>)
        temp &= ~(iocurrent);
 8000864:	9c01      	ldr	r4, [sp, #4]
        temp = EXTI->IMR;
 8000866:	6816      	ldr	r6, [r2, #0]
          temp |= iocurrent;
 8000868:	9d01      	ldr	r5, [sp, #4]
        temp &= ~(iocurrent);
 800086a:	43e4      	mvns	r4, r4
          temp |= iocurrent;
 800086c:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800086e:	03ff      	lsls	r7, r7, #15
 8000870:	d401      	bmi.n	8000876 <HAL_GPIO_Init+0x116>
        temp &= ~(iocurrent);
 8000872:	0035      	movs	r5, r6
 8000874:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000876:	4667      	mov	r7, ip
        EXTI->IMR = temp;
 8000878:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 800087a:	6856      	ldr	r6, [r2, #4]
          temp |= iocurrent;
 800087c:	9d01      	ldr	r5, [sp, #4]
 800087e:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000880:	03bf      	lsls	r7, r7, #14
 8000882:	d401      	bmi.n	8000888 <HAL_GPIO_Init+0x128>
        temp &= ~(iocurrent);
 8000884:	0035      	movs	r5, r6
 8000886:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000888:	4667      	mov	r7, ip
        EXTI->EMR = temp;
 800088a:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 800088c:	6896      	ldr	r6, [r2, #8]
          temp |= iocurrent;
 800088e:	9d01      	ldr	r5, [sp, #4]
 8000890:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000892:	02ff      	lsls	r7, r7, #11
 8000894:	d401      	bmi.n	800089a <HAL_GPIO_Init+0x13a>
        temp &= ~(iocurrent);
 8000896:	0035      	movs	r5, r6
 8000898:	4025      	ands	r5, r4
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 800089a:	4667      	mov	r7, ip
        EXTI->RTSR = temp;
 800089c:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 800089e:	68d5      	ldr	r5, [r2, #12]
          temp |= iocurrent;
 80008a0:	9e01      	ldr	r6, [sp, #4]
 80008a2:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 80008a4:	02bf      	lsls	r7, r7, #10
 80008a6:	d401      	bmi.n	80008ac <HAL_GPIO_Init+0x14c>
        temp &= ~(iocurrent);
 80008a8:	4025      	ands	r5, r4
 80008aa:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 80008ac:	60d6      	str	r6, [r2, #12]
    position++;
 80008ae:	3301      	adds	r3, #1
 80008b0:	e759      	b.n	8000766 <HAL_GPIO_Init+0x6>
 80008b2:	46c0      	nop			; (mov r8, r8)
 80008b4:	40021000 	.word	0x40021000
 80008b8:	40010000 	.word	0x40010000
 80008bc:	48000400 	.word	0x48000400
 80008c0:	48000800 	.word	0x48000800
 80008c4:	48000c00 	.word	0x48000c00
 80008c8:	40010400 	.word	0x40010400

080008cc <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80008cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008ce:	0004      	movs	r4, r0
 80008d0:	b085      	sub	sp, #20
  uint32_t tickstart;
  uint32_t pll_config;
  uint32_t pll_config2;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80008d2:	2800      	cmp	r0, #0
 80008d4:	d045      	beq.n	8000962 <HAL_RCC_OscConfig+0x96>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80008d6:	6803      	ldr	r3, [r0, #0]
 80008d8:	07db      	lsls	r3, r3, #31
 80008da:	d42f      	bmi.n	800093c <HAL_RCC_OscConfig+0x70>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80008dc:	6823      	ldr	r3, [r4, #0]
 80008de:	079b      	lsls	r3, r3, #30
 80008e0:	d500      	bpl.n	80008e4 <HAL_RCC_OscConfig+0x18>
 80008e2:	e081      	b.n	80009e8 <HAL_RCC_OscConfig+0x11c>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80008e4:	6823      	ldr	r3, [r4, #0]
 80008e6:	071b      	lsls	r3, r3, #28
 80008e8:	d500      	bpl.n	80008ec <HAL_RCC_OscConfig+0x20>
 80008ea:	e0bc      	b.n	8000a66 <HAL_RCC_OscConfig+0x19a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80008ec:	6823      	ldr	r3, [r4, #0]
 80008ee:	075b      	lsls	r3, r3, #29
 80008f0:	d500      	bpl.n	80008f4 <HAL_RCC_OscConfig+0x28>
 80008f2:	e0df      	b.n	8000ab4 <HAL_RCC_OscConfig+0x1e8>
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*----------------------------- HSI14 Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 80008f4:	6823      	ldr	r3, [r4, #0]
 80008f6:	06db      	lsls	r3, r3, #27
 80008f8:	d51a      	bpl.n	8000930 <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));

    /* Check the HSI14 State */
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 80008fa:	6962      	ldr	r2, [r4, #20]
 80008fc:	2304      	movs	r3, #4
 80008fe:	4db5      	ldr	r5, [pc, #724]	; (8000bd4 <HAL_RCC_OscConfig+0x308>)
 8000900:	2a01      	cmp	r2, #1
 8000902:	d000      	beq.n	8000906 <HAL_RCC_OscConfig+0x3a>
 8000904:	e14a      	b.n	8000b9c <HAL_RCC_OscConfig+0x2d0>
    {
      /* Disable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_DISABLE();
 8000906:	6b69      	ldr	r1, [r5, #52]	; 0x34

      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till HSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 8000908:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 800090a:	430b      	orrs	r3, r1
 800090c:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 800090e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000910:	431a      	orrs	r2, r3
 8000912:	636a      	str	r2, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 8000914:	f7ff fe2e 	bl	8000574 <HAL_GetTick>
 8000918:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800091a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800091c:	423b      	tst	r3, r7
 800091e:	d100      	bne.n	8000922 <HAL_RCC_OscConfig+0x56>
 8000920:	e135      	b.n	8000b8e <HAL_RCC_OscConfig+0x2c2>
    {
      /* Enable ADC control of the Internal High Speed oscillator HSI14 */
      __HAL_RCC_HSI14ADC_ENABLE();

      /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 8000922:	21f8      	movs	r1, #248	; 0xf8
 8000924:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000926:	69a3      	ldr	r3, [r4, #24]
 8000928:	438a      	bics	r2, r1
 800092a:	00db      	lsls	r3, r3, #3
 800092c:	4313      	orrs	r3, r2
 800092e:	636b      	str	r3, [r5, #52]	; 0x34
#endif /* RCC_HSI48_SUPPORT */
       
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000930:	6a23      	ldr	r3, [r4, #32]
 8000932:	2b00      	cmp	r3, #0
 8000934:	d000      	beq.n	8000938 <HAL_RCC_OscConfig+0x6c>
 8000936:	e159      	b.n	8000bec <HAL_RCC_OscConfig+0x320>
        }
      }
    }
  }

  return HAL_OK;
 8000938:	2000      	movs	r0, #0
 800093a:	e02a      	b.n	8000992 <HAL_RCC_OscConfig+0xc6>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800093c:	210c      	movs	r1, #12
 800093e:	4da5      	ldr	r5, [pc, #660]	; (8000bd4 <HAL_RCC_OscConfig+0x308>)
 8000940:	686a      	ldr	r2, [r5, #4]
 8000942:	400a      	ands	r2, r1
 8000944:	2a04      	cmp	r2, #4
 8000946:	d006      	beq.n	8000956 <HAL_RCC_OscConfig+0x8a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000948:	686b      	ldr	r3, [r5, #4]
 800094a:	400b      	ands	r3, r1
 800094c:	2b08      	cmp	r3, #8
 800094e:	d10a      	bne.n	8000966 <HAL_RCC_OscConfig+0x9a>
 8000950:	686b      	ldr	r3, [r5, #4]
 8000952:	03db      	lsls	r3, r3, #15
 8000954:	d507      	bpl.n	8000966 <HAL_RCC_OscConfig+0x9a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000956:	682b      	ldr	r3, [r5, #0]
 8000958:	039b      	lsls	r3, r3, #14
 800095a:	d5bf      	bpl.n	80008dc <HAL_RCC_OscConfig+0x10>
 800095c:	6863      	ldr	r3, [r4, #4]
 800095e:	2b00      	cmp	r3, #0
 8000960:	d1bc      	bne.n	80008dc <HAL_RCC_OscConfig+0x10>
          return HAL_ERROR;
 8000962:	2001      	movs	r0, #1
 8000964:	e015      	b.n	8000992 <HAL_RCC_OscConfig+0xc6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000966:	6863      	ldr	r3, [r4, #4]
 8000968:	2b01      	cmp	r3, #1
 800096a:	d114      	bne.n	8000996 <HAL_RCC_OscConfig+0xca>
 800096c:	2380      	movs	r3, #128	; 0x80
 800096e:	682a      	ldr	r2, [r5, #0]
 8000970:	025b      	lsls	r3, r3, #9
 8000972:	4313      	orrs	r3, r2
 8000974:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000976:	f7ff fdfd 	bl	8000574 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800097a:	2780      	movs	r7, #128	; 0x80
        tickstart = HAL_GetTick();
 800097c:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800097e:	02bf      	lsls	r7, r7, #10
 8000980:	682b      	ldr	r3, [r5, #0]
 8000982:	423b      	tst	r3, r7
 8000984:	d1aa      	bne.n	80008dc <HAL_RCC_OscConfig+0x10>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000986:	f7ff fdf5 	bl	8000574 <HAL_GetTick>
 800098a:	1b80      	subs	r0, r0, r6
 800098c:	2864      	cmp	r0, #100	; 0x64
 800098e:	d9f7      	bls.n	8000980 <HAL_RCC_OscConfig+0xb4>
            return HAL_TIMEOUT;
 8000990:	2003      	movs	r0, #3
}
 8000992:	b005      	add	sp, #20
 8000994:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000996:	2b00      	cmp	r3, #0
 8000998:	d116      	bne.n	80009c8 <HAL_RCC_OscConfig+0xfc>
 800099a:	682b      	ldr	r3, [r5, #0]
 800099c:	4a8e      	ldr	r2, [pc, #568]	; (8000bd8 <HAL_RCC_OscConfig+0x30c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800099e:	2780      	movs	r7, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009a0:	4013      	ands	r3, r2
 80009a2:	602b      	str	r3, [r5, #0]
 80009a4:	682b      	ldr	r3, [r5, #0]
 80009a6:	4a8d      	ldr	r2, [pc, #564]	; (8000bdc <HAL_RCC_OscConfig+0x310>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009a8:	02bf      	lsls	r7, r7, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009aa:	4013      	ands	r3, r2
 80009ac:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80009ae:	f7ff fde1 	bl	8000574 <HAL_GetTick>
 80009b2:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009b4:	682b      	ldr	r3, [r5, #0]
 80009b6:	423b      	tst	r3, r7
 80009b8:	d100      	bne.n	80009bc <HAL_RCC_OscConfig+0xf0>
 80009ba:	e78f      	b.n	80008dc <HAL_RCC_OscConfig+0x10>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80009bc:	f7ff fdda 	bl	8000574 <HAL_GetTick>
 80009c0:	1b80      	subs	r0, r0, r6
 80009c2:	2864      	cmp	r0, #100	; 0x64
 80009c4:	d9f6      	bls.n	80009b4 <HAL_RCC_OscConfig+0xe8>
 80009c6:	e7e3      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009c8:	2b05      	cmp	r3, #5
 80009ca:	d105      	bne.n	80009d8 <HAL_RCC_OscConfig+0x10c>
 80009cc:	2380      	movs	r3, #128	; 0x80
 80009ce:	682a      	ldr	r2, [r5, #0]
 80009d0:	02db      	lsls	r3, r3, #11
 80009d2:	4313      	orrs	r3, r2
 80009d4:	602b      	str	r3, [r5, #0]
 80009d6:	e7c9      	b.n	800096c <HAL_RCC_OscConfig+0xa0>
 80009d8:	682b      	ldr	r3, [r5, #0]
 80009da:	4a7f      	ldr	r2, [pc, #508]	; (8000bd8 <HAL_RCC_OscConfig+0x30c>)
 80009dc:	4013      	ands	r3, r2
 80009de:	602b      	str	r3, [r5, #0]
 80009e0:	682b      	ldr	r3, [r5, #0]
 80009e2:	4a7e      	ldr	r2, [pc, #504]	; (8000bdc <HAL_RCC_OscConfig+0x310>)
 80009e4:	4013      	ands	r3, r2
 80009e6:	e7c5      	b.n	8000974 <HAL_RCC_OscConfig+0xa8>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80009e8:	220c      	movs	r2, #12
 80009ea:	4d7a      	ldr	r5, [pc, #488]	; (8000bd4 <HAL_RCC_OscConfig+0x308>)
 80009ec:	686b      	ldr	r3, [r5, #4]
 80009ee:	4213      	tst	r3, r2
 80009f0:	d006      	beq.n	8000a00 <HAL_RCC_OscConfig+0x134>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 80009f2:	686b      	ldr	r3, [r5, #4]
 80009f4:	4013      	ands	r3, r2
 80009f6:	2b08      	cmp	r3, #8
 80009f8:	d110      	bne.n	8000a1c <HAL_RCC_OscConfig+0x150>
 80009fa:	686b      	ldr	r3, [r5, #4]
 80009fc:	03db      	lsls	r3, r3, #15
 80009fe:	d40d      	bmi.n	8000a1c <HAL_RCC_OscConfig+0x150>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000a00:	682b      	ldr	r3, [r5, #0]
 8000a02:	079b      	lsls	r3, r3, #30
 8000a04:	d502      	bpl.n	8000a0c <HAL_RCC_OscConfig+0x140>
 8000a06:	68e3      	ldr	r3, [r4, #12]
 8000a08:	2b01      	cmp	r3, #1
 8000a0a:	d1aa      	bne.n	8000962 <HAL_RCC_OscConfig+0x96>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000a0c:	21f8      	movs	r1, #248	; 0xf8
 8000a0e:	682a      	ldr	r2, [r5, #0]
 8000a10:	6923      	ldr	r3, [r4, #16]
 8000a12:	438a      	bics	r2, r1
 8000a14:	00db      	lsls	r3, r3, #3
 8000a16:	4313      	orrs	r3, r2
 8000a18:	602b      	str	r3, [r5, #0]
 8000a1a:	e763      	b.n	80008e4 <HAL_RCC_OscConfig+0x18>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8000a1c:	68e2      	ldr	r2, [r4, #12]
 8000a1e:	2301      	movs	r3, #1
 8000a20:	2a00      	cmp	r2, #0
 8000a22:	d00f      	beq.n	8000a44 <HAL_RCC_OscConfig+0x178>
        __HAL_RCC_HSI_ENABLE();
 8000a24:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000a26:	2702      	movs	r7, #2
        __HAL_RCC_HSI_ENABLE();
 8000a28:	4313      	orrs	r3, r2
 8000a2a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000a2c:	f7ff fda2 	bl	8000574 <HAL_GetTick>
 8000a30:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000a32:	682b      	ldr	r3, [r5, #0]
 8000a34:	423b      	tst	r3, r7
 8000a36:	d1e9      	bne.n	8000a0c <HAL_RCC_OscConfig+0x140>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000a38:	f7ff fd9c 	bl	8000574 <HAL_GetTick>
 8000a3c:	1b80      	subs	r0, r0, r6
 8000a3e:	2802      	cmp	r0, #2
 8000a40:	d9f7      	bls.n	8000a32 <HAL_RCC_OscConfig+0x166>
 8000a42:	e7a5      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
        __HAL_RCC_HSI_DISABLE();
 8000a44:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000a46:	2702      	movs	r7, #2
        __HAL_RCC_HSI_DISABLE();
 8000a48:	439a      	bics	r2, r3
 8000a4a:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 8000a4c:	f7ff fd92 	bl	8000574 <HAL_GetTick>
 8000a50:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000a52:	682b      	ldr	r3, [r5, #0]
 8000a54:	423b      	tst	r3, r7
 8000a56:	d100      	bne.n	8000a5a <HAL_RCC_OscConfig+0x18e>
 8000a58:	e744      	b.n	80008e4 <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000a5a:	f7ff fd8b 	bl	8000574 <HAL_GetTick>
 8000a5e:	1b80      	subs	r0, r0, r6
 8000a60:	2802      	cmp	r0, #2
 8000a62:	d9f6      	bls.n	8000a52 <HAL_RCC_OscConfig+0x186>
 8000a64:	e794      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8000a66:	69e2      	ldr	r2, [r4, #28]
 8000a68:	2301      	movs	r3, #1
 8000a6a:	4d5a      	ldr	r5, [pc, #360]	; (8000bd4 <HAL_RCC_OscConfig+0x308>)
 8000a6c:	2a00      	cmp	r2, #0
 8000a6e:	d010      	beq.n	8000a92 <HAL_RCC_OscConfig+0x1c6>
      __HAL_RCC_LSI_ENABLE();
 8000a70:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000a72:	2702      	movs	r7, #2
      __HAL_RCC_LSI_ENABLE();
 8000a74:	4313      	orrs	r3, r2
 8000a76:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000a78:	f7ff fd7c 	bl	8000574 <HAL_GetTick>
 8000a7c:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8000a7e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000a80:	423b      	tst	r3, r7
 8000a82:	d000      	beq.n	8000a86 <HAL_RCC_OscConfig+0x1ba>
 8000a84:	e732      	b.n	80008ec <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000a86:	f7ff fd75 	bl	8000574 <HAL_GetTick>
 8000a8a:	1b80      	subs	r0, r0, r6
 8000a8c:	2802      	cmp	r0, #2
 8000a8e:	d9f6      	bls.n	8000a7e <HAL_RCC_OscConfig+0x1b2>
 8000a90:	e77e      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
      __HAL_RCC_LSI_DISABLE();
 8000a92:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000a94:	2702      	movs	r7, #2
      __HAL_RCC_LSI_DISABLE();
 8000a96:	439a      	bics	r2, r3
 8000a98:	626a      	str	r2, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8000a9a:	f7ff fd6b 	bl	8000574 <HAL_GetTick>
 8000a9e:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000aa0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8000aa2:	423b      	tst	r3, r7
 8000aa4:	d100      	bne.n	8000aa8 <HAL_RCC_OscConfig+0x1dc>
 8000aa6:	e721      	b.n	80008ec <HAL_RCC_OscConfig+0x20>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8000aa8:	f7ff fd64 	bl	8000574 <HAL_GetTick>
 8000aac:	1b80      	subs	r0, r0, r6
 8000aae:	2802      	cmp	r0, #2
 8000ab0:	d9f6      	bls.n	8000aa0 <HAL_RCC_OscConfig+0x1d4>
 8000ab2:	e76d      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000ab4:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 8000ab6:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000ab8:	4d46      	ldr	r5, [pc, #280]	; (8000bd4 <HAL_RCC_OscConfig+0x308>)
 8000aba:	0552      	lsls	r2, r2, #21
 8000abc:	69eb      	ldr	r3, [r5, #28]
    FlagStatus       pwrclkchanged = RESET;
 8000abe:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8000ac0:	4213      	tst	r3, r2
 8000ac2:	d108      	bne.n	8000ad6 <HAL_RCC_OscConfig+0x20a>
      __HAL_RCC_PWR_CLK_ENABLE();
 8000ac4:	69eb      	ldr	r3, [r5, #28]
 8000ac6:	4313      	orrs	r3, r2
 8000ac8:	61eb      	str	r3, [r5, #28]
 8000aca:	69eb      	ldr	r3, [r5, #28]
 8000acc:	4013      	ands	r3, r2
 8000ace:	9303      	str	r3, [sp, #12]
 8000ad0:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 8000ad2:	2301      	movs	r3, #1
 8000ad4:	9300      	str	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000ad6:	2780      	movs	r7, #128	; 0x80
 8000ad8:	4e41      	ldr	r6, [pc, #260]	; (8000be0 <HAL_RCC_OscConfig+0x314>)
 8000ada:	007f      	lsls	r7, r7, #1
 8000adc:	6833      	ldr	r3, [r6, #0]
 8000ade:	423b      	tst	r3, r7
 8000ae0:	d006      	beq.n	8000af0 <HAL_RCC_OscConfig+0x224>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000ae2:	68a3      	ldr	r3, [r4, #8]
 8000ae4:	2b01      	cmp	r3, #1
 8000ae6:	d113      	bne.n	8000b10 <HAL_RCC_OscConfig+0x244>
 8000ae8:	6a2a      	ldr	r2, [r5, #32]
 8000aea:	4313      	orrs	r3, r2
 8000aec:	622b      	str	r3, [r5, #32]
 8000aee:	e030      	b.n	8000b52 <HAL_RCC_OscConfig+0x286>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8000af0:	6833      	ldr	r3, [r6, #0]
 8000af2:	433b      	orrs	r3, r7
 8000af4:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8000af6:	f7ff fd3d 	bl	8000574 <HAL_GetTick>
 8000afa:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8000afc:	6833      	ldr	r3, [r6, #0]
 8000afe:	423b      	tst	r3, r7
 8000b00:	d1ef      	bne.n	8000ae2 <HAL_RCC_OscConfig+0x216>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000b02:	f7ff fd37 	bl	8000574 <HAL_GetTick>
 8000b06:	9b01      	ldr	r3, [sp, #4]
 8000b08:	1ac0      	subs	r0, r0, r3
 8000b0a:	2864      	cmp	r0, #100	; 0x64
 8000b0c:	d9f6      	bls.n	8000afc <HAL_RCC_OscConfig+0x230>
 8000b0e:	e73f      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b10:	2201      	movs	r2, #1
 8000b12:	2b00      	cmp	r3, #0
 8000b14:	d114      	bne.n	8000b40 <HAL_RCC_OscConfig+0x274>
 8000b16:	6a2b      	ldr	r3, [r5, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b18:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b1a:	4393      	bics	r3, r2
 8000b1c:	622b      	str	r3, [r5, #32]
 8000b1e:	6a2b      	ldr	r3, [r5, #32]
 8000b20:	3203      	adds	r2, #3
 8000b22:	4393      	bics	r3, r2
 8000b24:	622b      	str	r3, [r5, #32]
      tickstart = HAL_GetTick();
 8000b26:	f7ff fd25 	bl	8000574 <HAL_GetTick>
 8000b2a:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b2c:	6a2b      	ldr	r3, [r5, #32]
 8000b2e:	423b      	tst	r3, r7
 8000b30:	d016      	beq.n	8000b60 <HAL_RCC_OscConfig+0x294>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000b32:	f7ff fd1f 	bl	8000574 <HAL_GetTick>
 8000b36:	4b2b      	ldr	r3, [pc, #172]	; (8000be4 <HAL_RCC_OscConfig+0x318>)
 8000b38:	1b80      	subs	r0, r0, r6
 8000b3a:	4298      	cmp	r0, r3
 8000b3c:	d9f6      	bls.n	8000b2c <HAL_RCC_OscConfig+0x260>
 8000b3e:	e727      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b40:	2b05      	cmp	r3, #5
 8000b42:	d116      	bne.n	8000b72 <HAL_RCC_OscConfig+0x2a6>
 8000b44:	6a29      	ldr	r1, [r5, #32]
 8000b46:	3b01      	subs	r3, #1
 8000b48:	430b      	orrs	r3, r1
 8000b4a:	622b      	str	r3, [r5, #32]
 8000b4c:	6a2b      	ldr	r3, [r5, #32]
 8000b4e:	431a      	orrs	r2, r3
 8000b50:	622a      	str	r2, [r5, #32]
      tickstart = HAL_GetTick();
 8000b52:	f7ff fd0f 	bl	8000574 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000b56:	2702      	movs	r7, #2
      tickstart = HAL_GetTick();
 8000b58:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000b5a:	6a2b      	ldr	r3, [r5, #32]
 8000b5c:	423b      	tst	r3, r7
 8000b5e:	d00f      	beq.n	8000b80 <HAL_RCC_OscConfig+0x2b4>
    if(pwrclkchanged == SET)
 8000b60:	9b00      	ldr	r3, [sp, #0]
 8000b62:	2b01      	cmp	r3, #1
 8000b64:	d000      	beq.n	8000b68 <HAL_RCC_OscConfig+0x29c>
 8000b66:	e6c5      	b.n	80008f4 <HAL_RCC_OscConfig+0x28>
      __HAL_RCC_PWR_CLK_DISABLE();
 8000b68:	69eb      	ldr	r3, [r5, #28]
 8000b6a:	4a1f      	ldr	r2, [pc, #124]	; (8000be8 <HAL_RCC_OscConfig+0x31c>)
 8000b6c:	4013      	ands	r3, r2
 8000b6e:	61eb      	str	r3, [r5, #28]
 8000b70:	e6c0      	b.n	80008f4 <HAL_RCC_OscConfig+0x28>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b72:	6a2b      	ldr	r3, [r5, #32]
 8000b74:	4393      	bics	r3, r2
 8000b76:	2204      	movs	r2, #4
 8000b78:	622b      	str	r3, [r5, #32]
 8000b7a:	6a2b      	ldr	r3, [r5, #32]
 8000b7c:	4393      	bics	r3, r2
 8000b7e:	e7b5      	b.n	8000aec <HAL_RCC_OscConfig+0x220>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000b80:	f7ff fcf8 	bl	8000574 <HAL_GetTick>
 8000b84:	4b17      	ldr	r3, [pc, #92]	; (8000be4 <HAL_RCC_OscConfig+0x318>)
 8000b86:	1b80      	subs	r0, r0, r6
 8000b88:	4298      	cmp	r0, r3
 8000b8a:	d9e6      	bls.n	8000b5a <HAL_RCC_OscConfig+0x28e>
 8000b8c:	e700      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000b8e:	f7ff fcf1 	bl	8000574 <HAL_GetTick>
 8000b92:	1b80      	subs	r0, r0, r6
 8000b94:	2802      	cmp	r0, #2
 8000b96:	d800      	bhi.n	8000b9a <HAL_RCC_OscConfig+0x2ce>
 8000b98:	e6bf      	b.n	800091a <HAL_RCC_OscConfig+0x4e>
 8000b9a:	e6f9      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 8000b9c:	3205      	adds	r2, #5
 8000b9e:	d103      	bne.n	8000ba8 <HAL_RCC_OscConfig+0x2dc>
      __HAL_RCC_HSI14ADC_ENABLE();
 8000ba0:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8000ba2:	439a      	bics	r2, r3
 8000ba4:	636a      	str	r2, [r5, #52]	; 0x34
 8000ba6:	e6bc      	b.n	8000922 <HAL_RCC_OscConfig+0x56>
      __HAL_RCC_HSI14ADC_DISABLE();
 8000ba8:	6b6a      	ldr	r2, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000baa:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 8000bac:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 8000bae:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 8000bb0:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 8000bb2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000bb4:	4393      	bics	r3, r2
 8000bb6:	636b      	str	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 8000bb8:	f7ff fcdc 	bl	8000574 <HAL_GetTick>
 8000bbc:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 8000bbe:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000bc0:	423b      	tst	r3, r7
 8000bc2:	d100      	bne.n	8000bc6 <HAL_RCC_OscConfig+0x2fa>
 8000bc4:	e6b4      	b.n	8000930 <HAL_RCC_OscConfig+0x64>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 8000bc6:	f7ff fcd5 	bl	8000574 <HAL_GetTick>
 8000bca:	1b80      	subs	r0, r0, r6
 8000bcc:	2802      	cmp	r0, #2
 8000bce:	d9f6      	bls.n	8000bbe <HAL_RCC_OscConfig+0x2f2>
 8000bd0:	e6de      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
 8000bd2:	46c0      	nop			; (mov r8, r8)
 8000bd4:	40021000 	.word	0x40021000
 8000bd8:	fffeffff 	.word	0xfffeffff
 8000bdc:	fffbffff 	.word	0xfffbffff
 8000be0:	40007000 	.word	0x40007000
 8000be4:	00001388 	.word	0x00001388
 8000be8:	efffffff 	.word	0xefffffff
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000bec:	200c      	movs	r0, #12
 8000bee:	4a34      	ldr	r2, [pc, #208]	; (8000cc0 <HAL_RCC_OscConfig+0x3f4>)
 8000bf0:	6851      	ldr	r1, [r2, #4]
 8000bf2:	0015      	movs	r5, r2
 8000bf4:	4001      	ands	r1, r0
 8000bf6:	2908      	cmp	r1, #8
 8000bf8:	d047      	beq.n	8000c8a <HAL_RCC_OscConfig+0x3be>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000bfa:	4a32      	ldr	r2, [pc, #200]	; (8000cc4 <HAL_RCC_OscConfig+0x3f8>)
 8000bfc:	2b02      	cmp	r3, #2
 8000bfe:	d132      	bne.n	8000c66 <HAL_RCC_OscConfig+0x39a>
        __HAL_RCC_PLL_DISABLE();
 8000c00:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c02:	2780      	movs	r7, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8000c04:	4013      	ands	r3, r2
 8000c06:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000c08:	f7ff fcb4 	bl	8000574 <HAL_GetTick>
 8000c0c:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c0e:	04bf      	lsls	r7, r7, #18
 8000c10:	682b      	ldr	r3, [r5, #0]
 8000c12:	423b      	tst	r3, r7
 8000c14:	d121      	bne.n	8000c5a <HAL_RCC_OscConfig+0x38e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c16:	220f      	movs	r2, #15
 8000c18:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000c1a:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c1c:	4393      	bics	r3, r2
 8000c1e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000c20:	04b6      	lsls	r6, r6, #18
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000c22:	4313      	orrs	r3, r2
 8000c24:	62eb      	str	r3, [r5, #44]	; 0x2c
 8000c26:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8000c28:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000c2a:	686a      	ldr	r2, [r5, #4]
 8000c2c:	430b      	orrs	r3, r1
 8000c2e:	4926      	ldr	r1, [pc, #152]	; (8000cc8 <HAL_RCC_OscConfig+0x3fc>)
 8000c30:	400a      	ands	r2, r1
 8000c32:	4313      	orrs	r3, r2
 8000c34:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8000c36:	2380      	movs	r3, #128	; 0x80
 8000c38:	682a      	ldr	r2, [r5, #0]
 8000c3a:	045b      	lsls	r3, r3, #17
 8000c3c:	4313      	orrs	r3, r2
 8000c3e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000c40:	f7ff fc98 	bl	8000574 <HAL_GetTick>
 8000c44:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000c46:	682b      	ldr	r3, [r5, #0]
 8000c48:	4233      	tst	r3, r6
 8000c4a:	d000      	beq.n	8000c4e <HAL_RCC_OscConfig+0x382>
 8000c4c:	e674      	b.n	8000938 <HAL_RCC_OscConfig+0x6c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000c4e:	f7ff fc91 	bl	8000574 <HAL_GetTick>
 8000c52:	1b00      	subs	r0, r0, r4
 8000c54:	2802      	cmp	r0, #2
 8000c56:	d9f6      	bls.n	8000c46 <HAL_RCC_OscConfig+0x37a>
 8000c58:	e69a      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000c5a:	f7ff fc8b 	bl	8000574 <HAL_GetTick>
 8000c5e:	1b80      	subs	r0, r0, r6
 8000c60:	2802      	cmp	r0, #2
 8000c62:	d9d5      	bls.n	8000c10 <HAL_RCC_OscConfig+0x344>
 8000c64:	e694      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
        __HAL_RCC_PLL_DISABLE();
 8000c66:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c68:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8000c6a:	4013      	ands	r3, r2
 8000c6c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8000c6e:	f7ff fc81 	bl	8000574 <HAL_GetTick>
 8000c72:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000c74:	04b6      	lsls	r6, r6, #18
 8000c76:	682b      	ldr	r3, [r5, #0]
 8000c78:	4233      	tst	r3, r6
 8000c7a:	d100      	bne.n	8000c7e <HAL_RCC_OscConfig+0x3b2>
 8000c7c:	e65c      	b.n	8000938 <HAL_RCC_OscConfig+0x6c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000c7e:	f7ff fc79 	bl	8000574 <HAL_GetTick>
 8000c82:	1b00      	subs	r0, r0, r4
 8000c84:	2802      	cmp	r0, #2
 8000c86:	d9f6      	bls.n	8000c76 <HAL_RCC_OscConfig+0x3aa>
 8000c88:	e682      	b.n	8000990 <HAL_RCC_OscConfig+0xc4>
        return HAL_ERROR;
 8000c8a:	0018      	movs	r0, r3
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8000c8c:	2b01      	cmp	r3, #1
 8000c8e:	d100      	bne.n	8000c92 <HAL_RCC_OscConfig+0x3c6>
 8000c90:	e67f      	b.n	8000992 <HAL_RCC_OscConfig+0xc6>
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000c92:	2180      	movs	r1, #128	; 0x80
        pll_config  = RCC->CFGR;
 8000c94:	6853      	ldr	r3, [r2, #4]
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000c96:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000c98:	0249      	lsls	r1, r1, #9
        pll_config2 = RCC->CFGR2;
 8000c9a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000c9c:	4019      	ands	r1, r3
 8000c9e:	4281      	cmp	r1, r0
 8000ca0:	d000      	beq.n	8000ca4 <HAL_RCC_OscConfig+0x3d8>
 8000ca2:	e65e      	b.n	8000962 <HAL_RCC_OscConfig+0x96>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 8000ca4:	210f      	movs	r1, #15
 8000ca6:	400a      	ands	r2, r1
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8000ca8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000caa:	428a      	cmp	r2, r1
 8000cac:	d000      	beq.n	8000cb0 <HAL_RCC_OscConfig+0x3e4>
 8000cae:	e658      	b.n	8000962 <HAL_RCC_OscConfig+0x96>
           (READ_BIT(pll_config,  RCC_CFGR_PLLMUL)  != RCC_OscInitStruct->PLL.PLLMUL))
 8000cb0:	22f0      	movs	r2, #240	; 0xf0
 8000cb2:	0392      	lsls	r2, r2, #14
 8000cb4:	4013      	ands	r3, r2
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 8000cb6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000cb8:	4293      	cmp	r3, r2
 8000cba:	d100      	bne.n	8000cbe <HAL_RCC_OscConfig+0x3f2>
 8000cbc:	e63c      	b.n	8000938 <HAL_RCC_OscConfig+0x6c>
 8000cbe:	e650      	b.n	8000962 <HAL_RCC_OscConfig+0x96>
 8000cc0:	40021000 	.word	0x40021000
 8000cc4:	feffffff 	.word	0xfeffffff
 8000cc8:	ffc2ffff 	.word	0xffc2ffff

08000ccc <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000ccc:	b570      	push	{r4, r5, r6, lr}
 8000cce:	b088      	sub	sp, #32
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000cd0:	2210      	movs	r2, #16
 8000cd2:	4912      	ldr	r1, [pc, #72]	; (8000d1c <HAL_RCC_GetSysClockFreq+0x50>)
 8000cd4:	4668      	mov	r0, sp
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000cd6:	ad04      	add	r5, sp, #16
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 8000cd8:	f001 fdf2 	bl	80028c0 <memcpy>
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 8000cdc:	2210      	movs	r2, #16
 8000cde:	0028      	movs	r0, r5
 8000ce0:	490f      	ldr	r1, [pc, #60]	; (8000d20 <HAL_RCC_GetSysClockFreq+0x54>)
 8000ce2:	f001 fded 	bl	80028c0 <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000ce6:	220c      	movs	r2, #12
  tmpreg = RCC->CFGR;
 8000ce8:	4e0e      	ldr	r6, [pc, #56]	; (8000d24 <HAL_RCC_GetSysClockFreq+0x58>)
 8000cea:	6873      	ldr	r3, [r6, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8000cec:	401a      	ands	r2, r3
 8000cee:	2a08      	cmp	r2, #8
 8000cf0:	d111      	bne.n	8000d16 <HAL_RCC_GetSysClockFreq+0x4a>
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8000cf2:	200f      	movs	r0, #15
 8000cf4:	466a      	mov	r2, sp
 8000cf6:	0c99      	lsrs	r1, r3, #18
 8000cf8:	4001      	ands	r1, r0
 8000cfa:	5c54      	ldrb	r4, [r2, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8000cfc:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8000cfe:	4002      	ands	r2, r0
 8000d00:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 8000d02:	03db      	lsls	r3, r3, #15
 8000d04:	d505      	bpl.n	8000d12 <HAL_RCC_GetSysClockFreq+0x46>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSE_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 8000d06:	4808      	ldr	r0, [pc, #32]	; (8000d28 <HAL_RCC_GetSysClockFreq+0x5c>)
 8000d08:	f7ff fa08 	bl	800011c <__udivsi3>
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
#else
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 8000d0c:	4360      	muls	r0, r4
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000d0e:	b008      	add	sp, #32
 8000d10:	bd70      	pop	{r4, r5, r6, pc}
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 8000d12:	4806      	ldr	r0, [pc, #24]	; (8000d2c <HAL_RCC_GetSysClockFreq+0x60>)
 8000d14:	e7fa      	b.n	8000d0c <HAL_RCC_GetSysClockFreq+0x40>
      sysclockfreq = HSE_VALUE;
 8000d16:	4804      	ldr	r0, [pc, #16]	; (8000d28 <HAL_RCC_GetSysClockFreq+0x5c>)
  return sysclockfreq;
 8000d18:	e7f9      	b.n	8000d0e <HAL_RCC_GetSysClockFreq+0x42>
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	08002920 	.word	0x08002920
 8000d20:	08002931 	.word	0x08002931
 8000d24:	40021000 	.word	0x40021000
 8000d28:	007a1200 	.word	0x007a1200
 8000d2c:	003d0900 	.word	0x003d0900

08000d30 <HAL_RCC_ClockConfig>:
{
 8000d30:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8000d32:	0005      	movs	r5, r0
 8000d34:	000e      	movs	r6, r1
  if(RCC_ClkInitStruct == NULL)
 8000d36:	2800      	cmp	r0, #0
 8000d38:	d101      	bne.n	8000d3e <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 8000d3a:	2001      	movs	r0, #1
}
 8000d3c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8000d3e:	2201      	movs	r2, #1
 8000d40:	4c37      	ldr	r4, [pc, #220]	; (8000e20 <HAL_RCC_ClockConfig+0xf0>)
 8000d42:	6823      	ldr	r3, [r4, #0]
 8000d44:	4013      	ands	r3, r2
 8000d46:	428b      	cmp	r3, r1
 8000d48:	d31c      	bcc.n	8000d84 <HAL_RCC_ClockConfig+0x54>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000d4a:	6829      	ldr	r1, [r5, #0]
 8000d4c:	078b      	lsls	r3, r1, #30
 8000d4e:	d422      	bmi.n	8000d96 <HAL_RCC_ClockConfig+0x66>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000d50:	07cb      	lsls	r3, r1, #31
 8000d52:	d42f      	bmi.n	8000db4 <HAL_RCC_ClockConfig+0x84>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8000d54:	2301      	movs	r3, #1
 8000d56:	6822      	ldr	r2, [r4, #0]
 8000d58:	401a      	ands	r2, r3
 8000d5a:	42b2      	cmp	r2, r6
 8000d5c:	d851      	bhi.n	8000e02 <HAL_RCC_ClockConfig+0xd2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000d5e:	682b      	ldr	r3, [r5, #0]
 8000d60:	4c30      	ldr	r4, [pc, #192]	; (8000e24 <HAL_RCC_ClockConfig+0xf4>)
 8000d62:	075b      	lsls	r3, r3, #29
 8000d64:	d454      	bmi.n	8000e10 <HAL_RCC_ClockConfig+0xe0>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8000d66:	f7ff ffb1 	bl	8000ccc <HAL_RCC_GetSysClockFreq>
 8000d6a:	6863      	ldr	r3, [r4, #4]
 8000d6c:	4a2e      	ldr	r2, [pc, #184]	; (8000e28 <HAL_RCC_ClockConfig+0xf8>)
 8000d6e:	061b      	lsls	r3, r3, #24
 8000d70:	0f1b      	lsrs	r3, r3, #28
 8000d72:	5cd3      	ldrb	r3, [r2, r3]
 8000d74:	40d8      	lsrs	r0, r3
 8000d76:	4b2d      	ldr	r3, [pc, #180]	; (8000e2c <HAL_RCC_ClockConfig+0xfc>)
 8000d78:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8000d7a:	2000      	movs	r0, #0
 8000d7c:	f7ff fb54 	bl	8000428 <HAL_InitTick>
  return HAL_OK;
 8000d80:	2000      	movs	r0, #0
 8000d82:	e7db      	b.n	8000d3c <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000d84:	6823      	ldr	r3, [r4, #0]
 8000d86:	4393      	bics	r3, r2
 8000d88:	430b      	orrs	r3, r1
 8000d8a:	6023      	str	r3, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000d8c:	6823      	ldr	r3, [r4, #0]
 8000d8e:	4013      	ands	r3, r2
 8000d90:	428b      	cmp	r3, r1
 8000d92:	d1d2      	bne.n	8000d3a <HAL_RCC_ClockConfig+0xa>
 8000d94:	e7d9      	b.n	8000d4a <HAL_RCC_ClockConfig+0x1a>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000d96:	4a23      	ldr	r2, [pc, #140]	; (8000e24 <HAL_RCC_ClockConfig+0xf4>)
 8000d98:	074b      	lsls	r3, r1, #29
 8000d9a:	d504      	bpl.n	8000da6 <HAL_RCC_ClockConfig+0x76>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 8000d9c:	23e0      	movs	r3, #224	; 0xe0
 8000d9e:	6850      	ldr	r0, [r2, #4]
 8000da0:	00db      	lsls	r3, r3, #3
 8000da2:	4303      	orrs	r3, r0
 8000da4:	6053      	str	r3, [r2, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000da6:	20f0      	movs	r0, #240	; 0xf0
 8000da8:	6853      	ldr	r3, [r2, #4]
 8000daa:	4383      	bics	r3, r0
 8000dac:	68a8      	ldr	r0, [r5, #8]
 8000dae:	4303      	orrs	r3, r0
 8000db0:	6053      	str	r3, [r2, #4]
 8000db2:	e7cd      	b.n	8000d50 <HAL_RCC_ClockConfig+0x20>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000db4:	4f1b      	ldr	r7, [pc, #108]	; (8000e24 <HAL_RCC_ClockConfig+0xf4>)
 8000db6:	686a      	ldr	r2, [r5, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000db8:	683b      	ldr	r3, [r7, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000dba:	2a01      	cmp	r2, #1
 8000dbc:	d119      	bne.n	8000df2 <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000dbe:	039b      	lsls	r3, r3, #14
 8000dc0:	d5bb      	bpl.n	8000d3a <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000dc2:	2103      	movs	r1, #3
 8000dc4:	687b      	ldr	r3, [r7, #4]
 8000dc6:	438b      	bics	r3, r1
 8000dc8:	4313      	orrs	r3, r2
 8000dca:	607b      	str	r3, [r7, #4]
    tickstart = HAL_GetTick();
 8000dcc:	f7ff fbd2 	bl	8000574 <HAL_GetTick>
 8000dd0:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8000dd2:	230c      	movs	r3, #12
 8000dd4:	687a      	ldr	r2, [r7, #4]
 8000dd6:	401a      	ands	r2, r3
 8000dd8:	686b      	ldr	r3, [r5, #4]
 8000dda:	009b      	lsls	r3, r3, #2
 8000ddc:	429a      	cmp	r2, r3
 8000dde:	d0b9      	beq.n	8000d54 <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000de0:	f7ff fbc8 	bl	8000574 <HAL_GetTick>
 8000de4:	9b01      	ldr	r3, [sp, #4]
 8000de6:	1ac0      	subs	r0, r0, r3
 8000de8:	4b11      	ldr	r3, [pc, #68]	; (8000e30 <HAL_RCC_ClockConfig+0x100>)
 8000dea:	4298      	cmp	r0, r3
 8000dec:	d9f1      	bls.n	8000dd2 <HAL_RCC_ClockConfig+0xa2>
        return HAL_TIMEOUT;
 8000dee:	2003      	movs	r0, #3
 8000df0:	e7a4      	b.n	8000d3c <HAL_RCC_ClockConfig+0xc>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000df2:	2a02      	cmp	r2, #2
 8000df4:	d102      	bne.n	8000dfc <HAL_RCC_ClockConfig+0xcc>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8000df6:	019b      	lsls	r3, r3, #6
 8000df8:	d4e3      	bmi.n	8000dc2 <HAL_RCC_ClockConfig+0x92>
 8000dfa:	e79e      	b.n	8000d3a <HAL_RCC_ClockConfig+0xa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000dfc:	079b      	lsls	r3, r3, #30
 8000dfe:	d4e0      	bmi.n	8000dc2 <HAL_RCC_ClockConfig+0x92>
 8000e00:	e79b      	b.n	8000d3a <HAL_RCC_ClockConfig+0xa>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000e02:	6822      	ldr	r2, [r4, #0]
 8000e04:	439a      	bics	r2, r3
 8000e06:	6022      	str	r2, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8000e08:	6822      	ldr	r2, [r4, #0]
 8000e0a:	421a      	tst	r2, r3
 8000e0c:	d0a7      	beq.n	8000d5e <HAL_RCC_ClockConfig+0x2e>
 8000e0e:	e794      	b.n	8000d3a <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8000e10:	6863      	ldr	r3, [r4, #4]
 8000e12:	4a08      	ldr	r2, [pc, #32]	; (8000e34 <HAL_RCC_ClockConfig+0x104>)
 8000e14:	4013      	ands	r3, r2
 8000e16:	68ea      	ldr	r2, [r5, #12]
 8000e18:	4313      	orrs	r3, r2
 8000e1a:	6063      	str	r3, [r4, #4]
 8000e1c:	e7a3      	b.n	8000d66 <HAL_RCC_ClockConfig+0x36>
 8000e1e:	46c0      	nop			; (mov r8, r8)
 8000e20:	40022000 	.word	0x40022000
 8000e24:	40021000 	.word	0x40021000
 8000e28:	08002908 	.word	0x08002908
 8000e2c:	20000000 	.word	0x20000000
 8000e30:	00001388 	.word	0x00001388
 8000e34:	fffff8ff 	.word	0xfffff8ff

08000e38 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 8000e38:	4b04      	ldr	r3, [pc, #16]	; (8000e4c <HAL_RCC_GetPCLK1Freq+0x14>)
 8000e3a:	4a05      	ldr	r2, [pc, #20]	; (8000e50 <HAL_RCC_GetPCLK1Freq+0x18>)
 8000e3c:	685b      	ldr	r3, [r3, #4]
 8000e3e:	055b      	lsls	r3, r3, #21
 8000e40:	0f5b      	lsrs	r3, r3, #29
 8000e42:	5cd3      	ldrb	r3, [r2, r3]
 8000e44:	4a03      	ldr	r2, [pc, #12]	; (8000e54 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8000e46:	6810      	ldr	r0, [r2, #0]
 8000e48:	40d8      	lsrs	r0, r3
}    
 8000e4a:	4770      	bx	lr
 8000e4c:	40021000 	.word	0x40021000
 8000e50:	08002918 	.word	0x08002918
 8000e54:	20000000 	.word	0x20000000

08000e58 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000e58:	2307      	movs	r3, #7
{
 8000e5a:	b510      	push	{r4, lr}
  
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000e5c:	2403      	movs	r4, #3
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 8000e5e:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8000e60:	4b09      	ldr	r3, [pc, #36]	; (8000e88 <HAL_RCC_GetClockConfig+0x30>)
 8000e62:	685a      	ldr	r2, [r3, #4]
 8000e64:	4022      	ands	r2, r4
 8000e66:	6042      	str	r2, [r0, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8000e68:	685a      	ldr	r2, [r3, #4]
 8000e6a:	34ed      	adds	r4, #237	; 0xed
 8000e6c:	4022      	ands	r2, r4
 8000e6e:	6082      	str	r2, [r0, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000e70:	22e0      	movs	r2, #224	; 0xe0
 8000e72:	685b      	ldr	r3, [r3, #4]
 8000e74:	00d2      	lsls	r2, r2, #3
 8000e76:	4013      	ands	r3, r2
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 8000e78:	2201      	movs	r2, #1
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 8000e7a:	60c3      	str	r3, [r0, #12]
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 8000e7c:	4b03      	ldr	r3, [pc, #12]	; (8000e8c <HAL_RCC_GetClockConfig+0x34>)
 8000e7e:	681b      	ldr	r3, [r3, #0]
 8000e80:	4013      	ands	r3, r2
 8000e82:	600b      	str	r3, [r1, #0]
}
 8000e84:	bd10      	pop	{r4, pc}
 8000e86:	46c0      	nop			; (mov r8, r8)
 8000e88:	40021000 	.word	0x40021000
 8000e8c:	40022000 	.word	0x40022000

08000e90 <SPI_WaitFlagStateUntilTimeout.constprop.0>:
  * @param  State flag state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 8000e90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e92:	000e      	movs	r6, r1
 8000e94:	b085      	sub	sp, #20
 8000e96:	0015      	movs	r5, r2
 8000e98:	0004      	movs	r4, r0
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8000e9a:	f7ff fb6b 	bl	8000574 <HAL_GetTick>
 8000e9e:	19ad      	adds	r5, r5, r6
 8000ea0:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 8000ea2:	f7ff fb67 	bl	8000574 <HAL_GetTick>

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8000ea6:	2780      	movs	r7, #128	; 0x80
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8000ea8:	4b25      	ldr	r3, [pc, #148]	; (8000f40 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xb0>)
  tmp_tickstart = HAL_GetTick();
 8000eaa:	9001      	str	r0, [sp, #4]
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8000eac:	681b      	ldr	r3, [r3, #0]
 8000eae:	015b      	lsls	r3, r3, #5
 8000eb0:	0d1b      	lsrs	r3, r3, #20
 8000eb2:	436b      	muls	r3, r5
 8000eb4:	9303      	str	r3, [sp, #12]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8000eb6:	6822      	ldr	r2, [r4, #0]
 8000eb8:	6893      	ldr	r3, [r2, #8]
 8000eba:	0018      	movs	r0, r3
 8000ebc:	4038      	ands	r0, r7
 8000ebe:	423b      	tst	r3, r7
 8000ec0:	d032      	beq.n	8000f28 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x98>
  {
    if (Timeout != HAL_MAX_DELAY)
 8000ec2:	1c73      	adds	r3, r6, #1
 8000ec4:	d0f8      	beq.n	8000eb8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x28>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8000ec6:	f7ff fb55 	bl	8000574 <HAL_GetTick>
 8000eca:	9b01      	ldr	r3, [sp, #4]
 8000ecc:	1ac0      	subs	r0, r0, r3
 8000ece:	42a8      	cmp	r0, r5
 8000ed0:	d32c      	bcc.n	8000f2c <SPI_WaitFlagStateUntilTimeout.constprop.0+0x9c>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8000ed2:	21e0      	movs	r1, #224	; 0xe0
 8000ed4:	6823      	ldr	r3, [r4, #0]
 8000ed6:	685a      	ldr	r2, [r3, #4]
 8000ed8:	438a      	bics	r2, r1
 8000eda:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8000edc:	2282      	movs	r2, #130	; 0x82
 8000ede:	6861      	ldr	r1, [r4, #4]
 8000ee0:	0052      	lsls	r2, r2, #1
 8000ee2:	4291      	cmp	r1, r2
 8000ee4:	d10c      	bne.n	8000f00 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x70>
 8000ee6:	2180      	movs	r1, #128	; 0x80
 8000ee8:	68a2      	ldr	r2, [r4, #8]
 8000eea:	0209      	lsls	r1, r1, #8
 8000eec:	428a      	cmp	r2, r1
 8000eee:	d003      	beq.n	8000ef8 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x68>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8000ef0:	2180      	movs	r1, #128	; 0x80
 8000ef2:	00c9      	lsls	r1, r1, #3
 8000ef4:	428a      	cmp	r2, r1
 8000ef6:	d103      	bne.n	8000f00 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x70>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8000ef8:	2140      	movs	r1, #64	; 0x40
 8000efa:	681a      	ldr	r2, [r3, #0]
 8000efc:	438a      	bics	r2, r1
 8000efe:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8000f00:	2180      	movs	r1, #128	; 0x80
 8000f02:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000f04:	0189      	lsls	r1, r1, #6
 8000f06:	428a      	cmp	r2, r1
 8000f08:	d106      	bne.n	8000f18 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x88>
        {
          SPI_RESET_CRC(hspi);
 8000f0a:	6819      	ldr	r1, [r3, #0]
 8000f0c:	480d      	ldr	r0, [pc, #52]	; (8000f44 <SPI_WaitFlagStateUntilTimeout.constprop.0+0xb4>)
 8000f0e:	4001      	ands	r1, r0
 8000f10:	6019      	str	r1, [r3, #0]
 8000f12:	6819      	ldr	r1, [r3, #0]
 8000f14:	430a      	orrs	r2, r1
 8000f16:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8000f18:	0023      	movs	r3, r4
 8000f1a:	2201      	movs	r2, #1
 8000f1c:	335d      	adds	r3, #93	; 0x5d
 8000f1e:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8000f20:	2300      	movs	r3, #0
 8000f22:	2003      	movs	r0, #3
 8000f24:	345c      	adds	r4, #92	; 0x5c
 8000f26:	7023      	strb	r3, [r4, #0]
      count--;
    }
  }

  return HAL_OK;
}
 8000f28:	b005      	add	sp, #20
 8000f2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if(count == 0U)
 8000f2c:	9b03      	ldr	r3, [sp, #12]
        tmp_timeout = 0U;
 8000f2e:	1e5a      	subs	r2, r3, #1
 8000f30:	4193      	sbcs	r3, r2
 8000f32:	425b      	negs	r3, r3
 8000f34:	401d      	ands	r5, r3
      count--;
 8000f36:	9b03      	ldr	r3, [sp, #12]
 8000f38:	3b01      	subs	r3, #1
 8000f3a:	9303      	str	r3, [sp, #12]
 8000f3c:	e7bb      	b.n	8000eb6 <SPI_WaitFlagStateUntilTimeout.constprop.0+0x26>
 8000f3e:	46c0      	nop			; (mov r8, r8)
 8000f40:	20000000 	.word	0x20000000
 8000f44:	ffffdfff 	.word	0xffffdfff

08000f48 <SPI_WaitFifoStateUntilTimeout.constprop.0>:
  * @param  State Fifo state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8000f48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000f4a:	0017      	movs	r7, r2
{
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;
  __IO uint8_t  * ptmpreg8;
  __IO uint8_t  tmpreg8 = 0;
 8000f4c:	2200      	movs	r2, #0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8000f4e:	b085      	sub	sp, #20
 8000f50:	001d      	movs	r5, r3
  __IO uint8_t  tmpreg8 = 0;
 8000f52:	ab02      	add	r3, sp, #8
 8000f54:	70da      	strb	r2, [r3, #3]
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8000f56:	0004      	movs	r4, r0
 8000f58:	000e      	movs	r6, r1

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 8000f5a:	f7ff fb0b 	bl	8000574 <HAL_GetTick>
 8000f5e:	19ed      	adds	r5, r5, r7
 8000f60:	1a2d      	subs	r5, r5, r0
  tmp_tickstart = HAL_GetTick();
 8000f62:	f7ff fb07 	bl	8000574 <HAL_GetTick>

  /* Initialize the 8bit temporary pointer */
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8000f66:	2223      	movs	r2, #35	; 0x23
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 8000f68:	6823      	ldr	r3, [r4, #0]
  tmp_tickstart = HAL_GetTick();
 8000f6a:	9000      	str	r0, [sp, #0]
  ptmpreg8 = (__IO uint8_t *)&hspi->Instance->DR;
 8000f6c:	9301      	str	r3, [sp, #4]
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8000f6e:	4b2a      	ldr	r3, [pc, #168]	; (8001018 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xd0>)
 8000f70:	681b      	ldr	r3, [r3, #0]
 8000f72:	4353      	muls	r3, r2
 8000f74:	0d1b      	lsrs	r3, r3, #20
 8000f76:	436b      	muls	r3, r5
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if(count == 0U)
      {
        tmp_timeout = 0U;
      }      
      count--;
 8000f78:	9303      	str	r3, [sp, #12]
  while ((hspi->Instance->SR & Fifo) != State)
 8000f7a:	6821      	ldr	r1, [r4, #0]
      tmpreg8 = *ptmpreg8;
 8000f7c:	ab02      	add	r3, sp, #8
 8000f7e:	1cda      	adds	r2, r3, #3
  while ((hspi->Instance->SR & Fifo) != State)
 8000f80:	688b      	ldr	r3, [r1, #8]
 8000f82:	0018      	movs	r0, r3
 8000f84:	4030      	ands	r0, r6
 8000f86:	4233      	tst	r3, r6
 8000f88:	d03b      	beq.n	8001002 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xba>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8000f8a:	23c0      	movs	r3, #192	; 0xc0
 8000f8c:	00db      	lsls	r3, r3, #3
 8000f8e:	429e      	cmp	r6, r3
 8000f90:	d104      	bne.n	8000f9c <SPI_WaitFifoStateUntilTimeout.constprop.0+0x54>
      tmpreg8 = *ptmpreg8;
 8000f92:	9b01      	ldr	r3, [sp, #4]
 8000f94:	7b1b      	ldrb	r3, [r3, #12]
 8000f96:	b2db      	uxtb	r3, r3
 8000f98:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg8);
 8000f9a:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 8000f9c:	1c7b      	adds	r3, r7, #1
 8000f9e:	d0ef      	beq.n	8000f80 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x38>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8000fa0:	f7ff fae8 	bl	8000574 <HAL_GetTick>
 8000fa4:	9b00      	ldr	r3, [sp, #0]
 8000fa6:	1ac0      	subs	r0, r0, r3
 8000fa8:	42a8      	cmp	r0, r5
 8000faa:	d32c      	bcc.n	8001006 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xbe>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8000fac:	21e0      	movs	r1, #224	; 0xe0
 8000fae:	6823      	ldr	r3, [r4, #0]
 8000fb0:	685a      	ldr	r2, [r3, #4]
 8000fb2:	438a      	bics	r2, r1
 8000fb4:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8000fb6:	2282      	movs	r2, #130	; 0x82
 8000fb8:	6861      	ldr	r1, [r4, #4]
 8000fba:	0052      	lsls	r2, r2, #1
 8000fbc:	4291      	cmp	r1, r2
 8000fbe:	d10c      	bne.n	8000fda <SPI_WaitFifoStateUntilTimeout.constprop.0+0x92>
 8000fc0:	2180      	movs	r1, #128	; 0x80
 8000fc2:	68a2      	ldr	r2, [r4, #8]
 8000fc4:	0209      	lsls	r1, r1, #8
 8000fc6:	428a      	cmp	r2, r1
 8000fc8:	d003      	beq.n	8000fd2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x8a>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8000fca:	2180      	movs	r1, #128	; 0x80
 8000fcc:	00c9      	lsls	r1, r1, #3
 8000fce:	428a      	cmp	r2, r1
 8000fd0:	d103      	bne.n	8000fda <SPI_WaitFifoStateUntilTimeout.constprop.0+0x92>
          __HAL_SPI_DISABLE(hspi);
 8000fd2:	2140      	movs	r1, #64	; 0x40
 8000fd4:	681a      	ldr	r2, [r3, #0]
 8000fd6:	438a      	bics	r2, r1
 8000fd8:	601a      	str	r2, [r3, #0]
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8000fda:	2180      	movs	r1, #128	; 0x80
 8000fdc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8000fde:	0189      	lsls	r1, r1, #6
 8000fe0:	428a      	cmp	r2, r1
 8000fe2:	d106      	bne.n	8000ff2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xaa>
          SPI_RESET_CRC(hspi);
 8000fe4:	6819      	ldr	r1, [r3, #0]
 8000fe6:	480d      	ldr	r0, [pc, #52]	; (800101c <SPI_WaitFifoStateUntilTimeout.constprop.0+0xd4>)
 8000fe8:	4001      	ands	r1, r0
 8000fea:	6019      	str	r1, [r3, #0]
 8000fec:	6819      	ldr	r1, [r3, #0]
 8000fee:	430a      	orrs	r2, r1
 8000ff0:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8000ff2:	0023      	movs	r3, r4
 8000ff4:	2201      	movs	r2, #1
 8000ff6:	335d      	adds	r3, #93	; 0x5d
 8000ff8:	701a      	strb	r2, [r3, #0]
        __HAL_UNLOCK(hspi);
 8000ffa:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 8000ffc:	2003      	movs	r0, #3
        __HAL_UNLOCK(hspi);
 8000ffe:	345c      	adds	r4, #92	; 0x5c
 8001000:	7023      	strb	r3, [r4, #0]
    }
  }

  return HAL_OK;
}
 8001002:	b005      	add	sp, #20
 8001004:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if(count == 0U)
 8001006:	9b03      	ldr	r3, [sp, #12]
        tmp_timeout = 0U;
 8001008:	1e5a      	subs	r2, r3, #1
 800100a:	4193      	sbcs	r3, r2
 800100c:	425b      	negs	r3, r3
 800100e:	401d      	ands	r5, r3
      count--;
 8001010:	9b03      	ldr	r3, [sp, #12]
 8001012:	3b01      	subs	r3, #1
 8001014:	e7b0      	b.n	8000f78 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x30>
 8001016:	46c0      	nop			; (mov r8, r8)
 8001018:	20000000 	.word	0x20000000
 800101c:	ffffdfff 	.word	0xffffdfff

08001020 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001020:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001022:	0013      	movs	r3, r2
{
 8001024:	000d      	movs	r5, r1
 8001026:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001028:	000a      	movs	r2, r1
 800102a:	21c0      	movs	r1, #192	; 0xc0
 800102c:	0149      	lsls	r1, r1, #5
{
 800102e:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001030:	f7ff ff8a 	bl	8000f48 <SPI_WaitFifoStateUntilTimeout.constprop.0>
 8001034:	2800      	cmp	r0, #0
 8001036:	d005      	beq.n	8001044 <SPI_EndRxTxTransaction+0x24>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001038:	2320      	movs	r3, #32
 800103a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800103c:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800103e:	4313      	orrs	r3, r2
 8001040:	6623      	str	r3, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8001042:	e00f      	b.n	8001064 <SPI_EndRxTxTransaction+0x44>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001044:	0032      	movs	r2, r6
 8001046:	0029      	movs	r1, r5
 8001048:	0020      	movs	r0, r4
 800104a:	f7ff ff21 	bl	8000e90 <SPI_WaitFlagStateUntilTimeout.constprop.0>
 800104e:	2800      	cmp	r0, #0
 8001050:	d1f2      	bne.n	8001038 <SPI_EndRxTxTransaction+0x18>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8001052:	21c0      	movs	r1, #192	; 0xc0
 8001054:	0033      	movs	r3, r6
 8001056:	002a      	movs	r2, r5
 8001058:	0020      	movs	r0, r4
 800105a:	00c9      	lsls	r1, r1, #3
 800105c:	f7ff ff74 	bl	8000f48 <SPI_WaitFifoStateUntilTimeout.constprop.0>
 8001060:	2800      	cmp	r0, #0
 8001062:	d1e9      	bne.n	8001038 <SPI_EndRxTxTransaction+0x18>
  }

  return HAL_OK;
}
 8001064:	bd70      	pop	{r4, r5, r6, pc}
	...

08001068 <HAL_SPI_Init>:
{
 8001068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800106a:	0004      	movs	r4, r0
    return HAL_ERROR;
 800106c:	2001      	movs	r0, #1
  if (hspi == NULL)
 800106e:	2c00      	cmp	r4, #0
 8001070:	d067      	beq.n	8001142 <HAL_SPI_Init+0xda>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8001072:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001074:	2b00      	cmp	r3, #0
 8001076:	d165      	bne.n	8001144 <HAL_SPI_Init+0xdc>
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8001078:	2282      	movs	r2, #130	; 0x82
 800107a:	6861      	ldr	r1, [r4, #4]
 800107c:	0052      	lsls	r2, r2, #1
 800107e:	4291      	cmp	r1, r2
 8001080:	d000      	beq.n	8001084 <HAL_SPI_Init+0x1c>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8001082:	61e3      	str	r3, [r4, #28]
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001084:	2300      	movs	r3, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8001086:	0025      	movs	r5, r4
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001088:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 800108a:	355d      	adds	r5, #93	; 0x5d
 800108c:	782b      	ldrb	r3, [r5, #0]
 800108e:	b2da      	uxtb	r2, r3
 8001090:	2b00      	cmp	r3, #0
 8001092:	d105      	bne.n	80010a0 <HAL_SPI_Init+0x38>
    hspi->Lock = HAL_UNLOCKED;
 8001094:	0023      	movs	r3, r4
 8001096:	335c      	adds	r3, #92	; 0x5c
    HAL_SPI_MspInit(hspi);
 8001098:	0020      	movs	r0, r4
    hspi->Lock = HAL_UNLOCKED;
 800109a:	701a      	strb	r2, [r3, #0]
    HAL_SPI_MspInit(hspi);
 800109c:	f7ff f978 	bl	8000390 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 80010a0:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 80010a2:	2140      	movs	r1, #64	; 0x40
  hspi->State = HAL_SPI_STATE_BUSY;
 80010a4:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 80010a6:	6822      	ldr	r2, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80010a8:	68e5      	ldr	r5, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 80010aa:	6813      	ldr	r3, [r2, #0]
 80010ac:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80010ae:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 80010b0:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80010b2:	00c9      	lsls	r1, r1, #3
 80010b4:	2300      	movs	r3, #0
 80010b6:	428d      	cmp	r5, r1
 80010b8:	d848      	bhi.n	800114c <HAL_SPI_Init+0xe4>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80010ba:	2080      	movs	r0, #128	; 0x80
 80010bc:	0140      	lsls	r0, r0, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80010be:	428d      	cmp	r5, r1
 80010c0:	d000      	beq.n	80010c4 <HAL_SPI_Init+0x5c>
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80010c2:	62a3      	str	r3, [r4, #40]	; 0x28
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80010c4:	2382      	movs	r3, #130	; 0x82
 80010c6:	6866      	ldr	r6, [r4, #4]
 80010c8:	005b      	lsls	r3, r3, #1
 80010ca:	4033      	ands	r3, r6
 80010cc:	2684      	movs	r6, #132	; 0x84
 80010ce:	68a7      	ldr	r7, [r4, #8]
 80010d0:	0236      	lsls	r6, r6, #8
 80010d2:	403e      	ands	r6, r7
 80010d4:	4333      	orrs	r3, r6
 80010d6:	2602      	movs	r6, #2
 80010d8:	6927      	ldr	r7, [r4, #16]
 80010da:	69a1      	ldr	r1, [r4, #24]
 80010dc:	403e      	ands	r6, r7
 80010de:	4333      	orrs	r3, r6
 80010e0:	2601      	movs	r6, #1
 80010e2:	6967      	ldr	r7, [r4, #20]
 80010e4:	46b4      	mov	ip, r6
 80010e6:	4037      	ands	r7, r6
 80010e8:	433b      	orrs	r3, r7
 80010ea:	2780      	movs	r7, #128	; 0x80
 80010ec:	00bf      	lsls	r7, r7, #2
 80010ee:	400f      	ands	r7, r1
 80010f0:	433b      	orrs	r3, r7
 80010f2:	2738      	movs	r7, #56	; 0x38
 80010f4:	69e6      	ldr	r6, [r4, #28]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80010f6:	0c09      	lsrs	r1, r1, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80010f8:	4037      	ands	r7, r6
 80010fa:	433b      	orrs	r3, r7
 80010fc:	2780      	movs	r7, #128	; 0x80
 80010fe:	6a26      	ldr	r6, [r4, #32]
 8001100:	4037      	ands	r7, r6
 8001102:	433b      	orrs	r3, r7
 8001104:	2780      	movs	r7, #128	; 0x80
 8001106:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8001108:	01bf      	lsls	r7, r7, #6
 800110a:	4037      	ands	r7, r6
 800110c:	433b      	orrs	r3, r7
 800110e:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8001110:	2310      	movs	r3, #16
 8001112:	2708      	movs	r7, #8
 8001114:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8001116:	4033      	ands	r3, r6
 8001118:	6b66      	ldr	r6, [r4, #52]	; 0x34
 800111a:	4037      	ands	r7, r6
 800111c:	433b      	orrs	r3, r7
 800111e:	27f0      	movs	r7, #240	; 0xf0
 8001120:	013f      	lsls	r7, r7, #4
 8001122:	403d      	ands	r5, r7
 8001124:	431d      	orrs	r5, r3
 8001126:	2304      	movs	r3, #4
 8001128:	4019      	ands	r1, r3
 800112a:	4329      	orrs	r1, r5
 800112c:	4308      	orrs	r0, r1
 800112e:	6050      	str	r0, [r2, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8001130:	69d3      	ldr	r3, [r2, #28]
 8001132:	4908      	ldr	r1, [pc, #32]	; (8001154 <HAL_SPI_Init+0xec>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8001134:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8001136:	400b      	ands	r3, r1
 8001138:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 800113a:	4663      	mov	r3, ip
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800113c:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 800113e:	345d      	adds	r4, #93	; 0x5d
 8001140:	7023      	strb	r3, [r4, #0]
}
 8001142:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8001144:	2300      	movs	r3, #0
 8001146:	6123      	str	r3, [r4, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8001148:	6163      	str	r3, [r4, #20]
 800114a:	e79b      	b.n	8001084 <HAL_SPI_Init+0x1c>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800114c:	21f0      	movs	r1, #240	; 0xf0
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800114e:	0018      	movs	r0, r3
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8001150:	0109      	lsls	r1, r1, #4
 8001152:	e7b4      	b.n	80010be <HAL_SPI_Init+0x56>
 8001154:	fffff7ff 	.word	0xfffff7ff

08001158 <HAL_SPI_Transmit_DMA>:
{
 8001158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 800115a:	0006      	movs	r6, r0
 800115c:	365c      	adds	r6, #92	; 0x5c
 800115e:	7833      	ldrb	r3, [r6, #0]
{
 8001160:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8001162:	2502      	movs	r5, #2
 8001164:	2b01      	cmp	r3, #1
 8001166:	d05b      	beq.n	8001220 <HAL_SPI_Transmit_DMA+0xc8>
 8001168:	2301      	movs	r3, #1
 800116a:	7033      	strb	r3, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 800116c:	0003      	movs	r3, r0
 800116e:	335d      	adds	r3, #93	; 0x5d
 8001170:	7818      	ldrb	r0, [r3, #0]
 8001172:	b2c5      	uxtb	r5, r0
 8001174:	2801      	cmp	r0, #1
 8001176:	d000      	beq.n	800117a <HAL_SPI_Transmit_DMA+0x22>
 8001178:	e06f      	b.n	800125a <HAL_SPI_Transmit_DMA+0x102>
  if ((pData == NULL) || (Size == 0U))
 800117a:	2900      	cmp	r1, #0
 800117c:	d04e      	beq.n	800121c <HAL_SPI_Transmit_DMA+0xc4>
 800117e:	2a00      	cmp	r2, #0
 8001180:	d04c      	beq.n	800121c <HAL_SPI_Transmit_DMA+0xc4>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001182:	3002      	adds	r0, #2
 8001184:	7018      	strb	r0, [r3, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001186:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 8001188:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800118a:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 800118c:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 800118e:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001190:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8001192:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8001194:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001196:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8001198:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 800119a:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800119c:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800119e:	2380      	movs	r3, #128	; 0x80
 80011a0:	68a0      	ldr	r0, [r4, #8]
 80011a2:	6822      	ldr	r2, [r4, #0]
 80011a4:	021b      	lsls	r3, r3, #8
 80011a6:	4298      	cmp	r0, r3
 80011a8:	d108      	bne.n	80011bc <HAL_SPI_Transmit_DMA+0x64>
    __HAL_SPI_DISABLE(hspi);
 80011aa:	2040      	movs	r0, #64	; 0x40
 80011ac:	6813      	ldr	r3, [r2, #0]
 80011ae:	4383      	bics	r3, r0
 80011b0:	6013      	str	r3, [r2, #0]
    SPI_1LINE_TX(hspi);
 80011b2:	2380      	movs	r3, #128	; 0x80
 80011b4:	6810      	ldr	r0, [r2, #0]
 80011b6:	01db      	lsls	r3, r3, #7
 80011b8:	4303      	orrs	r3, r0
 80011ba:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 80011bc:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80011be:	4b28      	ldr	r3, [pc, #160]	; (8001260 <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80011c0:	6857      	ldr	r7, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 80011c2:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 80011c4:	4b27      	ldr	r3, [pc, #156]	; (8001264 <HAL_SPI_Transmit_DMA+0x10c>)
 80011c6:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 80011c8:	4b27      	ldr	r3, [pc, #156]	; (8001268 <HAL_SPI_Transmit_DMA+0x110>)
 80011ca:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 80011cc:	2300      	movs	r3, #0
 80011ce:	6343      	str	r3, [r0, #52]	; 0x34
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80011d0:	4b26      	ldr	r3, [pc, #152]	; (800126c <HAL_SPI_Transmit_DMA+0x114>)
 80011d2:	401f      	ands	r7, r3
 80011d4:	469c      	mov	ip, r3
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80011d6:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80011d8:	6057      	str	r7, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80011da:	68e7      	ldr	r7, [r4, #12]
 80011dc:	00db      	lsls	r3, r3, #3
 80011de:	429f      	cmp	r7, r3
 80011e0:	d80e      	bhi.n	8001200 <HAL_SPI_Transmit_DMA+0xa8>
 80011e2:	2380      	movs	r3, #128	; 0x80
 80011e4:	6947      	ldr	r7, [r0, #20]
 80011e6:	00db      	lsls	r3, r3, #3
 80011e8:	429f      	cmp	r7, r3
 80011ea:	d109      	bne.n	8001200 <HAL_SPI_Transmit_DMA+0xa8>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 80011ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80011ee:	07db      	lsls	r3, r3, #31
 80011f0:	d418      	bmi.n	8001224 <HAL_SPI_Transmit_DMA+0xcc>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80011f2:	4667      	mov	r7, ip
 80011f4:	6853      	ldr	r3, [r2, #4]
 80011f6:	403b      	ands	r3, r7
 80011f8:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 80011fa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80011fc:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80011fe:	87e3      	strh	r3, [r4, #62]	; 0x3e
                                 hspi->TxXferCount))
 8001200:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8001202:	320c      	adds	r2, #12
                                 hspi->TxXferCount))
 8001204:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8001206:	f7ff fa23 	bl	8000650 <HAL_DMA_Start_IT>
 800120a:	2800      	cmp	r0, #0
 800120c:	d013      	beq.n	8001236 <HAL_SPI_Transmit_DMA+0xde>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 800120e:	2310      	movs	r3, #16
 8001210:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8001212:	4313      	orrs	r3, r2
 8001214:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->State = HAL_SPI_STATE_READY;
 8001216:	2301      	movs	r3, #1
 8001218:	345d      	adds	r4, #93	; 0x5d
 800121a:	7023      	strb	r3, [r4, #0]
  __HAL_UNLOCK(hspi);
 800121c:	2300      	movs	r3, #0
 800121e:	7033      	strb	r3, [r6, #0]
}
 8001220:	0028      	movs	r0, r5
 8001222:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8001224:	2380      	movs	r3, #128	; 0x80
 8001226:	6857      	ldr	r7, [r2, #4]
 8001228:	01db      	lsls	r3, r3, #7
 800122a:	433b      	orrs	r3, r7
 800122c:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 800122e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8001230:	085b      	lsrs	r3, r3, #1
 8001232:	3301      	adds	r3, #1
 8001234:	e7e3      	b.n	80011fe <HAL_SPI_Transmit_DMA+0xa6>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8001236:	2240      	movs	r2, #64	; 0x40
 8001238:	6823      	ldr	r3, [r4, #0]
 800123a:	6819      	ldr	r1, [r3, #0]
 800123c:	4211      	tst	r1, r2
 800123e:	d102      	bne.n	8001246 <HAL_SPI_Transmit_DMA+0xee>
    __HAL_SPI_ENABLE(hspi);
 8001240:	6819      	ldr	r1, [r3, #0]
 8001242:	430a      	orrs	r2, r1
 8001244:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8001246:	2220      	movs	r2, #32
 8001248:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 800124a:	2500      	movs	r5, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800124c:	430a      	orrs	r2, r1
 800124e:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8001250:	2202      	movs	r2, #2
 8001252:	6859      	ldr	r1, [r3, #4]
 8001254:	430a      	orrs	r2, r1
 8001256:	605a      	str	r2, [r3, #4]
 8001258:	e7e0      	b.n	800121c <HAL_SPI_Transmit_DMA+0xc4>
    errorcode = HAL_BUSY;
 800125a:	2502      	movs	r5, #2
 800125c:	e7de      	b.n	800121c <HAL_SPI_Transmit_DMA+0xc4>
 800125e:	46c0      	nop			; (mov r8, r8)
 8001260:	08001275 	.word	0x08001275
 8001264:	080012a5 	.word	0x080012a5
 8001268:	08001281 	.word	0x08001281
 800126c:	ffffbfff 	.word	0xffffbfff

08001270 <HAL_SPI_TxCpltCallback>:
 8001270:	4770      	bx	lr

08001272 <HAL_SPI_TxHalfCpltCallback>:
 8001272:	4770      	bx	lr

08001274 <SPI_DMAHalfTransmitCplt>:
{
 8001274:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8001276:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8001278:	f7ff fffb 	bl	8001272 <HAL_SPI_TxHalfCpltCallback>
}
 800127c:	bd10      	pop	{r4, pc}

0800127e <HAL_SPI_ErrorCallback>:
 800127e:	4770      	bx	lr

08001280 <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8001280:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8001282:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8001284:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8001286:	6802      	ldr	r2, [r0, #0]
 8001288:	6853      	ldr	r3, [r2, #4]
 800128a:	438b      	bics	r3, r1
 800128c:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 800128e:	2310      	movs	r3, #16
 8001290:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8001292:	4313      	orrs	r3, r2
 8001294:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8001296:	0003      	movs	r3, r0
 8001298:	2201      	movs	r2, #1
 800129a:	335d      	adds	r3, #93	; 0x5d
 800129c:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 800129e:	f7ff ffee 	bl	800127e <HAL_SPI_ErrorCallback>
}
 80012a2:	bd10      	pop	{r4, pc}

080012a4 <SPI_DMATransmitCplt>:
{
 80012a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80012a6:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 80012a8:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 80012aa:	f7ff f963 	bl	8000574 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80012ae:	682b      	ldr	r3, [r5, #0]
 80012b0:	2520      	movs	r5, #32
 80012b2:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 80012b4:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80012b6:	422b      	tst	r3, r5
 80012b8:	d127      	bne.n	800130a <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80012ba:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80012bc:	6823      	ldr	r3, [r4, #0]
 80012be:	6859      	ldr	r1, [r3, #4]
 80012c0:	43a9      	bics	r1, r5
 80012c2:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80012c4:	6859      	ldr	r1, [r3, #4]
 80012c6:	4381      	bics	r1, r0
 80012c8:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80012ca:	0020      	movs	r0, r4
 80012cc:	2164      	movs	r1, #100	; 0x64
 80012ce:	f7ff fea7 	bl	8001020 <SPI_EndRxTxTransaction>
 80012d2:	2800      	cmp	r0, #0
 80012d4:	d002      	beq.n	80012dc <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80012d6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80012d8:	431d      	orrs	r5, r3
 80012da:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80012dc:	68a3      	ldr	r3, [r4, #8]
 80012de:	2b00      	cmp	r3, #0
 80012e0:	d106      	bne.n	80012f0 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80012e2:	9301      	str	r3, [sp, #4]
 80012e4:	6823      	ldr	r3, [r4, #0]
 80012e6:	68da      	ldr	r2, [r3, #12]
 80012e8:	9201      	str	r2, [sp, #4]
 80012ea:	689b      	ldr	r3, [r3, #8]
 80012ec:	9301      	str	r3, [sp, #4]
 80012ee:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 80012f0:	2300      	movs	r3, #0
 80012f2:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80012f4:	0023      	movs	r3, r4
 80012f6:	2201      	movs	r2, #1
 80012f8:	335d      	adds	r3, #93	; 0x5d
 80012fa:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80012fc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80012fe:	2b00      	cmp	r3, #0
 8001300:	d003      	beq.n	800130a <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 8001302:	0020      	movs	r0, r4
 8001304:	f7ff ffbb 	bl	800127e <HAL_SPI_ErrorCallback>
}
 8001308:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 800130a:	0020      	movs	r0, r4
 800130c:	f7ff ffb0 	bl	8001270 <HAL_SPI_TxCpltCallback>
 8001310:	e7fa      	b.n	8001308 <SPI_DMATransmitCplt+0x64>

08001312 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8001312:	4770      	bx	lr

08001314 <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8001314:	0002      	movs	r2, r0
{
 8001316:	0003      	movs	r3, r0
  {
    return HAL_ERROR;
 8001318:	2001      	movs	r0, #1
  if (htim->State != HAL_TIM_STATE_READY)
 800131a:	323d      	adds	r2, #61	; 0x3d
 800131c:	7811      	ldrb	r1, [r2, #0]
 800131e:	4281      	cmp	r1, r0
 8001320:	d115      	bne.n	800134e <HAL_TIM_Base_Start_IT+0x3a>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8001322:	2102      	movs	r1, #2
 8001324:	7011      	strb	r1, [r2, #0]

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001326:	681b      	ldr	r3, [r3, #0]
 8001328:	68da      	ldr	r2, [r3, #12]
 800132a:	4302      	orrs	r2, r0
 800132c:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800132e:	4a0b      	ldr	r2, [pc, #44]	; (800135c <HAL_TIM_Base_Start_IT+0x48>)
 8001330:	4293      	cmp	r3, r2
 8001332:	d002      	beq.n	800133a <HAL_TIM_Base_Start_IT+0x26>
 8001334:	4a0a      	ldr	r2, [pc, #40]	; (8001360 <HAL_TIM_Base_Start_IT+0x4c>)
 8001336:	4293      	cmp	r3, r2
 8001338:	d10a      	bne.n	8001350 <HAL_TIM_Base_Start_IT+0x3c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800133a:	2107      	movs	r1, #7
 800133c:	689a      	ldr	r2, [r3, #8]
  {
    __HAL_TIM_ENABLE(htim);
  }

  /* Return function status */
  return HAL_OK;
 800133e:	2000      	movs	r0, #0
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8001340:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8001342:	2a06      	cmp	r2, #6
 8001344:	d003      	beq.n	800134e <HAL_TIM_Base_Start_IT+0x3a>
      __HAL_TIM_ENABLE(htim);
 8001346:	2201      	movs	r2, #1
 8001348:	6819      	ldr	r1, [r3, #0]
 800134a:	430a      	orrs	r2, r1
 800134c:	601a      	str	r2, [r3, #0]
}
 800134e:	4770      	bx	lr
    __HAL_TIM_ENABLE(htim);
 8001350:	681a      	ldr	r2, [r3, #0]
 8001352:	4310      	orrs	r0, r2
 8001354:	6018      	str	r0, [r3, #0]
  return HAL_OK;
 8001356:	2000      	movs	r0, #0
 8001358:	e7f9      	b.n	800134e <HAL_TIM_Base_Start_IT+0x3a>
 800135a:	46c0      	nop			; (mov r8, r8)
 800135c:	40012c00 	.word	0x40012c00
 8001360:	40000400 	.word	0x40000400

08001364 <HAL_TIM_OC_DelayElapsedCallback>:
 8001364:	4770      	bx	lr

08001366 <HAL_TIM_IC_CaptureCallback>:
 8001366:	4770      	bx	lr

08001368 <HAL_TIM_PWM_PulseFinishedCallback>:
 8001368:	4770      	bx	lr

0800136a <HAL_TIM_TriggerCallback>:
 800136a:	4770      	bx	lr

0800136c <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800136c:	2202      	movs	r2, #2
 800136e:	6803      	ldr	r3, [r0, #0]
{
 8001370:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001372:	6919      	ldr	r1, [r3, #16]
{
 8001374:	0004      	movs	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001376:	4211      	tst	r1, r2
 8001378:	d00e      	beq.n	8001398 <HAL_TIM_IRQHandler+0x2c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800137a:	68d9      	ldr	r1, [r3, #12]
 800137c:	4211      	tst	r1, r2
 800137e:	d00b      	beq.n	8001398 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8001380:	3a05      	subs	r2, #5
 8001382:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001384:	3204      	adds	r2, #4
 8001386:	7702      	strb	r2, [r0, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001388:	699b      	ldr	r3, [r3, #24]
 800138a:	079b      	lsls	r3, r3, #30
 800138c:	d100      	bne.n	8001390 <HAL_TIM_IRQHandler+0x24>
 800138e:	e079      	b.n	8001484 <HAL_TIM_IRQHandler+0x118>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8001390:	f7ff ffe9 	bl	8001366 <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001394:	2300      	movs	r3, #0
 8001396:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001398:	2204      	movs	r2, #4
 800139a:	6823      	ldr	r3, [r4, #0]
 800139c:	6919      	ldr	r1, [r3, #16]
 800139e:	4211      	tst	r1, r2
 80013a0:	d010      	beq.n	80013c4 <HAL_TIM_IRQHandler+0x58>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 80013a2:	68d9      	ldr	r1, [r3, #12]
 80013a4:	4211      	tst	r1, r2
 80013a6:	d00d      	beq.n	80013c4 <HAL_TIM_IRQHandler+0x58>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80013a8:	3a09      	subs	r2, #9
 80013aa:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80013ac:	3207      	adds	r2, #7
 80013ae:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80013b0:	699a      	ldr	r2, [r3, #24]
 80013b2:	23c0      	movs	r3, #192	; 0xc0
 80013b4:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80013b6:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80013b8:	421a      	tst	r2, r3
 80013ba:	d069      	beq.n	8001490 <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_IC_CaptureCallback(htim);
 80013bc:	f7ff ffd3 	bl	8001366 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80013c0:	2300      	movs	r3, #0
 80013c2:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80013c4:	2208      	movs	r2, #8
 80013c6:	6823      	ldr	r3, [r4, #0]
 80013c8:	6919      	ldr	r1, [r3, #16]
 80013ca:	4211      	tst	r1, r2
 80013cc:	d00e      	beq.n	80013ec <HAL_TIM_IRQHandler+0x80>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 80013ce:	68d9      	ldr	r1, [r3, #12]
 80013d0:	4211      	tst	r1, r2
 80013d2:	d00b      	beq.n	80013ec <HAL_TIM_IRQHandler+0x80>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80013d4:	3a11      	subs	r2, #17
 80013d6:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80013d8:	320d      	adds	r2, #13
 80013da:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80013dc:	69db      	ldr	r3, [r3, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80013de:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80013e0:	079b      	lsls	r3, r3, #30
 80013e2:	d05b      	beq.n	800149c <HAL_TIM_IRQHandler+0x130>
        HAL_TIM_IC_CaptureCallback(htim);
 80013e4:	f7ff ffbf 	bl	8001366 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80013e8:	2300      	movs	r3, #0
 80013ea:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80013ec:	2210      	movs	r2, #16
 80013ee:	6823      	ldr	r3, [r4, #0]
 80013f0:	6919      	ldr	r1, [r3, #16]
 80013f2:	4211      	tst	r1, r2
 80013f4:	d010      	beq.n	8001418 <HAL_TIM_IRQHandler+0xac>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80013f6:	68d9      	ldr	r1, [r3, #12]
 80013f8:	4211      	tst	r1, r2
 80013fa:	d00d      	beq.n	8001418 <HAL_TIM_IRQHandler+0xac>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80013fc:	3a21      	subs	r2, #33	; 0x21
 80013fe:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001400:	3219      	adds	r2, #25
 8001402:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001404:	69da      	ldr	r2, [r3, #28]
 8001406:	23c0      	movs	r3, #192	; 0xc0
 8001408:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800140a:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800140c:	421a      	tst	r2, r3
 800140e:	d04b      	beq.n	80014a8 <HAL_TIM_IRQHandler+0x13c>
        HAL_TIM_IC_CaptureCallback(htim);
 8001410:	f7ff ffa9 	bl	8001366 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001414:	2300      	movs	r3, #0
 8001416:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8001418:	2201      	movs	r2, #1
 800141a:	6823      	ldr	r3, [r4, #0]
 800141c:	6919      	ldr	r1, [r3, #16]
 800141e:	4211      	tst	r1, r2
 8001420:	d007      	beq.n	8001432 <HAL_TIM_IRQHandler+0xc6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8001422:	68d9      	ldr	r1, [r3, #12]
 8001424:	4211      	tst	r1, r2
 8001426:	d004      	beq.n	8001432 <HAL_TIM_IRQHandler+0xc6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8001428:	3a03      	subs	r2, #3
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800142a:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800142c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800142e:	f7fe ff8b 	bl	8000348 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001432:	2280      	movs	r2, #128	; 0x80
 8001434:	6823      	ldr	r3, [r4, #0]
 8001436:	6919      	ldr	r1, [r3, #16]
 8001438:	4211      	tst	r1, r2
 800143a:	d008      	beq.n	800144e <HAL_TIM_IRQHandler+0xe2>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800143c:	68d9      	ldr	r1, [r3, #12]
 800143e:	4211      	tst	r1, r2
 8001440:	d005      	beq.n	800144e <HAL_TIM_IRQHandler+0xe2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001442:	3a02      	subs	r2, #2
 8001444:	3aff      	subs	r2, #255	; 0xff
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8001446:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8001448:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800144a:	f000 f89c 	bl	8001586 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800144e:	2240      	movs	r2, #64	; 0x40
 8001450:	6823      	ldr	r3, [r4, #0]
 8001452:	6919      	ldr	r1, [r3, #16]
 8001454:	4211      	tst	r1, r2
 8001456:	d007      	beq.n	8001468 <HAL_TIM_IRQHandler+0xfc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8001458:	68d9      	ldr	r1, [r3, #12]
 800145a:	4211      	tst	r1, r2
 800145c:	d004      	beq.n	8001468 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800145e:	3a81      	subs	r2, #129	; 0x81
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8001460:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8001462:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8001464:	f7ff ff81 	bl	800136a <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8001468:	2220      	movs	r2, #32
 800146a:	6823      	ldr	r3, [r4, #0]
 800146c:	6919      	ldr	r1, [r3, #16]
 800146e:	4211      	tst	r1, r2
 8001470:	d007      	beq.n	8001482 <HAL_TIM_IRQHandler+0x116>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8001472:	68d9      	ldr	r1, [r3, #12]
 8001474:	4211      	tst	r1, r2
 8001476:	d004      	beq.n	8001482 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8001478:	3a41      	subs	r2, #65	; 0x41
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800147a:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800147c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 800147e:	f000 f881 	bl	8001584 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8001482:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001484:	f7ff ff6e 	bl	8001364 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001488:	0020      	movs	r0, r4
 800148a:	f7ff ff6d 	bl	8001368 <HAL_TIM_PWM_PulseFinishedCallback>
 800148e:	e781      	b.n	8001394 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001490:	f7ff ff68 	bl	8001364 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001494:	0020      	movs	r0, r4
 8001496:	f7ff ff67 	bl	8001368 <HAL_TIM_PWM_PulseFinishedCallback>
 800149a:	e791      	b.n	80013c0 <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800149c:	f7ff ff62 	bl	8001364 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80014a0:	0020      	movs	r0, r4
 80014a2:	f7ff ff61 	bl	8001368 <HAL_TIM_PWM_PulseFinishedCallback>
 80014a6:	e79f      	b.n	80013e8 <HAL_TIM_IRQHandler+0x7c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80014a8:	f7ff ff5c 	bl	8001364 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80014ac:	0020      	movs	r0, r4
 80014ae:	f7ff ff5b 	bl	8001368 <HAL_TIM_PWM_PulseFinishedCallback>
 80014b2:	e7af      	b.n	8001414 <HAL_TIM_IRQHandler+0xa8>

080014b4 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80014b4:	4a19      	ldr	r2, [pc, #100]	; (800151c <TIM_Base_SetConfig+0x68>)
{
 80014b6:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 80014b8:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80014ba:	4290      	cmp	r0, r2
 80014bc:	d002      	beq.n	80014c4 <TIM_Base_SetConfig+0x10>
 80014be:	4c18      	ldr	r4, [pc, #96]	; (8001520 <TIM_Base_SetConfig+0x6c>)
 80014c0:	42a0      	cmp	r0, r4
 80014c2:	d108      	bne.n	80014d6 <TIM_Base_SetConfig+0x22>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80014c4:	2470      	movs	r4, #112	; 0x70
 80014c6:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 80014c8:	684c      	ldr	r4, [r1, #4]
 80014ca:	4323      	orrs	r3, r4
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80014cc:	4290      	cmp	r0, r2
 80014ce:	d00b      	beq.n	80014e8 <TIM_Base_SetConfig+0x34>
 80014d0:	4c13      	ldr	r4, [pc, #76]	; (8001520 <TIM_Base_SetConfig+0x6c>)
 80014d2:	42a0      	cmp	r0, r4
 80014d4:	d008      	beq.n	80014e8 <TIM_Base_SetConfig+0x34>
 80014d6:	4c13      	ldr	r4, [pc, #76]	; (8001524 <TIM_Base_SetConfig+0x70>)
 80014d8:	42a0      	cmp	r0, r4
 80014da:	d005      	beq.n	80014e8 <TIM_Base_SetConfig+0x34>
 80014dc:	4c12      	ldr	r4, [pc, #72]	; (8001528 <TIM_Base_SetConfig+0x74>)
 80014de:	42a0      	cmp	r0, r4
 80014e0:	d002      	beq.n	80014e8 <TIM_Base_SetConfig+0x34>
 80014e2:	4c12      	ldr	r4, [pc, #72]	; (800152c <TIM_Base_SetConfig+0x78>)
 80014e4:	42a0      	cmp	r0, r4
 80014e6:	d103      	bne.n	80014f0 <TIM_Base_SetConfig+0x3c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80014e8:	4c11      	ldr	r4, [pc, #68]	; (8001530 <TIM_Base_SetConfig+0x7c>)
 80014ea:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80014ec:	68cc      	ldr	r4, [r1, #12]
 80014ee:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80014f0:	2480      	movs	r4, #128	; 0x80
 80014f2:	43a3      	bics	r3, r4
 80014f4:	694c      	ldr	r4, [r1, #20]
 80014f6:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 80014f8:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80014fa:	688b      	ldr	r3, [r1, #8]
 80014fc:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80014fe:	680b      	ldr	r3, [r1, #0]
 8001500:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8001502:	4290      	cmp	r0, r2
 8001504:	d005      	beq.n	8001512 <TIM_Base_SetConfig+0x5e>
 8001506:	4b08      	ldr	r3, [pc, #32]	; (8001528 <TIM_Base_SetConfig+0x74>)
 8001508:	4298      	cmp	r0, r3
 800150a:	d002      	beq.n	8001512 <TIM_Base_SetConfig+0x5e>
 800150c:	4b07      	ldr	r3, [pc, #28]	; (800152c <TIM_Base_SetConfig+0x78>)
 800150e:	4298      	cmp	r0, r3
 8001510:	d101      	bne.n	8001516 <TIM_Base_SetConfig+0x62>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8001512:	690b      	ldr	r3, [r1, #16]
 8001514:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8001516:	2301      	movs	r3, #1
 8001518:	6143      	str	r3, [r0, #20]
}
 800151a:	bd10      	pop	{r4, pc}
 800151c:	40012c00 	.word	0x40012c00
 8001520:	40000400 	.word	0x40000400
 8001524:	40002000 	.word	0x40002000
 8001528:	40014400 	.word	0x40014400
 800152c:	40014800 	.word	0x40014800
 8001530:	fffffcff 	.word	0xfffffcff

08001534 <HAL_TIM_Base_Init>:
{
 8001534:	b570      	push	{r4, r5, r6, lr}
 8001536:	0004      	movs	r4, r0
    return HAL_ERROR;
 8001538:	2001      	movs	r0, #1
  if (htim == NULL)
 800153a:	2c00      	cmp	r4, #0
 800153c:	d021      	beq.n	8001582 <HAL_TIM_Base_Init+0x4e>
  if (htim->State == HAL_TIM_STATE_RESET)
 800153e:	0025      	movs	r5, r4
 8001540:	353d      	adds	r5, #61	; 0x3d
 8001542:	782b      	ldrb	r3, [r5, #0]
 8001544:	b2da      	uxtb	r2, r3
 8001546:	2b00      	cmp	r3, #0
 8001548:	d105      	bne.n	8001556 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 800154a:	0023      	movs	r3, r4
 800154c:	333c      	adds	r3, #60	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800154e:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 8001550:	701a      	strb	r2, [r3, #0]
    HAL_TIM_Base_MspInit(htim);
 8001552:	f7ff fede 	bl	8001312 <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 8001556:	2302      	movs	r3, #2
 8001558:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800155a:	6820      	ldr	r0, [r4, #0]
 800155c:	1d21      	adds	r1, r4, #4
 800155e:	f7ff ffa9 	bl	80014b4 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001562:	0022      	movs	r2, r4
 8001564:	2301      	movs	r3, #1
  return HAL_OK;
 8001566:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8001568:	3246      	adds	r2, #70	; 0x46
 800156a:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800156c:	3445      	adds	r4, #69	; 0x45
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800156e:	3a08      	subs	r2, #8
 8001570:	7013      	strb	r3, [r2, #0]
 8001572:	7053      	strb	r3, [r2, #1]
 8001574:	7093      	strb	r3, [r2, #2]
 8001576:	70d3      	strb	r3, [r2, #3]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8001578:	7113      	strb	r3, [r2, #4]
 800157a:	7153      	strb	r3, [r2, #5]
 800157c:	7193      	strb	r3, [r2, #6]
 800157e:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 8001580:	702b      	strb	r3, [r5, #0]
}
 8001582:	bd70      	pop	{r4, r5, r6, pc}

08001584 <HAL_TIMEx_CommutCallback>:
 8001584:	4770      	bx	lr

08001586 <HAL_TIMEx_BreakCallback>:
 8001586:	4770      	bx	lr

08001588 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001588:	0003      	movs	r3, r0

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 800158a:	2201      	movs	r2, #1
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800158c:	3308      	adds	r3, #8
 800158e:	6043      	str	r3, [r0, #4]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001590:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001592:	6103      	str	r3, [r0, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8001594:	2300      	movs	r3, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001596:	4252      	negs	r2, r2
 8001598:	6082      	str	r2, [r0, #8]
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800159a:	6003      	str	r3, [r0, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800159c:	4770      	bx	lr

0800159e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 800159e:	2300      	movs	r3, #0
 80015a0:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 80015a2:	4770      	bx	lr

080015a4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    ListItem_t * const pxIndex = pxList->pxIndex;
 80015a4:	6843      	ldr	r3, [r0, #4]

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80015a6:	689a      	ldr	r2, [r3, #8]
    pxNewListItem->pxNext = pxIndex;
 80015a8:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80015aa:	608a      	str	r2, [r1, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
 80015ac:	689a      	ldr	r2, [r3, #8]
 80015ae:	6051      	str	r1, [r2, #4]
    pxIndex->pxPrevious = pxNewListItem;
 80015b0:	6099      	str	r1, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 80015b2:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 80015b4:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 80015b6:	3301      	adds	r3, #1
 80015b8:	6003      	str	r3, [r0, #0]
}
 80015ba:	4770      	bx	lr

080015bc <vListInsert>:
        *   4) Using a queue or semaphore before it has been initialised or
        *      before the scheduler has been started (are interrupts firing
        *      before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80015bc:	0002      	movs	r2, r0
{
 80015be:	b530      	push	{r4, r5, lr}
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80015c0:	680c      	ldr	r4, [r1, #0]
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80015c2:	3208      	adds	r2, #8
    if( xValueOfInsertion == portMAX_DELAY )
 80015c4:	1c63      	adds	r3, r4, #1
 80015c6:	d10a      	bne.n	80015de <vListInsert+0x22>
        pxIterator = pxList->xListEnd.pxPrevious;
 80015c8:	6903      	ldr	r3, [r0, #16]
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 80015ca:	685a      	ldr	r2, [r3, #4]
 80015cc:	604a      	str	r2, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80015ce:	6091      	str	r1, [r2, #8]
    pxNewListItem->pxPrevious = pxIterator;
 80015d0:	608b      	str	r3, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 80015d2:	6059      	str	r1, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 80015d4:	6803      	ldr	r3, [r0, #0]
    pxNewListItem->pxContainer = pxList;
 80015d6:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 80015d8:	3301      	adds	r3, #1
 80015da:	6003      	str	r3, [r0, #0]
}
 80015dc:	bd30      	pop	{r4, r5, pc}
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80015de:	0013      	movs	r3, r2
 80015e0:	6852      	ldr	r2, [r2, #4]
 80015e2:	6815      	ldr	r5, [r2, #0]
 80015e4:	42a5      	cmp	r5, r4
 80015e6:	d9fa      	bls.n	80015de <vListInsert+0x22>
 80015e8:	e7ef      	b.n	80015ca <vListInsert+0xe>

080015ea <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 80015ea:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80015ec:	6841      	ldr	r1, [r0, #4]
 80015ee:	6882      	ldr	r2, [r0, #8]
 80015f0:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80015f2:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 80015f4:	6859      	ldr	r1, [r3, #4]
 80015f6:	4281      	cmp	r1, r0
 80015f8:	d100      	bne.n	80015fc <uxListRemove+0x12>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 80015fa:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 80015fc:	2200      	movs	r2, #0
 80015fe:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 8001600:	681a      	ldr	r2, [r3, #0]
 8001602:	3a01      	subs	r2, #1
 8001604:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 8001606:	6818      	ldr	r0, [r3, #0]
}
 8001608:	4770      	bx	lr

0800160a <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 800160a:	b510      	push	{r4, lr}
 800160c:	0004      	movs	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 800160e:	f000 ffc7 	bl	80025a0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8001612:	6ba4      	ldr	r4, [r4, #56]	; 0x38
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 8001614:	f000 ffd0 	bl	80025b8 <vPortExitCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8001618:	4260      	negs	r0, r4
 800161a:	4160      	adcs	r0, r4

    return xReturn;
}
 800161c:	bd10      	pop	{r4, pc}

0800161e <prvCopyDataToQueue>:
{
 800161e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001620:	0015      	movs	r5, r2
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001622:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8001624:	0004      	movs	r4, r0
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001626:	6b86      	ldr	r6, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001628:	2a00      	cmp	r2, #0
 800162a:	d10c      	bne.n	8001646 <prvCopyDataToQueue+0x28>
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800162c:	6807      	ldr	r7, [r0, #0]
    BaseType_t xReturn = pdFALSE;
 800162e:	0015      	movs	r5, r2
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001630:	2f00      	cmp	r7, #0
 8001632:	d104      	bne.n	800163e <prvCopyDataToQueue+0x20>
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8001634:	6880      	ldr	r0, [r0, #8]
 8001636:	f000 fd9f 	bl	8002178 <xTaskPriorityDisinherit>
 800163a:	0005      	movs	r5, r0
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800163c:	60a7      	str	r7, [r4, #8]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800163e:	3601      	adds	r6, #1
}
 8001640:	0028      	movs	r0, r5
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8001642:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8001644:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if( xPosition == queueSEND_TO_BACK )
 8001646:	2d00      	cmp	r5, #0
 8001648:	d10c      	bne.n	8001664 <prvCopyDataToQueue+0x46>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800164a:	6840      	ldr	r0, [r0, #4]
 800164c:	f001 f938 	bl	80028c0 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001650:	6863      	ldr	r3, [r4, #4]
 8001652:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001654:	189b      	adds	r3, r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001656:	68a2      	ldr	r2, [r4, #8]
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001658:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800165a:	4293      	cmp	r3, r2
 800165c:	d3ef      	bcc.n	800163e <prvCopyDataToQueue+0x20>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 800165e:	6823      	ldr	r3, [r4, #0]
 8001660:	6063      	str	r3, [r4, #4]
 8001662:	e7ec      	b.n	800163e <prvCopyDataToQueue+0x20>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8001664:	68c0      	ldr	r0, [r0, #12]
 8001666:	f001 f92b 	bl	80028c0 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800166a:	68e3      	ldr	r3, [r4, #12]
 800166c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800166e:	4251      	negs	r1, r2
 8001670:	1a9a      	subs	r2, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001672:	6823      	ldr	r3, [r4, #0]
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8001674:	60e2      	str	r2, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001676:	429a      	cmp	r2, r3
 8001678:	d202      	bcs.n	8001680 <prvCopyDataToQueue+0x62>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 800167a:	68a3      	ldr	r3, [r4, #8]
 800167c:	1859      	adds	r1, r3, r1
 800167e:	60e1      	str	r1, [r4, #12]
        if( xPosition == queueOVERWRITE )
 8001680:	2d02      	cmp	r5, #2
 8001682:	d105      	bne.n	8001690 <prvCopyDataToQueue+0x72>
                --uxMessagesWaiting;
 8001684:	0033      	movs	r3, r6
 8001686:	1e5a      	subs	r2, r3, #1
 8001688:	4193      	sbcs	r3, r2
    BaseType_t xReturn = pdFALSE;
 800168a:	2500      	movs	r5, #0
                --uxMessagesWaiting;
 800168c:	1af6      	subs	r6, r6, r3
 800168e:	e7d6      	b.n	800163e <prvCopyDataToQueue+0x20>
    BaseType_t xReturn = pdFALSE;
 8001690:	2500      	movs	r5, #0
 8001692:	e7d4      	b.n	800163e <prvCopyDataToQueue+0x20>

08001694 <prvCopyDataFromQueue>:
{
 8001694:	0003      	movs	r3, r0
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001696:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8001698:	0008      	movs	r0, r1
 800169a:	b510      	push	{r4, lr}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800169c:	2a00      	cmp	r2, #0
 800169e:	d00a      	beq.n	80016b6 <prvCopyDataFromQueue+0x22>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80016a0:	68d9      	ldr	r1, [r3, #12]
 80016a2:	188c      	adds	r4, r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80016a4:	6899      	ldr	r1, [r3, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80016a6:	60dc      	str	r4, [r3, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80016a8:	428c      	cmp	r4, r1
 80016aa:	d301      	bcc.n	80016b0 <prvCopyDataFromQueue+0x1c>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 80016ac:	6819      	ldr	r1, [r3, #0]
 80016ae:	60d9      	str	r1, [r3, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80016b0:	68d9      	ldr	r1, [r3, #12]
 80016b2:	f001 f905 	bl	80028c0 <memcpy>
}
 80016b6:	bd10      	pop	{r4, pc}

080016b8 <prvUnlockQueue>:
{
 80016b8:	b570      	push	{r4, r5, r6, lr}
 80016ba:	0004      	movs	r4, r0
        int8_t cTxLock = pxQueue->cTxLock;
 80016bc:	0026      	movs	r6, r4
 80016be:	3645      	adds	r6, #69	; 0x45
    taskENTER_CRITICAL();
 80016c0:	f000 ff6e 	bl	80025a0 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80016c4:	7835      	ldrb	r5, [r6, #0]
 80016c6:	b26d      	sxtb	r5, r5
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80016c8:	2d00      	cmp	r5, #0
 80016ca:	dc10      	bgt.n	80016ee <prvUnlockQueue+0x36>
        pxQueue->cTxLock = queueUNLOCKED;
 80016cc:	23ff      	movs	r3, #255	; 0xff
 80016ce:	7033      	strb	r3, [r6, #0]
        int8_t cRxLock = pxQueue->cRxLock;
 80016d0:	0026      	movs	r6, r4
 80016d2:	3644      	adds	r6, #68	; 0x44
    taskEXIT_CRITICAL();
 80016d4:	f000 ff70 	bl	80025b8 <vPortExitCritical>
    taskENTER_CRITICAL();
 80016d8:	f000 ff62 	bl	80025a0 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80016dc:	7835      	ldrb	r5, [r6, #0]
 80016de:	b26d      	sxtb	r5, r5
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80016e0:	2d00      	cmp	r5, #0
 80016e2:	dc11      	bgt.n	8001708 <prvUnlockQueue+0x50>
        pxQueue->cRxLock = queueUNLOCKED;
 80016e4:	23ff      	movs	r3, #255	; 0xff
 80016e6:	7033      	strb	r3, [r6, #0]
    taskEXIT_CRITICAL();
 80016e8:	f000 ff66 	bl	80025b8 <vPortExitCritical>
}
 80016ec:	bd70      	pop	{r4, r5, r6, pc}
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80016ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80016f0:	2b00      	cmp	r3, #0
 80016f2:	d0eb      	beq.n	80016cc <prvUnlockQueue+0x14>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80016f4:	0020      	movs	r0, r4
 80016f6:	3024      	adds	r0, #36	; 0x24
 80016f8:	f000 fcae 	bl	8002058 <xTaskRemoveFromEventList>
 80016fc:	2800      	cmp	r0, #0
 80016fe:	d001      	beq.n	8001704 <prvUnlockQueue+0x4c>
                            vTaskMissedYield();
 8001700:	f000 fd24 	bl	800214c <vTaskMissedYield>
            --cTxLock;
 8001704:	3d01      	subs	r5, #1
 8001706:	e7de      	b.n	80016c6 <prvUnlockQueue+0xe>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001708:	6923      	ldr	r3, [r4, #16]
 800170a:	2b00      	cmp	r3, #0
 800170c:	d0ea      	beq.n	80016e4 <prvUnlockQueue+0x2c>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800170e:	0020      	movs	r0, r4
 8001710:	3010      	adds	r0, #16
 8001712:	f000 fca1 	bl	8002058 <xTaskRemoveFromEventList>
 8001716:	2800      	cmp	r0, #0
 8001718:	d001      	beq.n	800171e <prvUnlockQueue+0x66>
                    vTaskMissedYield();
 800171a:	f000 fd17 	bl	800214c <vTaskMissedYield>
                --cRxLock;
 800171e:	3d01      	subs	r5, #1
 8001720:	e7dd      	b.n	80016de <prvUnlockQueue+0x26>

08001722 <xQueueGenericReset>:
{
 8001722:	b570      	push	{r4, r5, r6, lr}
 8001724:	0004      	movs	r4, r0
 8001726:	000d      	movs	r5, r1
    configASSERT( pxQueue );
 8001728:	2800      	cmp	r0, #0
 800172a:	d101      	bne.n	8001730 <xQueueGenericReset+0xe>
 800172c:	b672      	cpsid	i
 800172e:	e7fe      	b.n	800172e <xQueueGenericReset+0xc>
    taskENTER_CRITICAL();
 8001730:	f000 ff36 	bl	80025a0 <vPortEnterCritical>
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001734:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001736:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001738:	6822      	ldr	r2, [r4, #0]
 800173a:	434b      	muls	r3, r1
 800173c:	18d0      	adds	r0, r2, r3
        pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800173e:	1a5b      	subs	r3, r3, r1
 8001740:	18d3      	adds	r3, r2, r3
 8001742:	60e3      	str	r3, [r4, #12]
        pxQueue->cRxLock = queueUNLOCKED;
 8001744:	0023      	movs	r3, r4
        pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001746:	60a0      	str	r0, [r4, #8]
        pxQueue->pcWriteTo = pxQueue->pcHead;
 8001748:	6062      	str	r2, [r4, #4]
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800174a:	2000      	movs	r0, #0
        pxQueue->cRxLock = queueUNLOCKED;
 800174c:	22ff      	movs	r2, #255	; 0xff
 800174e:	3344      	adds	r3, #68	; 0x44
        pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001750:	63a0      	str	r0, [r4, #56]	; 0x38
        pxQueue->cRxLock = queueUNLOCKED;
 8001752:	701a      	strb	r2, [r3, #0]
        pxQueue->cTxLock = queueUNLOCKED;
 8001754:	705a      	strb	r2, [r3, #1]
        if( xNewQueue == pdFALSE )
 8001756:	4285      	cmp	r5, r0
 8001758:	d10a      	bne.n	8001770 <xQueueGenericReset+0x4e>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800175a:	6923      	ldr	r3, [r4, #16]
 800175c:	4283      	cmp	r3, r0
 800175e:	d003      	beq.n	8001768 <xQueueGenericReset+0x46>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001760:	0020      	movs	r0, r4
 8001762:	3010      	adds	r0, #16
 8001764:	f000 fc78 	bl	8002058 <xTaskRemoveFromEventList>
    taskEXIT_CRITICAL();
 8001768:	f000 ff26 	bl	80025b8 <vPortExitCritical>
}
 800176c:	2001      	movs	r0, #1
 800176e:	bd70      	pop	{r4, r5, r6, pc}
            vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001770:	0020      	movs	r0, r4
 8001772:	3010      	adds	r0, #16
 8001774:	f7ff ff08 	bl	8001588 <vListInitialise>
            vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001778:	0020      	movs	r0, r4
 800177a:	3024      	adds	r0, #36	; 0x24
 800177c:	f7ff ff04 	bl	8001588 <vListInitialise>
 8001780:	e7f2      	b.n	8001768 <xQueueGenericReset+0x46>

08001782 <xQueueGenericCreate>:
    {
 8001782:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001784:	0006      	movs	r6, r0
 8001786:	000d      	movs	r5, r1
 8001788:	0017      	movs	r7, r2
        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800178a:	2800      	cmp	r0, #0
 800178c:	d101      	bne.n	8001792 <xQueueGenericCreate+0x10>
 800178e:	b672      	cpsid	i
 8001790:	e7fe      	b.n	8001790 <xQueueGenericCreate+0xe>
        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001792:	000c      	movs	r4, r1
 8001794:	4344      	muls	r4, r0
        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );
 8001796:	2900      	cmp	r1, #0
 8001798:	d00b      	beq.n	80017b2 <xQueueGenericCreate+0x30>
 800179a:	0020      	movs	r0, r4
 800179c:	f7fe fcbe 	bl	800011c <__udivsi3>
 80017a0:	4286      	cmp	r6, r0
 80017a2:	d001      	beq.n	80017a8 <xQueueGenericCreate+0x26>
 80017a4:	b672      	cpsid	i
 80017a6:	e7fe      	b.n	80017a6 <xQueueGenericCreate+0x24>
        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
 80017a8:	0023      	movs	r3, r4
 80017aa:	3351      	adds	r3, #81	; 0x51
 80017ac:	d901      	bls.n	80017b2 <xQueueGenericCreate+0x30>
 80017ae:	b672      	cpsid	i
 80017b0:	e7fe      	b.n	80017b0 <xQueueGenericCreate+0x2e>
        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80017b2:	0020      	movs	r0, r4
 80017b4:	3050      	adds	r0, #80	; 0x50
 80017b6:	f000 ffab 	bl	8002710 <pvPortMalloc>
 80017ba:	1e04      	subs	r4, r0, #0
        if( pxNewQueue != NULL )
 80017bc:	d00d      	beq.n	80017da <xQueueGenericCreate+0x58>
    if( uxItemSize == ( UBaseType_t ) 0 )
 80017be:	0003      	movs	r3, r0
 80017c0:	2d00      	cmp	r5, #0
 80017c2:	d000      	beq.n	80017c6 <xQueueGenericCreate+0x44>
            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017c4:	3350      	adds	r3, #80	; 0x50
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80017c6:	6023      	str	r3, [r4, #0]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80017c8:	2101      	movs	r1, #1
 80017ca:	0020      	movs	r0, r4
    pxNewQueue->uxLength = uxQueueLength;
 80017cc:	63e6      	str	r6, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 80017ce:	6425      	str	r5, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80017d0:	f7ff ffa7 	bl	8001722 <xQueueGenericReset>
            pxNewQueue->ucQueueType = ucQueueType;
 80017d4:	0023      	movs	r3, r4
 80017d6:	334c      	adds	r3, #76	; 0x4c
 80017d8:	701f      	strb	r7, [r3, #0]
    }
 80017da:	0020      	movs	r0, r4
 80017dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080017de <xQueueGenericSend>:
{
 80017de:	b5f0      	push	{r4, r5, r6, r7, lr}
 80017e0:	b085      	sub	sp, #20
 80017e2:	0004      	movs	r4, r0
 80017e4:	000d      	movs	r5, r1
 80017e6:	001f      	movs	r7, r3
 80017e8:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
 80017ea:	2800      	cmp	r0, #0
 80017ec:	d101      	bne.n	80017f2 <xQueueGenericSend+0x14>
 80017ee:	b672      	cpsid	i
 80017f0:	e7fe      	b.n	80017f0 <xQueueGenericSend+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80017f2:	2900      	cmp	r1, #0
 80017f4:	d104      	bne.n	8001800 <xQueueGenericSend+0x22>
 80017f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80017f8:	2b00      	cmp	r3, #0
 80017fa:	d001      	beq.n	8001800 <xQueueGenericSend+0x22>
 80017fc:	b672      	cpsid	i
 80017fe:	e7fe      	b.n	80017fe <xQueueGenericSend+0x20>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8001800:	2f02      	cmp	r7, #2
 8001802:	d104      	bne.n	800180e <xQueueGenericSend+0x30>
 8001804:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001806:	2b01      	cmp	r3, #1
 8001808:	d001      	beq.n	800180e <xQueueGenericSend+0x30>
 800180a:	b672      	cpsid	i
 800180c:	e7fe      	b.n	800180c <xQueueGenericSend+0x2e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800180e:	f000 fca3 	bl	8002158 <xTaskGetSchedulerState>
 8001812:	1e06      	subs	r6, r0, #0
 8001814:	d104      	bne.n	8001820 <xQueueGenericSend+0x42>
 8001816:	9b01      	ldr	r3, [sp, #4]
 8001818:	2b00      	cmp	r3, #0
 800181a:	d04d      	beq.n	80018b8 <xQueueGenericSend+0xda>
 800181c:	b672      	cpsid	i
 800181e:	e7fe      	b.n	800181e <xQueueGenericSend+0x40>
 8001820:	2600      	movs	r6, #0
 8001822:	e049      	b.n	80018b8 <xQueueGenericSend+0xda>
                if( xTicksToWait == ( TickType_t ) 0 )
 8001824:	9b01      	ldr	r3, [sp, #4]
 8001826:	9300      	str	r3, [sp, #0]
 8001828:	2b00      	cmp	r3, #0
 800182a:	d103      	bne.n	8001834 <xQueueGenericSend+0x56>
                    taskEXIT_CRITICAL();
 800182c:	f000 fec4 	bl	80025b8 <vPortExitCritical>
            return errQUEUE_FULL;
 8001830:	2000      	movs	r0, #0
 8001832:	e058      	b.n	80018e6 <xQueueGenericSend+0x108>
                else if( xEntryTimeSet == pdFALSE )
 8001834:	2e00      	cmp	r6, #0
 8001836:	d102      	bne.n	800183e <xQueueGenericSend+0x60>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8001838:	a802      	add	r0, sp, #8
 800183a:	f000 fc49 	bl	80020d0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 800183e:	f000 febb 	bl	80025b8 <vPortExitCritical>
        vTaskSuspendAll();
 8001842:	f000 fad7 	bl	8001df4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8001846:	f000 feab 	bl	80025a0 <vPortEnterCritical>
 800184a:	0022      	movs	r2, r4
 800184c:	3244      	adds	r2, #68	; 0x44
 800184e:	7813      	ldrb	r3, [r2, #0]
 8001850:	b25b      	sxtb	r3, r3
 8001852:	3301      	adds	r3, #1
 8001854:	d101      	bne.n	800185a <xQueueGenericSend+0x7c>
 8001856:	2300      	movs	r3, #0
 8001858:	7013      	strb	r3, [r2, #0]
 800185a:	0022      	movs	r2, r4
 800185c:	3245      	adds	r2, #69	; 0x45
 800185e:	7813      	ldrb	r3, [r2, #0]
 8001860:	b25b      	sxtb	r3, r3
 8001862:	3301      	adds	r3, #1
 8001864:	d101      	bne.n	800186a <xQueueGenericSend+0x8c>
 8001866:	2300      	movs	r3, #0
 8001868:	7013      	strb	r3, [r2, #0]
 800186a:	f000 fea5 	bl	80025b8 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800186e:	a901      	add	r1, sp, #4
 8001870:	a802      	add	r0, sp, #8
 8001872:	f000 fc39 	bl	80020e8 <xTaskCheckForTimeOut>
 8001876:	2800      	cmp	r0, #0
 8001878:	d137      	bne.n	80018ea <xQueueGenericSend+0x10c>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 800187a:	f000 fe91 	bl	80025a0 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800187e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001880:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001882:	4293      	cmp	r3, r2
 8001884:	d110      	bne.n	80018a8 <xQueueGenericSend+0xca>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 8001886:	f000 fe97 	bl	80025b8 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800188a:	0020      	movs	r0, r4
 800188c:	9901      	ldr	r1, [sp, #4]
 800188e:	3010      	adds	r0, #16
 8001890:	f000 fbb8 	bl	8002004 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001894:	0020      	movs	r0, r4
 8001896:	f7ff ff0f 	bl	80016b8 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 800189a:	f000 fb1b 	bl	8001ed4 <xTaskResumeAll>
 800189e:	2800      	cmp	r0, #0
 80018a0:	d109      	bne.n	80018b6 <xQueueGenericSend+0xd8>
                    portYIELD_WITHIN_API();
 80018a2:	f000 fe71 	bl	8002588 <vPortYield>
 80018a6:	e006      	b.n	80018b6 <xQueueGenericSend+0xd8>
    taskEXIT_CRITICAL();
 80018a8:	f000 fe86 	bl	80025b8 <vPortExitCritical>
                prvUnlockQueue( pxQueue );
 80018ac:	0020      	movs	r0, r4
 80018ae:	f7ff ff03 	bl	80016b8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 80018b2:	f000 fb0f 	bl	8001ed4 <xTaskResumeAll>
 80018b6:	2601      	movs	r6, #1
        taskENTER_CRITICAL();
 80018b8:	f000 fe72 	bl	80025a0 <vPortEnterCritical>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80018bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80018be:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80018c0:	4293      	cmp	r3, r2
 80018c2:	d301      	bcc.n	80018c8 <xQueueGenericSend+0xea>
 80018c4:	2f02      	cmp	r7, #2
 80018c6:	d1ad      	bne.n	8001824 <xQueueGenericSend+0x46>
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80018c8:	003a      	movs	r2, r7
 80018ca:	0029      	movs	r1, r5
 80018cc:	0020      	movs	r0, r4
 80018ce:	f7ff fea6 	bl	800161e <prvCopyDataToQueue>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80018d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80018d4:	2b00      	cmp	r3, #0
 80018d6:	d003      	beq.n	80018e0 <xQueueGenericSend+0x102>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80018d8:	0020      	movs	r0, r4
 80018da:	3024      	adds	r0, #36	; 0x24
 80018dc:	f000 fbbc 	bl	8002058 <xTaskRemoveFromEventList>
                taskEXIT_CRITICAL();
 80018e0:	f000 fe6a 	bl	80025b8 <vPortExitCritical>
                return pdPASS;
 80018e4:	2001      	movs	r0, #1
}
 80018e6:	b005      	add	sp, #20
 80018e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
            prvUnlockQueue( pxQueue );
 80018ea:	0020      	movs	r0, r4
 80018ec:	f7ff fee4 	bl	80016b8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 80018f0:	f000 faf0 	bl	8001ed4 <xTaskResumeAll>
 80018f4:	e79c      	b.n	8001830 <xQueueGenericSend+0x52>

080018f6 <xQueueGenericSendFromISR>:
{
 80018f6:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018f8:	b085      	sub	sp, #20
 80018fa:	0004      	movs	r4, r0
 80018fc:	0017      	movs	r7, r2
 80018fe:	001e      	movs	r6, r3
 8001900:	9101      	str	r1, [sp, #4]
    configASSERT( pxQueue );
 8001902:	2800      	cmp	r0, #0
 8001904:	d101      	bne.n	800190a <xQueueGenericSendFromISR+0x14>
 8001906:	b672      	cpsid	i
 8001908:	e7fe      	b.n	8001908 <xQueueGenericSendFromISR+0x12>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800190a:	9b01      	ldr	r3, [sp, #4]
 800190c:	2b00      	cmp	r3, #0
 800190e:	d104      	bne.n	800191a <xQueueGenericSendFromISR+0x24>
 8001910:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001912:	2b00      	cmp	r3, #0
 8001914:	d001      	beq.n	800191a <xQueueGenericSendFromISR+0x24>
 8001916:	b672      	cpsid	i
 8001918:	e7fe      	b.n	8001918 <xQueueGenericSendFromISR+0x22>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800191a:	2e02      	cmp	r6, #2
 800191c:	d104      	bne.n	8001928 <xQueueGenericSendFromISR+0x32>
 800191e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001920:	2b01      	cmp	r3, #1
 8001922:	d001      	beq.n	8001928 <xQueueGenericSendFromISR+0x32>
 8001924:	b672      	cpsid	i
 8001926:	e7fe      	b.n	8001926 <xQueueGenericSendFromISR+0x30>
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001928:	f000 fe54 	bl	80025d4 <ulSetInterruptMaskFromISR>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800192c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800192e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8001930:	9003      	str	r0, [sp, #12]
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001932:	4293      	cmp	r3, r2
 8001934:	d302      	bcc.n	800193c <xQueueGenericSendFromISR+0x46>
            xReturn = errQUEUE_FULL;
 8001936:	2500      	movs	r5, #0
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001938:	2e02      	cmp	r6, #2
 800193a:	d11b      	bne.n	8001974 <xQueueGenericSendFromISR+0x7e>
            const int8_t cTxLock = pxQueue->cTxLock;
 800193c:	0023      	movs	r3, r4
 800193e:	3345      	adds	r3, #69	; 0x45
 8001940:	9302      	str	r3, [sp, #8]
 8001942:	781d      	ldrb	r5, [r3, #0]
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001944:	0032      	movs	r2, r6
            const int8_t cTxLock = pxQueue->cTxLock;
 8001946:	b26d      	sxtb	r5, r5
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001948:	0020      	movs	r0, r4
 800194a:	9901      	ldr	r1, [sp, #4]
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 800194c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800194e:	f7ff fe66 	bl	800161e <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
 8001952:	1c6b      	adds	r3, r5, #1
 8001954:	d114      	bne.n	8001980 <xQueueGenericSendFromISR+0x8a>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001956:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001958:	2b00      	cmp	r3, #0
 800195a:	d101      	bne.n	8001960 <xQueueGenericSendFromISR+0x6a>
            xReturn = pdPASS;
 800195c:	2501      	movs	r5, #1
 800195e:	e009      	b.n	8001974 <xQueueGenericSendFromISR+0x7e>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001960:	0020      	movs	r0, r4
 8001962:	3024      	adds	r0, #36	; 0x24
 8001964:	f000 fb78 	bl	8002058 <xTaskRemoveFromEventList>
 8001968:	2800      	cmp	r0, #0
 800196a:	d0f7      	beq.n	800195c <xQueueGenericSendFromISR+0x66>
                                if( pxHigherPriorityTaskWoken != NULL )
 800196c:	2f00      	cmp	r7, #0
 800196e:	d0f5      	beq.n	800195c <xQueueGenericSendFromISR+0x66>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8001970:	2501      	movs	r5, #1
 8001972:	603d      	str	r5, [r7, #0]
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8001974:	9803      	ldr	r0, [sp, #12]
 8001976:	f000 fe31 	bl	80025dc <vClearInterruptMaskFromISR>
}
 800197a:	0028      	movs	r0, r5
 800197c:	b005      	add	sp, #20
 800197e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                configASSERT( cTxLock != queueINT8_MAX );
 8001980:	2d7f      	cmp	r5, #127	; 0x7f
 8001982:	d101      	bne.n	8001988 <xQueueGenericSendFromISR+0x92>
 8001984:	b672      	cpsid	i
 8001986:	e7fe      	b.n	8001986 <xQueueGenericSendFromISR+0x90>
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001988:	9b02      	ldr	r3, [sp, #8]
 800198a:	3501      	adds	r5, #1
 800198c:	b26d      	sxtb	r5, r5
 800198e:	701d      	strb	r5, [r3, #0]
 8001990:	e7e4      	b.n	800195c <xQueueGenericSendFromISR+0x66>

08001992 <xQueueReceive>:
{
 8001992:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001994:	b085      	sub	sp, #20
 8001996:	0004      	movs	r4, r0
 8001998:	000f      	movs	r7, r1
 800199a:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 800199c:	2800      	cmp	r0, #0
 800199e:	d101      	bne.n	80019a4 <xQueueReceive+0x12>
 80019a0:	b672      	cpsid	i
 80019a2:	e7fe      	b.n	80019a2 <xQueueReceive+0x10>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80019a4:	2900      	cmp	r1, #0
 80019a6:	d104      	bne.n	80019b2 <xQueueReceive+0x20>
 80019a8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80019aa:	2b00      	cmp	r3, #0
 80019ac:	d001      	beq.n	80019b2 <xQueueReceive+0x20>
 80019ae:	b672      	cpsid	i
 80019b0:	e7fe      	b.n	80019b0 <xQueueReceive+0x1e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80019b2:	f000 fbd1 	bl	8002158 <xTaskGetSchedulerState>
 80019b6:	1e06      	subs	r6, r0, #0
 80019b8:	d104      	bne.n	80019c4 <xQueueReceive+0x32>
 80019ba:	9b01      	ldr	r3, [sp, #4]
 80019bc:	2b00      	cmp	r3, #0
 80019be:	d041      	beq.n	8001a44 <xQueueReceive+0xb2>
 80019c0:	b672      	cpsid	i
 80019c2:	e7fe      	b.n	80019c2 <xQueueReceive+0x30>
 80019c4:	2600      	movs	r6, #0
 80019c6:	e03d      	b.n	8001a44 <xQueueReceive+0xb2>
                if( xTicksToWait == ( TickType_t ) 0 )
 80019c8:	9d01      	ldr	r5, [sp, #4]
 80019ca:	2d00      	cmp	r5, #0
 80019cc:	d103      	bne.n	80019d6 <xQueueReceive+0x44>
                    taskEXIT_CRITICAL();
 80019ce:	f000 fdf3 	bl	80025b8 <vPortExitCritical>
                return errQUEUE_EMPTY;
 80019d2:	2000      	movs	r0, #0
 80019d4:	e04b      	b.n	8001a6e <xQueueReceive+0xdc>
                else if( xEntryTimeSet == pdFALSE )
 80019d6:	2e00      	cmp	r6, #0
 80019d8:	d102      	bne.n	80019e0 <xQueueReceive+0x4e>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 80019da:	a802      	add	r0, sp, #8
 80019dc:	f000 fb78 	bl	80020d0 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 80019e0:	f000 fdea 	bl	80025b8 <vPortExitCritical>
        vTaskSuspendAll();
 80019e4:	f000 fa06 	bl	8001df4 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 80019e8:	f000 fdda 	bl	80025a0 <vPortEnterCritical>
 80019ec:	0022      	movs	r2, r4
 80019ee:	3244      	adds	r2, #68	; 0x44
 80019f0:	7813      	ldrb	r3, [r2, #0]
 80019f2:	b25b      	sxtb	r3, r3
 80019f4:	3301      	adds	r3, #1
 80019f6:	d101      	bne.n	80019fc <xQueueReceive+0x6a>
 80019f8:	2300      	movs	r3, #0
 80019fa:	7013      	strb	r3, [r2, #0]
 80019fc:	0022      	movs	r2, r4
 80019fe:	3245      	adds	r2, #69	; 0x45
 8001a00:	7813      	ldrb	r3, [r2, #0]
 8001a02:	b25b      	sxtb	r3, r3
 8001a04:	3301      	adds	r3, #1
 8001a06:	d101      	bne.n	8001a0c <xQueueReceive+0x7a>
 8001a08:	2300      	movs	r3, #0
 8001a0a:	7013      	strb	r3, [r2, #0]
 8001a0c:	f000 fdd4 	bl	80025b8 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001a10:	a901      	add	r1, sp, #4
 8001a12:	a802      	add	r0, sp, #8
 8001a14:	f000 fb68 	bl	80020e8 <xTaskCheckForTimeOut>
 8001a18:	2800      	cmp	r0, #0
 8001a1a:	d130      	bne.n	8001a7e <xQueueReceive+0xec>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001a1c:	0020      	movs	r0, r4
 8001a1e:	f7ff fdf4 	bl	800160a <prvIsQueueEmpty>
 8001a22:	2800      	cmp	r0, #0
 8001a24:	d025      	beq.n	8001a72 <xQueueReceive+0xe0>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8001a26:	0020      	movs	r0, r4
 8001a28:	9901      	ldr	r1, [sp, #4]
 8001a2a:	3024      	adds	r0, #36	; 0x24
 8001a2c:	f000 faea 	bl	8002004 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 8001a30:	0020      	movs	r0, r4
 8001a32:	f7ff fe41 	bl	80016b8 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 8001a36:	f000 fa4d 	bl	8001ed4 <xTaskResumeAll>
 8001a3a:	2800      	cmp	r0, #0
 8001a3c:	d101      	bne.n	8001a42 <xQueueReceive+0xb0>
                    portYIELD_WITHIN_API();
 8001a3e:	f000 fda3 	bl	8002588 <vPortYield>
 8001a42:	2601      	movs	r6, #1
        taskENTER_CRITICAL();
 8001a44:	f000 fdac 	bl	80025a0 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001a48:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001a4a:	2d00      	cmp	r5, #0
 8001a4c:	d0bc      	beq.n	80019c8 <xQueueReceive+0x36>
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001a4e:	0039      	movs	r1, r7
 8001a50:	0020      	movs	r0, r4
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001a52:	3d01      	subs	r5, #1
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8001a54:	f7ff fe1e 	bl	8001694 <prvCopyDataFromQueue>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001a58:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001a5a:	6923      	ldr	r3, [r4, #16]
 8001a5c:	2b00      	cmp	r3, #0
 8001a5e:	d003      	beq.n	8001a68 <xQueueReceive+0xd6>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001a60:	0020      	movs	r0, r4
 8001a62:	3010      	adds	r0, #16
 8001a64:	f000 faf8 	bl	8002058 <xTaskRemoveFromEventList>
                taskEXIT_CRITICAL();
 8001a68:	f000 fda6 	bl	80025b8 <vPortExitCritical>
                return pdPASS;
 8001a6c:	2001      	movs	r0, #1
}
 8001a6e:	b005      	add	sp, #20
 8001a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
                prvUnlockQueue( pxQueue );
 8001a72:	0020      	movs	r0, r4
 8001a74:	f7ff fe20 	bl	80016b8 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8001a78:	f000 fa2c 	bl	8001ed4 <xTaskResumeAll>
 8001a7c:	e7e1      	b.n	8001a42 <xQueueReceive+0xb0>
            prvUnlockQueue( pxQueue );
 8001a7e:	0020      	movs	r0, r4
 8001a80:	f7ff fe1a 	bl	80016b8 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8001a84:	f000 fa26 	bl	8001ed4 <xTaskResumeAll>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8001a88:	0020      	movs	r0, r4
 8001a8a:	f7ff fdbe 	bl	800160a <prvIsQueueEmpty>
 8001a8e:	2800      	cmp	r0, #0
 8001a90:	d0d7      	beq.n	8001a42 <xQueueReceive+0xb0>
 8001a92:	e79e      	b.n	80019d2 <xQueueReceive+0x40>

08001a94 <vQueueAddToRegistry>:
    {
        UBaseType_t ux;

        /* See if there is an empty space in the registry.  A NULL name denotes
         * a free slot. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001a94:	2300      	movs	r3, #0
    {
 8001a96:	b570      	push	{r4, r5, r6, lr}
        {
            if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8001a98:	4a06      	ldr	r2, [pc, #24]	; (8001ab4 <vQueueAddToRegistry+0x20>)
 8001a9a:	00dd      	lsls	r5, r3, #3
 8001a9c:	18ac      	adds	r4, r5, r2
 8001a9e:	6826      	ldr	r6, [r4, #0]
 8001aa0:	2e00      	cmp	r6, #0
 8001aa2:	d102      	bne.n	8001aaa <vQueueAddToRegistry+0x16>
            {
                /* Store the information on this queue. */
                xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8001aa4:	50a9      	str	r1, [r5, r2]
                xQueueRegistry[ ux ].xHandle = xQueue;
 8001aa6:	6060      	str	r0, [r4, #4]
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
 8001aa8:	bd70      	pop	{r4, r5, r6, pc}
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001aaa:	3301      	adds	r3, #1
 8001aac:	2b08      	cmp	r3, #8
 8001aae:	d1f4      	bne.n	8001a9a <vQueueAddToRegistry+0x6>
 8001ab0:	e7fa      	b.n	8001aa8 <vQueueAddToRegistry+0x14>
 8001ab2:	46c0      	nop			; (mov r8, r8)
 8001ab4:	20000860 	.word	0x20000860

08001ab8 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 8001ab8:	b570      	push	{r4, r5, r6, lr}
 8001aba:	0004      	movs	r4, r0
 8001abc:	0016      	movs	r6, r2
 8001abe:	000d      	movs	r5, r1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 8001ac0:	f000 fd6e 	bl	80025a0 <vPortEnterCritical>
 8001ac4:	0022      	movs	r2, r4
 8001ac6:	3244      	adds	r2, #68	; 0x44
 8001ac8:	7813      	ldrb	r3, [r2, #0]
 8001aca:	b25b      	sxtb	r3, r3
 8001acc:	3301      	adds	r3, #1
 8001ace:	d101      	bne.n	8001ad4 <vQueueWaitForMessageRestricted+0x1c>
 8001ad0:	2300      	movs	r3, #0
 8001ad2:	7013      	strb	r3, [r2, #0]
 8001ad4:	0022      	movs	r2, r4
 8001ad6:	3245      	adds	r2, #69	; 0x45
 8001ad8:	7813      	ldrb	r3, [r2, #0]
 8001ada:	b25b      	sxtb	r3, r3
 8001adc:	3301      	adds	r3, #1
 8001ade:	d101      	bne.n	8001ae4 <vQueueWaitForMessageRestricted+0x2c>
 8001ae0:	2300      	movs	r3, #0
 8001ae2:	7013      	strb	r3, [r2, #0]
 8001ae4:	f000 fd68 	bl	80025b8 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8001ae8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001aea:	2b00      	cmp	r3, #0
 8001aec:	d105      	bne.n	8001afa <vQueueWaitForMessageRestricted+0x42>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8001aee:	0020      	movs	r0, r4
 8001af0:	0032      	movs	r2, r6
 8001af2:	0029      	movs	r1, r5
 8001af4:	3024      	adds	r0, #36	; 0x24
 8001af6:	f000 fa97 	bl	8002028 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
 8001afa:	0020      	movs	r0, r4
 8001afc:	f7ff fddc 	bl	80016b8 <prvUnlockQueue>
    }
 8001b00:	bd70      	pop	{r4, r5, r6, pc}
	...

08001b04 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001b04:	4a06      	ldr	r2, [pc, #24]	; (8001b20 <prvResetNextTaskUnblockTime+0x1c>)
 8001b06:	6813      	ldr	r3, [r2, #0]
 8001b08:	6819      	ldr	r1, [r3, #0]
 8001b0a:	4b06      	ldr	r3, [pc, #24]	; (8001b24 <prvResetNextTaskUnblockTime+0x20>)
 8001b0c:	2900      	cmp	r1, #0
 8001b0e:	d103      	bne.n	8001b18 <prvResetNextTaskUnblockTime+0x14>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 8001b10:	2201      	movs	r2, #1
 8001b12:	4252      	negs	r2, r2
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001b14:	601a      	str	r2, [r3, #0]
    }
}
 8001b16:	4770      	bx	lr
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8001b18:	6812      	ldr	r2, [r2, #0]
 8001b1a:	68d2      	ldr	r2, [r2, #12]
 8001b1c:	6812      	ldr	r2, [r2, #0]
 8001b1e:	e7f9      	b.n	8001b14 <prvResetNextTaskUnblockTime+0x10>
 8001b20:	20000030 	.word	0x20000030
 8001b24:	200000dc 	.word	0x200000dc

08001b28 <prvAddCurrentTaskToDelayedList>:
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8001b28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001b2a:	0004      	movs	r4, r0
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8001b2c:	4b14      	ldr	r3, [pc, #80]	; (8001b80 <prvAddCurrentTaskToDelayedList+0x58>)
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001b2e:	4d15      	ldr	r5, [pc, #84]	; (8001b84 <prvAddCurrentTaskToDelayedList+0x5c>)
    const TickType_t xConstTickCount = xTickCount;
 8001b30:	681e      	ldr	r6, [r3, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001b32:	6828      	ldr	r0, [r5, #0]
{
 8001b34:	000f      	movs	r7, r1
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8001b36:	3004      	adds	r0, #4
 8001b38:	f7ff fd57 	bl	80015ea <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8001b3c:	1c63      	adds	r3, r4, #1
 8001b3e:	d107      	bne.n	8001b50 <prvAddCurrentTaskToDelayedList+0x28>
 8001b40:	2f00      	cmp	r7, #0
 8001b42:	d005      	beq.n	8001b50 <prvAddCurrentTaskToDelayedList+0x28>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001b44:	6829      	ldr	r1, [r5, #0]
 8001b46:	4810      	ldr	r0, [pc, #64]	; (8001b88 <prvAddCurrentTaskToDelayedList+0x60>)
 8001b48:	3104      	adds	r1, #4
 8001b4a:	f7ff fd2b 	bl	80015a4 <vListInsertEnd>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 8001b4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001b50:	682b      	ldr	r3, [r5, #0]
                xTimeToWake = xConstTickCount + xTicksToWait;
 8001b52:	1934      	adds	r4, r6, r4
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8001b54:	605c      	str	r4, [r3, #4]
                if( xTimeToWake < xConstTickCount )
 8001b56:	42a6      	cmp	r6, r4
 8001b58:	d906      	bls.n	8001b68 <prvAddCurrentTaskToDelayedList+0x40>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001b5a:	4b0c      	ldr	r3, [pc, #48]	; (8001b8c <prvAddCurrentTaskToDelayedList+0x64>)
 8001b5c:	6818      	ldr	r0, [r3, #0]
 8001b5e:	6829      	ldr	r1, [r5, #0]
 8001b60:	3104      	adds	r1, #4
 8001b62:	f7ff fd2b 	bl	80015bc <vListInsert>
 8001b66:	e7f2      	b.n	8001b4e <prvAddCurrentTaskToDelayedList+0x26>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8001b68:	4b09      	ldr	r3, [pc, #36]	; (8001b90 <prvAddCurrentTaskToDelayedList+0x68>)
 8001b6a:	6818      	ldr	r0, [r3, #0]
 8001b6c:	6829      	ldr	r1, [r5, #0]
 8001b6e:	3104      	adds	r1, #4
 8001b70:	f7ff fd24 	bl	80015bc <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8001b74:	4b07      	ldr	r3, [pc, #28]	; (8001b94 <prvAddCurrentTaskToDelayedList+0x6c>)
 8001b76:	681a      	ldr	r2, [r3, #0]
 8001b78:	42a2      	cmp	r2, r4
 8001b7a:	d9e8      	bls.n	8001b4e <prvAddCurrentTaskToDelayedList+0x26>
                        xNextTaskUnblockTime = xTimeToWake;
 8001b7c:	601c      	str	r4, [r3, #0]
}
 8001b7e:	e7e6      	b.n	8001b4e <prvAddCurrentTaskToDelayedList+0x26>
 8001b80:	20000128 	.word	0x20000128
 8001b84:	2000002c 	.word	0x2000002c
 8001b88:	20000100 	.word	0x20000100
 8001b8c:	20000034 	.word	0x20000034
 8001b90:	20000030 	.word	0x20000030
 8001b94:	200000dc 	.word	0x200000dc

08001b98 <prvIdleTask>:
{
 8001b98:	b570      	push	{r4, r5, r6, lr}
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001b9a:	4c0f      	ldr	r4, [pc, #60]	; (8001bd8 <prvIdleTask+0x40>)
 8001b9c:	6823      	ldr	r3, [r4, #0]
 8001b9e:	2b00      	cmp	r3, #0
 8001ba0:	d102      	bne.n	8001ba8 <prvIdleTask+0x10>
                taskYIELD();
 8001ba2:	f000 fcf1 	bl	8002588 <vPortYield>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8001ba6:	e7f8      	b.n	8001b9a <prvIdleTask+0x2>
                taskENTER_CRITICAL();
 8001ba8:	f000 fcfa 	bl	80025a0 <vPortEnterCritical>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001bac:	4b0b      	ldr	r3, [pc, #44]	; (8001bdc <prvIdleTask+0x44>)
 8001bae:	68db      	ldr	r3, [r3, #12]
 8001bb0:	68dd      	ldr	r5, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001bb2:	1d28      	adds	r0, r5, #4
 8001bb4:	f7ff fd19 	bl	80015ea <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8001bb8:	4a09      	ldr	r2, [pc, #36]	; (8001be0 <prvIdleTask+0x48>)
 8001bba:	6813      	ldr	r3, [r2, #0]
 8001bbc:	3b01      	subs	r3, #1
 8001bbe:	6013      	str	r3, [r2, #0]
                    --uxDeletedTasksWaitingCleanUp;
 8001bc0:	6823      	ldr	r3, [r4, #0]
 8001bc2:	3b01      	subs	r3, #1
 8001bc4:	6023      	str	r3, [r4, #0]
                taskEXIT_CRITICAL();
 8001bc6:	f000 fcf7 	bl	80025b8 <vPortExitCritical>
                vPortFree( pxTCB->pxStack );
 8001bca:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8001bcc:	f000 fe2a 	bl	8002824 <vPortFree>
                vPortFree( pxTCB );
 8001bd0:	0028      	movs	r0, r5
 8001bd2:	f000 fe27 	bl	8002824 <vPortFree>
    }
 8001bd6:	e7e0      	b.n	8001b9a <prvIdleTask+0x2>
 8001bd8:	200000a0 	.word	0x200000a0
 8001bdc:	20000114 	.word	0x20000114
 8001be0:	2000009c 	.word	0x2000009c

08001be4 <xTaskCreate>:
    {
 8001be4:	b5f0      	push	{r4, r5, r6, r7, lr}
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001be6:	0095      	lsls	r5, r2, #2
    {
 8001be8:	b085      	sub	sp, #20
 8001bea:	9002      	str	r0, [sp, #8]
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001bec:	0028      	movs	r0, r5
    {
 8001bee:	000c      	movs	r4, r1
 8001bf0:	9303      	str	r3, [sp, #12]
                pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8001bf2:	f000 fd8d 	bl	8002710 <pvPortMalloc>
 8001bf6:	1e06      	subs	r6, r0, #0
                if( pxStack != NULL )
 8001bf8:	d018      	beq.n	8001c2c <xTaskCreate+0x48>
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8001bfa:	2054      	movs	r0, #84	; 0x54
 8001bfc:	f000 fd88 	bl	8002710 <pvPortMalloc>
 8001c00:	1e07      	subs	r7, r0, #0
                    if( pxNewTCB != NULL )
 8001c02:	d010      	beq.n	8001c26 <xTaskCreate+0x42>
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8001c04:	002a      	movs	r2, r5
                        pxNewTCB->pxStack = pxStack;
 8001c06:	6306      	str	r6, [r0, #48]	; 0x30
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8001c08:	21a5      	movs	r1, #165	; 0xa5
 8001c0a:	0030      	movs	r0, r6
 8001c0c:	f000 fe61 	bl	80028d2 <memset>
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001c10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001c12:	003a      	movs	r2, r7
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001c14:	9300      	str	r3, [sp, #0]
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001c16:	2300      	movs	r3, #0
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001c18:	3234      	adds	r2, #52	; 0x34
    if( pcName != NULL )
 8001c1a:	429c      	cmp	r4, r3
 8001c1c:	d109      	bne.n	8001c32 <xTaskCreate+0x4e>
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8001c1e:	003b      	movs	r3, r7
 8001c20:	3334      	adds	r3, #52	; 0x34
 8001c22:	701c      	strb	r4, [r3, #0]
 8001c24:	e011      	b.n	8001c4a <xTaskCreate+0x66>
                        vPortFree( pxStack );
 8001c26:	0030      	movs	r0, r6
 8001c28:	f000 fdfc 	bl	8002824 <vPortFree>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001c2c:	2001      	movs	r0, #1
 8001c2e:	4240      	negs	r0, r0
 8001c30:	e088      	b.n	8001d44 <xTaskCreate+0x160>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8001c32:	5ce1      	ldrb	r1, [r4, r3]
 8001c34:	54d1      	strb	r1, [r2, r3]
            if( pcName[ x ] == ( char ) 0x00 )
 8001c36:	5ce1      	ldrb	r1, [r4, r3]
 8001c38:	2900      	cmp	r1, #0
 8001c3a:	d002      	beq.n	8001c42 <xTaskCreate+0x5e>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8001c3c:	3301      	adds	r3, #1
 8001c3e:	2b05      	cmp	r3, #5
 8001c40:	d1f7      	bne.n	8001c32 <xTaskCreate+0x4e>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8001c42:	003b      	movs	r3, r7
 8001c44:	2200      	movs	r2, #0
 8001c46:	3338      	adds	r3, #56	; 0x38
 8001c48:	701a      	strb	r2, [r3, #0]
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8001c4a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8001c4c:	2c04      	cmp	r4, #4
 8001c4e:	d900      	bls.n	8001c52 <xTaskCreate+0x6e>
 8001c50:	2404      	movs	r4, #4
            pxNewTCB->uxMutexesHeld = 0;
 8001c52:	2600      	movs	r6, #0
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001c54:	1d3b      	adds	r3, r7, #4
 8001c56:	0018      	movs	r0, r3
    pxNewTCB->uxPriority = uxPriority;
 8001c58:	62fc      	str	r4, [r7, #44]	; 0x2c
            pxNewTCB->uxBasePriority = uxPriority;
 8001c5a:	647c      	str	r4, [r7, #68]	; 0x44
            pxNewTCB->uxMutexesHeld = 0;
 8001c5c:	64be      	str	r6, [r7, #72]	; 0x48
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8001c5e:	9301      	str	r3, [sp, #4]
 8001c60:	f7ff fc9d 	bl	800159e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8001c64:	0038      	movs	r0, r7
 8001c66:	3018      	adds	r0, #24
 8001c68:	f7ff fc99 	bl	800159e <vListInitialiseItem>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001c6c:	2305      	movs	r3, #5
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001c6e:	0038      	movs	r0, r7
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001c70:	1b1c      	subs	r4, r3, r4
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001c72:	2204      	movs	r2, #4
 8001c74:	0031      	movs	r1, r6
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8001c76:	613f      	str	r7, [r7, #16]
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001c78:	61bc      	str	r4, [r7, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8001c7a:	627f      	str	r7, [r7, #36]	; 0x24
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8001c7c:	304c      	adds	r0, #76	; 0x4c
 8001c7e:	f000 fe28 	bl	80028d2 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 8001c82:	003b      	movs	r3, r7
 8001c84:	3350      	adds	r3, #80	; 0x50
 8001c86:	701e      	strb	r6, [r3, #0]
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8001c88:	9b00      	ldr	r3, [sp, #0]
 8001c8a:	1f28      	subs	r0, r5, #4
 8001c8c:	1818      	adds	r0, r3, r0
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8001c8e:	2307      	movs	r3, #7
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001c90:	9a03      	ldr	r2, [sp, #12]
            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 8001c92:	4398      	bics	r0, r3
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001c94:	9902      	ldr	r1, [sp, #8]
 8001c96:	f000 fc65 	bl	8002564 <pxPortInitialiseStack>
    if( pxCreatedTask != NULL )
 8001c9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001c9c:	6038      	str	r0, [r7, #0]
    if( pxCreatedTask != NULL )
 8001c9e:	42b3      	cmp	r3, r6
 8001ca0:	d000      	beq.n	8001ca4 <xTaskCreate+0xc0>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8001ca2:	601f      	str	r7, [r3, #0]
    taskENTER_CRITICAL();
 8001ca4:	f000 fc7c 	bl	80025a0 <vPortEnterCritical>
        uxCurrentNumberOfTasks++;
 8001ca8:	4b2c      	ldr	r3, [pc, #176]	; (8001d5c <xTaskCreate+0x178>)
        if( pxCurrentTCB == NULL )
 8001caa:	4d2d      	ldr	r5, [pc, #180]	; (8001d60 <xTaskCreate+0x17c>)
        uxCurrentNumberOfTasks++;
 8001cac:	681a      	ldr	r2, [r3, #0]
 8001cae:	4c2d      	ldr	r4, [pc, #180]	; (8001d64 <xTaskCreate+0x180>)
 8001cb0:	3201      	adds	r2, #1
 8001cb2:	601a      	str	r2, [r3, #0]
        if( pxCurrentTCB == NULL )
 8001cb4:	682a      	ldr	r2, [r5, #0]
 8001cb6:	4e2c      	ldr	r6, [pc, #176]	; (8001d68 <xTaskCreate+0x184>)
 8001cb8:	2a00      	cmp	r2, #0
 8001cba:	d145      	bne.n	8001d48 <xTaskCreate+0x164>
            pxCurrentTCB = pxNewTCB;
 8001cbc:	602f      	str	r7, [r5, #0]
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8001cbe:	681b      	ldr	r3, [r3, #0]
 8001cc0:	2b01      	cmp	r3, #1
 8001cc2:	d127      	bne.n	8001d14 <xTaskCreate+0x130>
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8001cc4:	0020      	movs	r0, r4
 8001cc6:	f7ff fc5f 	bl	8001588 <vListInitialise>
 8001cca:	0020      	movs	r0, r4
 8001ccc:	3014      	adds	r0, #20
 8001cce:	f7ff fc5b 	bl	8001588 <vListInitialise>
 8001cd2:	0020      	movs	r0, r4
 8001cd4:	3028      	adds	r0, #40	; 0x28
 8001cd6:	f7ff fc57 	bl	8001588 <vListInitialise>
 8001cda:	0020      	movs	r0, r4
 8001cdc:	303c      	adds	r0, #60	; 0x3c
 8001cde:	f7ff fc53 	bl	8001588 <vListInitialise>
 8001ce2:	0020      	movs	r0, r4
 8001ce4:	3050      	adds	r0, #80	; 0x50
 8001ce6:	f7ff fc4f 	bl	8001588 <vListInitialise>
    vListInitialise( &xDelayedTaskList1 );
 8001cea:	4820      	ldr	r0, [pc, #128]	; (8001d6c <xTaskCreate+0x188>)
 8001cec:	f7ff fc4c 	bl	8001588 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8001cf0:	481f      	ldr	r0, [pc, #124]	; (8001d70 <xTaskCreate+0x18c>)
 8001cf2:	f7ff fc49 	bl	8001588 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8001cf6:	481f      	ldr	r0, [pc, #124]	; (8001d74 <xTaskCreate+0x190>)
 8001cf8:	f7ff fc46 	bl	8001588 <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
 8001cfc:	481e      	ldr	r0, [pc, #120]	; (8001d78 <xTaskCreate+0x194>)
 8001cfe:	f7ff fc43 	bl	8001588 <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
 8001d02:	481e      	ldr	r0, [pc, #120]	; (8001d7c <xTaskCreate+0x198>)
 8001d04:	f7ff fc40 	bl	8001588 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
 8001d08:	4b1d      	ldr	r3, [pc, #116]	; (8001d80 <xTaskCreate+0x19c>)
 8001d0a:	4a18      	ldr	r2, [pc, #96]	; (8001d6c <xTaskCreate+0x188>)
 8001d0c:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8001d0e:	4b1d      	ldr	r3, [pc, #116]	; (8001d84 <xTaskCreate+0x1a0>)
 8001d10:	4a17      	ldr	r2, [pc, #92]	; (8001d70 <xTaskCreate+0x18c>)
 8001d12:	601a      	str	r2, [r3, #0]
        uxTaskNumber++;
 8001d14:	4a1c      	ldr	r2, [pc, #112]	; (8001d88 <xTaskCreate+0x1a4>)
 8001d16:	6813      	ldr	r3, [r2, #0]
 8001d18:	3301      	adds	r3, #1
 8001d1a:	6013      	str	r3, [r2, #0]
        prvAddTaskToReadyList( pxNewTCB );
 8001d1c:	4a1b      	ldr	r2, [pc, #108]	; (8001d8c <xTaskCreate+0x1a8>)
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 8001d1e:	63fb      	str	r3, [r7, #60]	; 0x3c
        prvAddTaskToReadyList( pxNewTCB );
 8001d20:	6811      	ldr	r1, [r2, #0]
 8001d22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001d24:	428b      	cmp	r3, r1
 8001d26:	d900      	bls.n	8001d2a <xTaskCreate+0x146>
 8001d28:	6013      	str	r3, [r2, #0]
 8001d2a:	2014      	movs	r0, #20
 8001d2c:	4358      	muls	r0, r3
 8001d2e:	9901      	ldr	r1, [sp, #4]
 8001d30:	1820      	adds	r0, r4, r0
 8001d32:	f7ff fc37 	bl	80015a4 <vListInsertEnd>
    taskEXIT_CRITICAL();
 8001d36:	f000 fc3f 	bl	80025b8 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 8001d3a:	6833      	ldr	r3, [r6, #0]
            xReturn = pdPASS;
 8001d3c:	2001      	movs	r0, #1
    if( xSchedulerRunning != pdFALSE )
 8001d3e:	2b00      	cmp	r3, #0
 8001d40:	d000      	beq.n	8001d44 <xTaskCreate+0x160>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8001d42:	682b      	ldr	r3, [r5, #0]
    }
 8001d44:	b005      	add	sp, #20
 8001d46:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( xSchedulerRunning == pdFALSE )
 8001d48:	6833      	ldr	r3, [r6, #0]
 8001d4a:	2b00      	cmp	r3, #0
 8001d4c:	d1e2      	bne.n	8001d14 <xTaskCreate+0x130>
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8001d4e:	682b      	ldr	r3, [r5, #0]
 8001d50:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001d52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d54:	4293      	cmp	r3, r2
 8001d56:	d8dd      	bhi.n	8001d14 <xTaskCreate+0x130>
                    pxCurrentTCB = pxNewTCB;
 8001d58:	602f      	str	r7, [r5, #0]
 8001d5a:	e7db      	b.n	8001d14 <xTaskCreate+0x130>
 8001d5c:	2000009c 	.word	0x2000009c
 8001d60:	2000002c 	.word	0x2000002c
 8001d64:	20000038 	.word	0x20000038
 8001d68:	200000fc 	.word	0x200000fc
 8001d6c:	200000b0 	.word	0x200000b0
 8001d70:	200000c4 	.word	0x200000c4
 8001d74:	200000e8 	.word	0x200000e8
 8001d78:	20000114 	.word	0x20000114
 8001d7c:	20000100 	.word	0x20000100
 8001d80:	20000030 	.word	0x20000030
 8001d84:	20000034 	.word	0x20000034
 8001d88:	200000a8 	.word	0x200000a8
 8001d8c:	200000ac 	.word	0x200000ac

08001d90 <vTaskStartScheduler>:
{
 8001d90:	b513      	push	{r0, r1, r4, lr}
            xReturn = xTaskCreate( prvIdleTask,
 8001d92:	2400      	movs	r4, #0
 8001d94:	4b10      	ldr	r3, [pc, #64]	; (8001dd8 <vTaskStartScheduler+0x48>)
 8001d96:	223c      	movs	r2, #60	; 0x3c
 8001d98:	9301      	str	r3, [sp, #4]
 8001d9a:	4910      	ldr	r1, [pc, #64]	; (8001ddc <vTaskStartScheduler+0x4c>)
 8001d9c:	0023      	movs	r3, r4
 8001d9e:	4810      	ldr	r0, [pc, #64]	; (8001de0 <vTaskStartScheduler+0x50>)
 8001da0:	9400      	str	r4, [sp, #0]
 8001da2:	f7ff ff1f 	bl	8001be4 <xTaskCreate>
            if( xReturn == pdPASS )
 8001da6:	2801      	cmp	r0, #1
 8001da8:	d111      	bne.n	8001dce <vTaskStartScheduler+0x3e>
                xReturn = xTimerCreateTimerTask();
 8001daa:	f000 fa67 	bl	800227c <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 8001dae:	2801      	cmp	r0, #1
 8001db0:	d10d      	bne.n	8001dce <vTaskStartScheduler+0x3e>
        portDISABLE_INTERRUPTS();
 8001db2:	b672      	cpsid	i
        xNextTaskUnblockTime = portMAX_DELAY;
 8001db4:	2201      	movs	r2, #1
 8001db6:	4b0b      	ldr	r3, [pc, #44]	; (8001de4 <vTaskStartScheduler+0x54>)
 8001db8:	4252      	negs	r2, r2
 8001dba:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8001dbc:	4b0a      	ldr	r3, [pc, #40]	; (8001de8 <vTaskStartScheduler+0x58>)
 8001dbe:	6018      	str	r0, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8001dc0:	4b0a      	ldr	r3, [pc, #40]	; (8001dec <vTaskStartScheduler+0x5c>)
 8001dc2:	601c      	str	r4, [r3, #0]
        if( xPortStartScheduler() != pdFALSE )
 8001dc4:	f000 fc62 	bl	800268c <xPortStartScheduler>
    ( void ) uxTopUsedPriority;
 8001dc8:	4b09      	ldr	r3, [pc, #36]	; (8001df0 <vTaskStartScheduler+0x60>)
 8001dca:	681b      	ldr	r3, [r3, #0]
}
 8001dcc:	bd13      	pop	{r0, r1, r4, pc}
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8001dce:	1c43      	adds	r3, r0, #1
 8001dd0:	d1fa      	bne.n	8001dc8 <vTaskStartScheduler+0x38>
 8001dd2:	b672      	cpsid	i
 8001dd4:	e7fe      	b.n	8001dd4 <vTaskStartScheduler+0x44>
 8001dd6:	46c0      	nop			; (mov r8, r8)
 8001dd8:	200000d8 	.word	0x200000d8
 8001ddc:	08002942 	.word	0x08002942
 8001de0:	08001b99 	.word	0x08001b99
 8001de4:	200000dc 	.word	0x200000dc
 8001de8:	200000fc 	.word	0x200000fc
 8001dec:	20000128 	.word	0x20000128
 8001df0:	20000008 	.word	0x20000008

08001df4 <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 8001df4:	4a02      	ldr	r2, [pc, #8]	; (8001e00 <vTaskSuspendAll+0xc>)
 8001df6:	6813      	ldr	r3, [r2, #0]
 8001df8:	3301      	adds	r3, #1
 8001dfa:	6013      	str	r3, [r2, #0]
}
 8001dfc:	4770      	bx	lr
 8001dfe:	46c0      	nop			; (mov r8, r8)
 8001e00:	200000a4 	.word	0x200000a4

08001e04 <xTaskGetTickCount>:
        xTicks = xTickCount;
 8001e04:	4b01      	ldr	r3, [pc, #4]	; (8001e0c <xTaskGetTickCount+0x8>)
 8001e06:	6818      	ldr	r0, [r3, #0]
}
 8001e08:	4770      	bx	lr
 8001e0a:	46c0      	nop			; (mov r8, r8)
 8001e0c:	20000128 	.word	0x20000128

08001e10 <xTaskIncrementTick>:
{
 8001e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001e12:	4b27      	ldr	r3, [pc, #156]	; (8001eb0 <xTaskIncrementTick+0xa0>)
 8001e14:	681b      	ldr	r3, [r3, #0]
 8001e16:	2b00      	cmp	r3, #0
 8001e18:	d144      	bne.n	8001ea4 <xTaskIncrementTick+0x94>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8001e1a:	4b26      	ldr	r3, [pc, #152]	; (8001eb4 <xTaskIncrementTick+0xa4>)
 8001e1c:	681c      	ldr	r4, [r3, #0]
 8001e1e:	3401      	adds	r4, #1
        xTickCount = xConstTickCount;
 8001e20:	601c      	str	r4, [r3, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8001e22:	2c00      	cmp	r4, #0
 8001e24:	d111      	bne.n	8001e4a <xTaskIncrementTick+0x3a>
            taskSWITCH_DELAYED_LISTS();
 8001e26:	4b24      	ldr	r3, [pc, #144]	; (8001eb8 <xTaskIncrementTick+0xa8>)
 8001e28:	681a      	ldr	r2, [r3, #0]
 8001e2a:	6812      	ldr	r2, [r2, #0]
 8001e2c:	2a00      	cmp	r2, #0
 8001e2e:	d001      	beq.n	8001e34 <xTaskIncrementTick+0x24>
 8001e30:	b672      	cpsid	i
 8001e32:	e7fe      	b.n	8001e32 <xTaskIncrementTick+0x22>
 8001e34:	4a21      	ldr	r2, [pc, #132]	; (8001ebc <xTaskIncrementTick+0xac>)
 8001e36:	6819      	ldr	r1, [r3, #0]
 8001e38:	6810      	ldr	r0, [r2, #0]
 8001e3a:	6018      	str	r0, [r3, #0]
 8001e3c:	6011      	str	r1, [r2, #0]
 8001e3e:	4a20      	ldr	r2, [pc, #128]	; (8001ec0 <xTaskIncrementTick+0xb0>)
 8001e40:	6813      	ldr	r3, [r2, #0]
 8001e42:	3301      	adds	r3, #1
 8001e44:	6013      	str	r3, [r2, #0]
 8001e46:	f7ff fe5d 	bl	8001b04 <prvResetNextTaskUnblockTime>
        if( xConstTickCount >= xNextTaskUnblockTime )
 8001e4a:	4e1e      	ldr	r6, [pc, #120]	; (8001ec4 <xTaskIncrementTick+0xb4>)
 8001e4c:	6833      	ldr	r3, [r6, #0]
 8001e4e:	429c      	cmp	r4, r3
 8001e50:	d307      	bcc.n	8001e62 <xTaskIncrementTick+0x52>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001e52:	4b19      	ldr	r3, [pc, #100]	; (8001eb8 <xTaskIncrementTick+0xa8>)
 8001e54:	681a      	ldr	r2, [r3, #0]
 8001e56:	6812      	ldr	r2, [r2, #0]
 8001e58:	2a00      	cmp	r2, #0
 8001e5a:	d104      	bne.n	8001e66 <xTaskIncrementTick+0x56>
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001e5c:	2301      	movs	r3, #1
 8001e5e:	425b      	negs	r3, r3
                        xNextTaskUnblockTime = xItemValue;
 8001e60:	6033      	str	r3, [r6, #0]
}
 8001e62:	2000      	movs	r0, #0
 8001e64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	68db      	ldr	r3, [r3, #12]
 8001e6a:	68dd      	ldr	r5, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8001e6c:	686b      	ldr	r3, [r5, #4]
                    if( xConstTickCount < xItemValue )
 8001e6e:	429c      	cmp	r4, r3
 8001e70:	d3f6      	bcc.n	8001e60 <xTaskIncrementTick+0x50>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001e72:	1d2f      	adds	r7, r5, #4
 8001e74:	0038      	movs	r0, r7
 8001e76:	f7ff fbb8 	bl	80015ea <uxListRemove>
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8001e7a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001e7c:	2b00      	cmp	r3, #0
 8001e7e:	d003      	beq.n	8001e88 <xTaskIncrementTick+0x78>
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001e80:	0028      	movs	r0, r5
 8001e82:	3018      	adds	r0, #24
 8001e84:	f7ff fbb1 	bl	80015ea <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001e88:	4b0f      	ldr	r3, [pc, #60]	; (8001ec8 <xTaskIncrementTick+0xb8>)
 8001e8a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8001e8c:	681a      	ldr	r2, [r3, #0]
 8001e8e:	4290      	cmp	r0, r2
 8001e90:	d900      	bls.n	8001e94 <xTaskIncrementTick+0x84>
 8001e92:	6018      	str	r0, [r3, #0]
 8001e94:	2314      	movs	r3, #20
 8001e96:	4358      	muls	r0, r3
 8001e98:	4b0c      	ldr	r3, [pc, #48]	; (8001ecc <xTaskIncrementTick+0xbc>)
 8001e9a:	0039      	movs	r1, r7
 8001e9c:	1818      	adds	r0, r3, r0
 8001e9e:	f7ff fb81 	bl	80015a4 <vListInsertEnd>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001ea2:	e7d6      	b.n	8001e52 <xTaskIncrementTick+0x42>
        ++xPendedTicks;
 8001ea4:	4a0a      	ldr	r2, [pc, #40]	; (8001ed0 <xTaskIncrementTick+0xc0>)
 8001ea6:	6813      	ldr	r3, [r2, #0]
 8001ea8:	3301      	adds	r3, #1
 8001eaa:	6013      	str	r3, [r2, #0]
 8001eac:	e7d9      	b.n	8001e62 <xTaskIncrementTick+0x52>
 8001eae:	46c0      	nop			; (mov r8, r8)
 8001eb0:	200000a4 	.word	0x200000a4
 8001eb4:	20000128 	.word	0x20000128
 8001eb8:	20000030 	.word	0x20000030
 8001ebc:	20000034 	.word	0x20000034
 8001ec0:	200000e0 	.word	0x200000e0
 8001ec4:	200000dc 	.word	0x200000dc
 8001ec8:	200000ac 	.word	0x200000ac
 8001ecc:	20000038 	.word	0x20000038
 8001ed0:	200000e4 	.word	0x200000e4

08001ed4 <xTaskResumeAll>:
{
 8001ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    configASSERT( uxSchedulerSuspended );
 8001ed6:	4c28      	ldr	r4, [pc, #160]	; (8001f78 <xTaskResumeAll+0xa4>)
 8001ed8:	6823      	ldr	r3, [r4, #0]
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d101      	bne.n	8001ee2 <xTaskResumeAll+0xe>
 8001ede:	b672      	cpsid	i
 8001ee0:	e7fe      	b.n	8001ee0 <xTaskResumeAll+0xc>
    taskENTER_CRITICAL();
 8001ee2:	f000 fb5d 	bl	80025a0 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8001ee6:	6823      	ldr	r3, [r4, #0]
 8001ee8:	3b01      	subs	r3, #1
 8001eea:	6023      	str	r3, [r4, #0]
        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001eec:	6824      	ldr	r4, [r4, #0]
 8001eee:	2c00      	cmp	r4, #0
 8001ef0:	d103      	bne.n	8001efa <xTaskResumeAll+0x26>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8001ef2:	4b22      	ldr	r3, [pc, #136]	; (8001f7c <xTaskResumeAll+0xa8>)
 8001ef4:	681b      	ldr	r3, [r3, #0]
 8001ef6:	2b00      	cmp	r3, #0
 8001ef8:	d13b      	bne.n	8001f72 <xTaskResumeAll+0x9e>
    taskEXIT_CRITICAL();
 8001efa:	f000 fb5d 	bl	80025b8 <vPortExitCritical>
}
 8001efe:	2000      	movs	r0, #0
 8001f00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001f02:	68db      	ldr	r3, [r3, #12]
 8001f04:	68dc      	ldr	r4, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001f06:	0020      	movs	r0, r4
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001f08:	1d25      	adds	r5, r4, #4
                    ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8001f0a:	3018      	adds	r0, #24
 8001f0c:	f7ff fb6d 	bl	80015ea <uxListRemove>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8001f10:	0028      	movs	r0, r5
 8001f12:	f7ff fb6a 	bl	80015ea <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 8001f16:	4b1a      	ldr	r3, [pc, #104]	; (8001f80 <xTaskResumeAll+0xac>)
 8001f18:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8001f1a:	681a      	ldr	r2, [r3, #0]
 8001f1c:	4290      	cmp	r0, r2
 8001f1e:	d900      	bls.n	8001f22 <xTaskResumeAll+0x4e>
 8001f20:	6018      	str	r0, [r3, #0]
 8001f22:	4370      	muls	r0, r6
 8001f24:	4b17      	ldr	r3, [pc, #92]	; (8001f84 <xTaskResumeAll+0xb0>)
 8001f26:	0029      	movs	r1, r5
 8001f28:	1818      	adds	r0, r3, r0
 8001f2a:	f7ff fb3b 	bl	80015a4 <vListInsertEnd>
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001f2e:	4b16      	ldr	r3, [pc, #88]	; (8001f88 <xTaskResumeAll+0xb4>)
 8001f30:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001f32:	681b      	ldr	r3, [r3, #0]
 8001f34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f36:	429a      	cmp	r2, r3
 8001f38:	d301      	bcc.n	8001f3e <xTaskResumeAll+0x6a>
                        xYieldPending = pdTRUE;
 8001f3a:	4b14      	ldr	r3, [pc, #80]	; (8001f8c <xTaskResumeAll+0xb8>)
 8001f3c:	601f      	str	r7, [r3, #0]
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8001f3e:	4b14      	ldr	r3, [pc, #80]	; (8001f90 <xTaskResumeAll+0xbc>)
 8001f40:	681a      	ldr	r2, [r3, #0]
 8001f42:	2a00      	cmp	r2, #0
 8001f44:	d1dd      	bne.n	8001f02 <xTaskResumeAll+0x2e>
                if( pxTCB != NULL )
 8001f46:	2c00      	cmp	r4, #0
 8001f48:	d001      	beq.n	8001f4e <xTaskResumeAll+0x7a>
                    prvResetNextTaskUnblockTime();
 8001f4a:	f7ff fddb 	bl	8001b04 <prvResetNextTaskUnblockTime>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8001f4e:	4d11      	ldr	r5, [pc, #68]	; (8001f94 <xTaskResumeAll+0xc0>)
 8001f50:	682c      	ldr	r4, [r5, #0]
                    if( xPendedCounts > ( TickType_t ) 0U )
 8001f52:	2c00      	cmp	r4, #0
 8001f54:	d00a      	beq.n	8001f6c <xTaskResumeAll+0x98>
                                xYieldPending = pdTRUE;
 8001f56:	2601      	movs	r6, #1
                            if( xTaskIncrementTick() != pdFALSE )
 8001f58:	f7ff ff5a 	bl	8001e10 <xTaskIncrementTick>
 8001f5c:	2800      	cmp	r0, #0
 8001f5e:	d001      	beq.n	8001f64 <xTaskResumeAll+0x90>
                                xYieldPending = pdTRUE;
 8001f60:	4b0a      	ldr	r3, [pc, #40]	; (8001f8c <xTaskResumeAll+0xb8>)
 8001f62:	601e      	str	r6, [r3, #0]
                            --xPendedCounts;
 8001f64:	3c01      	subs	r4, #1
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8001f66:	2c00      	cmp	r4, #0
 8001f68:	d1f6      	bne.n	8001f58 <xTaskResumeAll+0x84>
                        xPendedTicks = 0;
 8001f6a:	602c      	str	r4, [r5, #0]
                if( xYieldPending != pdFALSE )
 8001f6c:	4b07      	ldr	r3, [pc, #28]	; (8001f8c <xTaskResumeAll+0xb8>)
 8001f6e:	681b      	ldr	r3, [r3, #0]
 8001f70:	e7c3      	b.n	8001efa <xTaskResumeAll+0x26>
                    prvAddTaskToReadyList( pxTCB );
 8001f72:	2614      	movs	r6, #20
                        xYieldPending = pdTRUE;
 8001f74:	2701      	movs	r7, #1
 8001f76:	e7e2      	b.n	8001f3e <xTaskResumeAll+0x6a>
 8001f78:	200000a4 	.word	0x200000a4
 8001f7c:	2000009c 	.word	0x2000009c
 8001f80:	200000ac 	.word	0x200000ac
 8001f84:	20000038 	.word	0x20000038
 8001f88:	2000002c 	.word	0x2000002c
 8001f8c:	2000012c 	.word	0x2000012c
 8001f90:	200000e8 	.word	0x200000e8
 8001f94:	200000e4 	.word	0x200000e4

08001f98 <vTaskSwitchContext>:
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001f98:	4b15      	ldr	r3, [pc, #84]	; (8001ff0 <vTaskSwitchContext+0x58>)
{
 8001f9a:	b530      	push	{r4, r5, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8001f9c:	681a      	ldr	r2, [r3, #0]
 8001f9e:	4b15      	ldr	r3, [pc, #84]	; (8001ff4 <vTaskSwitchContext+0x5c>)
 8001fa0:	2a00      	cmp	r2, #0
 8001fa2:	d002      	beq.n	8001faa <vTaskSwitchContext+0x12>
        xYieldPending = pdTRUE;
 8001fa4:	2201      	movs	r2, #1
 8001fa6:	601a      	str	r2, [r3, #0]
}
 8001fa8:	bd30      	pop	{r4, r5, pc}
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001faa:	2514      	movs	r5, #20
 8001fac:	4812      	ldr	r0, [pc, #72]	; (8001ff8 <vTaskSwitchContext+0x60>)
        xYieldPending = pdFALSE;
 8001fae:	601a      	str	r2, [r3, #0]
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001fb0:	6802      	ldr	r2, [r0, #0]
 8001fb2:	4912      	ldr	r1, [pc, #72]	; (8001ffc <vTaskSwitchContext+0x64>)
 8001fb4:	002b      	movs	r3, r5
 8001fb6:	4353      	muls	r3, r2
 8001fb8:	585c      	ldr	r4, [r3, r1]
 8001fba:	2c00      	cmp	r4, #0
 8001fbc:	d012      	beq.n	8001fe4 <vTaskSwitchContext+0x4c>
 8001fbe:	18cc      	adds	r4, r1, r3
 8001fc0:	6865      	ldr	r5, [r4, #4]
 8001fc2:	3308      	adds	r3, #8
 8001fc4:	686d      	ldr	r5, [r5, #4]
 8001fc6:	18cb      	adds	r3, r1, r3
 8001fc8:	6065      	str	r5, [r4, #4]
 8001fca:	429d      	cmp	r5, r3
 8001fcc:	d101      	bne.n	8001fd2 <vTaskSwitchContext+0x3a>
 8001fce:	686b      	ldr	r3, [r5, #4]
 8001fd0:	6063      	str	r3, [r4, #4]
 8001fd2:	2314      	movs	r3, #20
 8001fd4:	4353      	muls	r3, r2
 8001fd6:	18c9      	adds	r1, r1, r3
 8001fd8:	684b      	ldr	r3, [r1, #4]
 8001fda:	68d9      	ldr	r1, [r3, #12]
 8001fdc:	4b08      	ldr	r3, [pc, #32]	; (8002000 <vTaskSwitchContext+0x68>)
 8001fde:	6019      	str	r1, [r3, #0]
 8001fe0:	6002      	str	r2, [r0, #0]
}
 8001fe2:	e7e1      	b.n	8001fa8 <vTaskSwitchContext+0x10>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8001fe4:	2a00      	cmp	r2, #0
 8001fe6:	d101      	bne.n	8001fec <vTaskSwitchContext+0x54>
 8001fe8:	b672      	cpsid	i
 8001fea:	e7fe      	b.n	8001fea <vTaskSwitchContext+0x52>
 8001fec:	3a01      	subs	r2, #1
 8001fee:	e7e1      	b.n	8001fb4 <vTaskSwitchContext+0x1c>
 8001ff0:	200000a4 	.word	0x200000a4
 8001ff4:	2000012c 	.word	0x2000012c
 8001ff8:	200000ac 	.word	0x200000ac
 8001ffc:	20000038 	.word	0x20000038
 8002000:	2000002c 	.word	0x2000002c

08002004 <vTaskPlaceOnEventList>:
{
 8002004:	b510      	push	{r4, lr}
 8002006:	000c      	movs	r4, r1
    configASSERT( pxEventList );
 8002008:	2800      	cmp	r0, #0
 800200a:	d101      	bne.n	8002010 <vTaskPlaceOnEventList+0xc>
 800200c:	b672      	cpsid	i
 800200e:	e7fe      	b.n	800200e <vTaskPlaceOnEventList+0xa>
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002010:	4b04      	ldr	r3, [pc, #16]	; (8002024 <vTaskPlaceOnEventList+0x20>)
 8002012:	6819      	ldr	r1, [r3, #0]
 8002014:	3118      	adds	r1, #24
 8002016:	f7ff fad1 	bl	80015bc <vListInsert>
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800201a:	2101      	movs	r1, #1
 800201c:	0020      	movs	r0, r4
 800201e:	f7ff fd83 	bl	8001b28 <prvAddCurrentTaskToDelayedList>
}
 8002022:	bd10      	pop	{r4, pc}
 8002024:	2000002c 	.word	0x2000002c

08002028 <vTaskPlaceOnEventListRestricted>:
    {
 8002028:	b570      	push	{r4, r5, r6, lr}
 800202a:	000c      	movs	r4, r1
 800202c:	0015      	movs	r5, r2
        configASSERT( pxEventList );
 800202e:	2800      	cmp	r0, #0
 8002030:	d101      	bne.n	8002036 <vTaskPlaceOnEventListRestricted+0xe>
 8002032:	b672      	cpsid	i
 8002034:	e7fe      	b.n	8002034 <vTaskPlaceOnEventListRestricted+0xc>
        vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002036:	4b07      	ldr	r3, [pc, #28]	; (8002054 <vTaskPlaceOnEventListRestricted+0x2c>)
 8002038:	6819      	ldr	r1, [r3, #0]
 800203a:	3118      	adds	r1, #24
 800203c:	f7ff fab2 	bl	80015a4 <vListInsertEnd>
        if( xWaitIndefinitely != pdFALSE )
 8002040:	2d00      	cmp	r5, #0
 8002042:	d001      	beq.n	8002048 <vTaskPlaceOnEventListRestricted+0x20>
            xTicksToWait = portMAX_DELAY;
 8002044:	2401      	movs	r4, #1
 8002046:	4264      	negs	r4, r4
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002048:	0029      	movs	r1, r5
 800204a:	0020      	movs	r0, r4
 800204c:	f7ff fd6c 	bl	8001b28 <prvAddCurrentTaskToDelayedList>
    }
 8002050:	bd70      	pop	{r4, r5, r6, pc}
 8002052:	46c0      	nop			; (mov r8, r8)
 8002054:	2000002c 	.word	0x2000002c

08002058 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002058:	68c3      	ldr	r3, [r0, #12]
{
 800205a:	b570      	push	{r4, r5, r6, lr}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800205c:	68dc      	ldr	r4, [r3, #12]
    configASSERT( pxUnblockedTCB );
 800205e:	2c00      	cmp	r4, #0
 8002060:	d101      	bne.n	8002066 <xTaskRemoveFromEventList+0xe>
 8002062:	b672      	cpsid	i
 8002064:	e7fe      	b.n	8002064 <xTaskRemoveFromEventList+0xc>
    ( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8002066:	0025      	movs	r5, r4
 8002068:	3518      	adds	r5, #24
 800206a:	0028      	movs	r0, r5
 800206c:	f7ff fabd 	bl	80015ea <uxListRemove>
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002070:	4b11      	ldr	r3, [pc, #68]	; (80020b8 <xTaskRemoveFromEventList+0x60>)
 8002072:	681b      	ldr	r3, [r3, #0]
 8002074:	2b00      	cmp	r3, #0
 8002076:	d11b      	bne.n	80020b0 <xTaskRemoveFromEventList+0x58>
        ( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8002078:	1d25      	adds	r5, r4, #4
 800207a:	0028      	movs	r0, r5
 800207c:	f7ff fab5 	bl	80015ea <uxListRemove>
        prvAddTaskToReadyList( pxUnblockedTCB );
 8002080:	4a0e      	ldr	r2, [pc, #56]	; (80020bc <xTaskRemoveFromEventList+0x64>)
 8002082:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002084:	6811      	ldr	r1, [r2, #0]
 8002086:	428b      	cmp	r3, r1
 8002088:	d900      	bls.n	800208c <xTaskRemoveFromEventList+0x34>
 800208a:	6013      	str	r3, [r2, #0]
 800208c:	2014      	movs	r0, #20
 800208e:	0029      	movs	r1, r5
 8002090:	4343      	muls	r3, r0
 8002092:	480b      	ldr	r0, [pc, #44]	; (80020c0 <xTaskRemoveFromEventList+0x68>)
 8002094:	18c0      	adds	r0, r0, r3
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002096:	f7ff fa85 	bl	80015a4 <vListInsertEnd>
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800209a:	4b0a      	ldr	r3, [pc, #40]	; (80020c4 <xTaskRemoveFromEventList+0x6c>)
 800209c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800209e:	681b      	ldr	r3, [r3, #0]
        xReturn = pdFALSE;
 80020a0:	2000      	movs	r0, #0
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80020a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80020a4:	429a      	cmp	r2, r3
 80020a6:	d902      	bls.n	80020ae <xTaskRemoveFromEventList+0x56>
        xYieldPending = pdTRUE;
 80020a8:	4b07      	ldr	r3, [pc, #28]	; (80020c8 <xTaskRemoveFromEventList+0x70>)
 80020aa:	3001      	adds	r0, #1
 80020ac:	6018      	str	r0, [r3, #0]
}
 80020ae:	bd70      	pop	{r4, r5, r6, pc}
        vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80020b0:	0029      	movs	r1, r5
 80020b2:	4806      	ldr	r0, [pc, #24]	; (80020cc <xTaskRemoveFromEventList+0x74>)
 80020b4:	e7ef      	b.n	8002096 <xTaskRemoveFromEventList+0x3e>
 80020b6:	46c0      	nop			; (mov r8, r8)
 80020b8:	200000a4 	.word	0x200000a4
 80020bc:	200000ac 	.word	0x200000ac
 80020c0:	20000038 	.word	0x20000038
 80020c4:	2000002c 	.word	0x2000002c
 80020c8:	2000012c 	.word	0x2000012c
 80020cc:	200000e8 	.word	0x200000e8

080020d0 <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 80020d0:	4b03      	ldr	r3, [pc, #12]	; (80020e0 <vTaskInternalSetTimeOutState+0x10>)
 80020d2:	681b      	ldr	r3, [r3, #0]
 80020d4:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 80020d6:	4b03      	ldr	r3, [pc, #12]	; (80020e4 <vTaskInternalSetTimeOutState+0x14>)
 80020d8:	681b      	ldr	r3, [r3, #0]
 80020da:	6043      	str	r3, [r0, #4]
}
 80020dc:	4770      	bx	lr
 80020de:	46c0      	nop			; (mov r8, r8)
 80020e0:	200000e0 	.word	0x200000e0
 80020e4:	20000128 	.word	0x20000128

080020e8 <xTaskCheckForTimeOut>:
{
 80020e8:	b570      	push	{r4, r5, r6, lr}
 80020ea:	0004      	movs	r4, r0
 80020ec:	000d      	movs	r5, r1
    configASSERT( pxTimeOut );
 80020ee:	2800      	cmp	r0, #0
 80020f0:	d101      	bne.n	80020f6 <xTaskCheckForTimeOut+0xe>
 80020f2:	b672      	cpsid	i
 80020f4:	e7fe      	b.n	80020f4 <xTaskCheckForTimeOut+0xc>
    configASSERT( pxTicksToWait );
 80020f6:	2900      	cmp	r1, #0
 80020f8:	d101      	bne.n	80020fe <xTaskCheckForTimeOut+0x16>
 80020fa:	b672      	cpsid	i
 80020fc:	e7fe      	b.n	80020fc <xTaskCheckForTimeOut+0x14>
    taskENTER_CRITICAL();
 80020fe:	f000 fa4f 	bl	80025a0 <vPortEnterCritical>
        const TickType_t xConstTickCount = xTickCount;
 8002102:	4b10      	ldr	r3, [pc, #64]	; (8002144 <xTaskCheckForTimeOut+0x5c>)
                xReturn = pdFALSE;
 8002104:	2600      	movs	r6, #0
        const TickType_t xConstTickCount = xTickCount;
 8002106:	6819      	ldr	r1, [r3, #0]
            if( *pxTicksToWait == portMAX_DELAY )
 8002108:	682b      	ldr	r3, [r5, #0]
 800210a:	1c5a      	adds	r2, r3, #1
 800210c:	d00a      	beq.n	8002124 <xTaskCheckForTimeOut+0x3c>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800210e:	480e      	ldr	r0, [pc, #56]	; (8002148 <xTaskCheckForTimeOut+0x60>)
 8002110:	6826      	ldr	r6, [r4, #0]
 8002112:	6800      	ldr	r0, [r0, #0]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8002114:	6862      	ldr	r2, [r4, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8002116:	4286      	cmp	r6, r0
 8002118:	d008      	beq.n	800212c <xTaskCheckForTimeOut+0x44>
 800211a:	428a      	cmp	r2, r1
 800211c:	d806      	bhi.n	800212c <xTaskCheckForTimeOut+0x44>
            *pxTicksToWait = ( TickType_t ) 0;
 800211e:	2300      	movs	r3, #0
            xReturn = pdTRUE;
 8002120:	2601      	movs	r6, #1
            *pxTicksToWait = ( TickType_t ) 0;
 8002122:	602b      	str	r3, [r5, #0]
    taskEXIT_CRITICAL();
 8002124:	f000 fa48 	bl	80025b8 <vPortExitCritical>
}
 8002128:	0030      	movs	r0, r6
 800212a:	bd70      	pop	{r4, r5, r6, pc}
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800212c:	1a88      	subs	r0, r1, r2
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800212e:	4283      	cmp	r3, r0
 8002130:	d9f5      	bls.n	800211e <xTaskCheckForTimeOut+0x36>
            *pxTicksToWait -= xElapsedTime;
 8002132:	1a5b      	subs	r3, r3, r1
 8002134:	189b      	adds	r3, r3, r2
            vTaskInternalSetTimeOutState( pxTimeOut );
 8002136:	0020      	movs	r0, r4
            *pxTicksToWait -= xElapsedTime;
 8002138:	602b      	str	r3, [r5, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
 800213a:	f7ff ffc9 	bl	80020d0 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 800213e:	2600      	movs	r6, #0
 8002140:	e7f0      	b.n	8002124 <xTaskCheckForTimeOut+0x3c>
 8002142:	46c0      	nop			; (mov r8, r8)
 8002144:	20000128 	.word	0x20000128
 8002148:	200000e0 	.word	0x200000e0

0800214c <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 800214c:	2201      	movs	r2, #1
 800214e:	4b01      	ldr	r3, [pc, #4]	; (8002154 <vTaskMissedYield+0x8>)
 8002150:	601a      	str	r2, [r3, #0]
}
 8002152:	4770      	bx	lr
 8002154:	2000012c 	.word	0x2000012c

08002158 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 8002158:	4b05      	ldr	r3, [pc, #20]	; (8002170 <xTaskGetSchedulerState+0x18>)
            xReturn = taskSCHEDULER_NOT_STARTED;
 800215a:	2001      	movs	r0, #1
        if( xSchedulerRunning == pdFALSE )
 800215c:	681b      	ldr	r3, [r3, #0]
 800215e:	2b00      	cmp	r3, #0
 8002160:	d004      	beq.n	800216c <xTaskGetSchedulerState+0x14>
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002162:	4b04      	ldr	r3, [pc, #16]	; (8002174 <xTaskGetSchedulerState+0x1c>)
 8002164:	6818      	ldr	r0, [r3, #0]
                xReturn = taskSCHEDULER_SUSPENDED;
 8002166:	4243      	negs	r3, r0
 8002168:	4158      	adcs	r0, r3
 800216a:	0040      	lsls	r0, r0, #1
    }
 800216c:	4770      	bx	lr
 800216e:	46c0      	nop			; (mov r8, r8)
 8002170:	200000fc 	.word	0x200000fc
 8002174:	200000a4 	.word	0x200000a4

08002178 <xTaskPriorityDisinherit>:
    {
 8002178:	b570      	push	{r4, r5, r6, lr}
        if( pxMutexHolder != NULL )
 800217a:	2800      	cmp	r0, #0
 800217c:	d101      	bne.n	8002182 <xTaskPriorityDisinherit+0xa>
        BaseType_t xReturn = pdFALSE;
 800217e:	2000      	movs	r0, #0
    }
 8002180:	bd70      	pop	{r4, r5, r6, pc}
            configASSERT( pxTCB == pxCurrentTCB );
 8002182:	4b15      	ldr	r3, [pc, #84]	; (80021d8 <xTaskPriorityDisinherit+0x60>)
 8002184:	681c      	ldr	r4, [r3, #0]
 8002186:	4284      	cmp	r4, r0
 8002188:	d001      	beq.n	800218e <xTaskPriorityDisinherit+0x16>
 800218a:	b672      	cpsid	i
 800218c:	e7fe      	b.n	800218c <xTaskPriorityDisinherit+0x14>
            configASSERT( pxTCB->uxMutexesHeld );
 800218e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002190:	2b00      	cmp	r3, #0
 8002192:	d101      	bne.n	8002198 <xTaskPriorityDisinherit+0x20>
 8002194:	b672      	cpsid	i
 8002196:	e7fe      	b.n	8002196 <xTaskPriorityDisinherit+0x1e>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002198:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800219a:	6c61      	ldr	r1, [r4, #68]	; 0x44
            ( pxTCB->uxMutexesHeld )--;
 800219c:	3b01      	subs	r3, #1
 800219e:	64a3      	str	r3, [r4, #72]	; 0x48
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80021a0:	428a      	cmp	r2, r1
 80021a2:	d0ec      	beq.n	800217e <xTaskPriorityDisinherit+0x6>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80021a4:	2b00      	cmp	r3, #0
 80021a6:	d1ea      	bne.n	800217e <xTaskPriorityDisinherit+0x6>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80021a8:	1d25      	adds	r5, r4, #4
 80021aa:	0028      	movs	r0, r5
 80021ac:	f7ff fa1d 	bl	80015ea <uxListRemove>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80021b0:	2305      	movs	r3, #5
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 80021b2:	6c60      	ldr	r0, [r4, #68]	; 0x44
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80021b4:	1a1b      	subs	r3, r3, r0
 80021b6:	61a3      	str	r3, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
 80021b8:	4b08      	ldr	r3, [pc, #32]	; (80021dc <xTaskPriorityDisinherit+0x64>)
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 80021ba:	62e0      	str	r0, [r4, #44]	; 0x2c
                    prvAddTaskToReadyList( pxTCB );
 80021bc:	681a      	ldr	r2, [r3, #0]
 80021be:	4290      	cmp	r0, r2
 80021c0:	d900      	bls.n	80021c4 <xTaskPriorityDisinherit+0x4c>
 80021c2:	6018      	str	r0, [r3, #0]
 80021c4:	2314      	movs	r3, #20
 80021c6:	4343      	muls	r3, r0
 80021c8:	4805      	ldr	r0, [pc, #20]	; (80021e0 <xTaskPriorityDisinherit+0x68>)
 80021ca:	0029      	movs	r1, r5
 80021cc:	18c0      	adds	r0, r0, r3
 80021ce:	f7ff f9e9 	bl	80015a4 <vListInsertEnd>
                    xReturn = pdTRUE;
 80021d2:	2001      	movs	r0, #1
        return xReturn;
 80021d4:	e7d4      	b.n	8002180 <xTaskPriorityDisinherit+0x8>
 80021d6:	46c0      	nop			; (mov r8, r8)
 80021d8:	2000002c 	.word	0x2000002c
 80021dc:	200000ac 	.word	0x200000ac
 80021e0:	20000038 	.word	0x20000038

080021e4 <prvCheckForValidListAndQueue>:
        pxOverflowTimerList = pxTemp;
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 80021e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 80021e6:	f000 f9db 	bl	80025a0 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 80021ea:	4c0f      	ldr	r4, [pc, #60]	; (8002228 <prvCheckForValidListAndQueue+0x44>)
 80021ec:	6825      	ldr	r5, [r4, #0]
 80021ee:	2d00      	cmp	r5, #0
 80021f0:	d116      	bne.n	8002220 <prvCheckForValidListAndQueue+0x3c>
            {
                vListInitialise( &xActiveTimerList1 );
 80021f2:	4f0e      	ldr	r7, [pc, #56]	; (800222c <prvCheckForValidListAndQueue+0x48>)
 80021f4:	0038      	movs	r0, r7
 80021f6:	f7ff f9c7 	bl	8001588 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 80021fa:	4e0d      	ldr	r6, [pc, #52]	; (8002230 <prvCheckForValidListAndQueue+0x4c>)
 80021fc:	0030      	movs	r0, r6
 80021fe:	f7ff f9c3 	bl	8001588 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 8002202:	4b0c      	ldr	r3, [pc, #48]	; (8002234 <prvCheckForValidListAndQueue+0x50>)

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002204:	002a      	movs	r2, r5
                pxCurrentTimerList = &xActiveTimerList1;
 8002206:	601f      	str	r7, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 8002208:	4b0b      	ldr	r3, [pc, #44]	; (8002238 <prvCheckForValidListAndQueue+0x54>)
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 800220a:	210c      	movs	r1, #12
 800220c:	2005      	movs	r0, #5
                pxOverflowTimerList = &xActiveTimerList2;
 800220e:	601e      	str	r6, [r3, #0]
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002210:	f7ff fab7 	bl	8001782 <xQueueGenericCreate>
 8002214:	6020      	str	r0, [r4, #0]
                    }
                #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */

                #if ( configQUEUE_REGISTRY_SIZE > 0 )
                    {
                        if( xTimerQueue != NULL )
 8002216:	2800      	cmp	r0, #0
 8002218:	d002      	beq.n	8002220 <prvCheckForValidListAndQueue+0x3c>
                        {
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800221a:	4908      	ldr	r1, [pc, #32]	; (800223c <prvCheckForValidListAndQueue+0x58>)
 800221c:	f7ff fc3a 	bl	8001a94 <vQueueAddToRegistry>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8002220:	f000 f9ca 	bl	80025b8 <vPortExitCritical>
    }
 8002224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002226:	46c0      	nop			; (mov r8, r8)
 8002228:	20000164 	.word	0x20000164
 800222c:	20000138 	.word	0x20000138
 8002230:	2000014c 	.word	0x2000014c
 8002234:	20000130 	.word	0x20000130
 8002238:	20000134 	.word	0x20000134
 800223c:	08002947 	.word	0x08002947

08002240 <prvInsertTimerInActiveList>:
    {
 8002240:	b510      	push	{r4, lr}
 8002242:	0004      	movs	r4, r0
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002244:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002246:	6100      	str	r0, [r0, #16]
        if( xNextExpiryTime <= xTimeNow )
 8002248:	4291      	cmp	r1, r2
 800224a:	d80b      	bhi.n	8002264 <prvInsertTimerInActiveList+0x24>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800224c:	1ad2      	subs	r2, r2, r3
 800224e:	69a3      	ldr	r3, [r4, #24]
                xProcessTimerNow = pdTRUE;
 8002250:	2001      	movs	r0, #1
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002252:	429a      	cmp	r2, r3
 8002254:	d205      	bcs.n	8002262 <prvInsertTimerInActiveList+0x22>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002256:	4b07      	ldr	r3, [pc, #28]	; (8002274 <prvInsertTimerInActiveList+0x34>)
 8002258:	1d21      	adds	r1, r4, #4
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800225a:	6818      	ldr	r0, [r3, #0]
 800225c:	f7ff f9ae 	bl	80015bc <vListInsert>
        BaseType_t xProcessTimerNow = pdFALSE;
 8002260:	2000      	movs	r0, #0
    }
 8002262:	bd10      	pop	{r4, pc}
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8002264:	429a      	cmp	r2, r3
 8002266:	d202      	bcs.n	800226e <prvInsertTimerInActiveList+0x2e>
                xProcessTimerNow = pdTRUE;
 8002268:	2001      	movs	r0, #1
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800226a:	4299      	cmp	r1, r3
 800226c:	d2f9      	bcs.n	8002262 <prvInsertTimerInActiveList+0x22>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800226e:	4b02      	ldr	r3, [pc, #8]	; (8002278 <prvInsertTimerInActiveList+0x38>)
 8002270:	1d21      	adds	r1, r4, #4
 8002272:	e7f2      	b.n	800225a <prvInsertTimerInActiveList+0x1a>
 8002274:	20000134 	.word	0x20000134
 8002278:	20000130 	.word	0x20000130

0800227c <xTimerCreateTimerTask>:
    {
 800227c:	b507      	push	{r0, r1, r2, lr}
        prvCheckForValidListAndQueue();
 800227e:	f7ff ffb1 	bl	80021e4 <prvCheckForValidListAndQueue>
        if( xTimerQueue != NULL )
 8002282:	4b09      	ldr	r3, [pc, #36]	; (80022a8 <xTimerCreateTimerTask+0x2c>)
 8002284:	681b      	ldr	r3, [r3, #0]
 8002286:	2b00      	cmp	r3, #0
 8002288:	d101      	bne.n	800228e <xTimerCreateTimerTask+0x12>
        configASSERT( xReturn );
 800228a:	b672      	cpsid	i
 800228c:	e7fe      	b.n	800228c <xTimerCreateTimerTask+0x10>
                    xReturn = xTaskCreate( prvTimerTask,
 800228e:	4b07      	ldr	r3, [pc, #28]	; (80022ac <xTimerCreateTimerTask+0x30>)
 8002290:	2250      	movs	r2, #80	; 0x50
 8002292:	9301      	str	r3, [sp, #4]
 8002294:	2302      	movs	r3, #2
 8002296:	4906      	ldr	r1, [pc, #24]	; (80022b0 <xTimerCreateTimerTask+0x34>)
 8002298:	9300      	str	r3, [sp, #0]
 800229a:	4806      	ldr	r0, [pc, #24]	; (80022b4 <xTimerCreateTimerTask+0x38>)
 800229c:	2300      	movs	r3, #0
 800229e:	f7ff fca1 	bl	8001be4 <xTaskCreate>
        configASSERT( xReturn );
 80022a2:	2800      	cmp	r0, #0
 80022a4:	d0f1      	beq.n	800228a <xTimerCreateTimerTask+0xe>
    }
 80022a6:	bd0e      	pop	{r1, r2, r3, pc}
 80022a8:	20000164 	.word	0x20000164
 80022ac:	20000168 	.word	0x20000168
 80022b0:	0800294c 	.word	0x0800294c
 80022b4:	08002371 	.word	0x08002371

080022b8 <xTimerGenericCommand>:
    {
 80022b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80022ba:	0017      	movs	r7, r2
 80022bc:	0004      	movs	r4, r0
 80022be:	001a      	movs	r2, r3
 80022c0:	b085      	sub	sp, #20
        configASSERT( xTimer );
 80022c2:	2800      	cmp	r0, #0
 80022c4:	d101      	bne.n	80022ca <xTimerGenericCommand+0x12>
 80022c6:	b672      	cpsid	i
 80022c8:	e7fe      	b.n	80022c8 <xTimerGenericCommand+0x10>
        if( xTimerQueue != NULL )
 80022ca:	4d0d      	ldr	r5, [pc, #52]	; (8002300 <xTimerGenericCommand+0x48>)
 80022cc:	682e      	ldr	r6, [r5, #0]
        BaseType_t xReturn = pdFAIL;
 80022ce:	1e30      	subs	r0, r6, #0
        if( xTimerQueue != NULL )
 80022d0:	d00f      	beq.n	80022f2 <xTimerGenericCommand+0x3a>
            xMessage.xMessageID = xCommandID;
 80022d2:	9101      	str	r1, [sp, #4]
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80022d4:	9702      	str	r7, [sp, #8]
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 80022d6:	9403      	str	r4, [sp, #12]
            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 80022d8:	2905      	cmp	r1, #5
 80022da:	dc0c      	bgt.n	80022f6 <xTimerGenericCommand+0x3e>
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80022dc:	f7ff ff3c 	bl	8002158 <xTaskGetSchedulerState>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80022e0:	2300      	movs	r3, #0
 80022e2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 80022e4:	2802      	cmp	r0, #2
 80022e6:	d000      	beq.n	80022ea <xTimerGenericCommand+0x32>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80022e8:	001a      	movs	r2, r3
 80022ea:	6828      	ldr	r0, [r5, #0]
 80022ec:	a901      	add	r1, sp, #4
 80022ee:	f7ff fa76 	bl	80017de <xQueueGenericSend>
    }
 80022f2:	b005      	add	sp, #20
 80022f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80022f6:	2300      	movs	r3, #0
 80022f8:	a901      	add	r1, sp, #4
 80022fa:	f7ff fafc 	bl	80018f6 <xQueueGenericSendFromISR>
 80022fe:	e7f8      	b.n	80022f2 <xTimerGenericCommand+0x3a>
 8002300:	20000164 	.word	0x20000164

08002304 <prvSwitchTimerLists>:
    {
 8002304:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002306:	4d18      	ldr	r5, [pc, #96]	; (8002368 <prvSwitchTimerLists+0x64>)
 8002308:	682b      	ldr	r3, [r5, #0]
 800230a:	681a      	ldr	r2, [r3, #0]
 800230c:	2a00      	cmp	r2, #0
 800230e:	d104      	bne.n	800231a <prvSwitchTimerLists+0x16>
        pxCurrentTimerList = pxOverflowTimerList;
 8002310:	4a16      	ldr	r2, [pc, #88]	; (800236c <prvSwitchTimerLists+0x68>)
 8002312:	6811      	ldr	r1, [r2, #0]
        pxOverflowTimerList = pxTemp;
 8002314:	6013      	str	r3, [r2, #0]
        pxCurrentTimerList = pxOverflowTimerList;
 8002316:	6029      	str	r1, [r5, #0]
    }
 8002318:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800231a:	68db      	ldr	r3, [r3, #12]
            pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800231c:	68dc      	ldr	r4, [r3, #12]
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800231e:	681e      	ldr	r6, [r3, #0]
            ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002320:	1d27      	adds	r7, r4, #4
 8002322:	0038      	movs	r0, r7
 8002324:	f7ff f961 	bl	80015ea <uxListRemove>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002328:	6a23      	ldr	r3, [r4, #32]
 800232a:	0020      	movs	r0, r4
 800232c:	4798      	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800232e:	0023      	movs	r3, r4
 8002330:	2204      	movs	r2, #4
 8002332:	3328      	adds	r3, #40	; 0x28
 8002334:	781b      	ldrb	r3, [r3, #0]
 8002336:	4213      	tst	r3, r2
 8002338:	d0e5      	beq.n	8002306 <prvSwitchTimerLists+0x2>
                xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800233a:	69a3      	ldr	r3, [r4, #24]
 800233c:	18f3      	adds	r3, r6, r3
                if( xReloadTime > xNextExpireTime )
 800233e:	429e      	cmp	r6, r3
 8002340:	d206      	bcs.n	8002350 <prvSwitchTimerLists+0x4c>
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002342:	0039      	movs	r1, r7
 8002344:	6828      	ldr	r0, [r5, #0]
                    listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8002346:	6063      	str	r3, [r4, #4]
                    listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002348:	6124      	str	r4, [r4, #16]
                    vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800234a:	f7ff f937 	bl	80015bc <vListInsert>
 800234e:	e7da      	b.n	8002306 <prvSwitchTimerLists+0x2>
                    xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002350:	2100      	movs	r1, #0
 8002352:	0032      	movs	r2, r6
 8002354:	000b      	movs	r3, r1
 8002356:	0020      	movs	r0, r4
 8002358:	9100      	str	r1, [sp, #0]
 800235a:	f7ff ffad 	bl	80022b8 <xTimerGenericCommand>
                    configASSERT( xResult );
 800235e:	2800      	cmp	r0, #0
 8002360:	d1d1      	bne.n	8002306 <prvSwitchTimerLists+0x2>
 8002362:	b672      	cpsid	i
 8002364:	e7fe      	b.n	8002364 <prvSwitchTimerLists+0x60>
 8002366:	46c0      	nop			; (mov r8, r8)
 8002368:	20000130 	.word	0x20000130
 800236c:	20000134 	.word	0x20000134

08002370 <prvTimerTask>:
    {
 8002370:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002372:	b089      	sub	sp, #36	; 0x24
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002374:	4f60      	ldr	r7, [pc, #384]	; (80024f8 <prvTimerTask+0x188>)
 8002376:	2601      	movs	r6, #1
 8002378:	683b      	ldr	r3, [r7, #0]
 800237a:	681c      	ldr	r4, [r3, #0]
 800237c:	2c00      	cmp	r4, #0
 800237e:	d002      	beq.n	8002386 <prvTimerTask+0x16>
 8002380:	2600      	movs	r6, #0
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002382:	68db      	ldr	r3, [r3, #12]
 8002384:	681c      	ldr	r4, [r3, #0]
        vTaskSuspendAll();
 8002386:	f7ff fd35 	bl	8001df4 <vTaskSuspendAll>
        xTimeNow = xTaskGetTickCount();
 800238a:	f7ff fd3b 	bl	8001e04 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 800238e:	4b5b      	ldr	r3, [pc, #364]	; (80024fc <prvTimerTask+0x18c>)
        xTimeNow = xTaskGetTickCount();
 8002390:	0005      	movs	r5, r0
        if( xTimeNow < xLastTime )
 8002392:	681b      	ldr	r3, [r3, #0]
 8002394:	9303      	str	r3, [sp, #12]
 8002396:	4298      	cmp	r0, r3
 8002398:	d315      	bcc.n	80023c6 <prvTimerTask+0x56>
        xLastTime = xTimeNow;
 800239a:	4b58      	ldr	r3, [pc, #352]	; (80024fc <prvTimerTask+0x18c>)
 800239c:	6018      	str	r0, [r3, #0]
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800239e:	2e00      	cmp	r6, #0
 80023a0:	d019      	beq.n	80023d6 <prvTimerTask+0x66>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80023a2:	4b57      	ldr	r3, [pc, #348]	; (8002500 <prvTimerTask+0x190>)
 80023a4:	681b      	ldr	r3, [r3, #0]
 80023a6:	681e      	ldr	r6, [r3, #0]
 80023a8:	4273      	negs	r3, r6
 80023aa:	415e      	adcs	r6, r3
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 80023ac:	4b55      	ldr	r3, [pc, #340]	; (8002504 <prvTimerTask+0x194>)
 80023ae:	0032      	movs	r2, r6
 80023b0:	6818      	ldr	r0, [r3, #0]
 80023b2:	1b61      	subs	r1, r4, r5
 80023b4:	f7ff fb80 	bl	8001ab8 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 80023b8:	f7ff fd8c 	bl	8001ed4 <xTaskResumeAll>
 80023bc:	2800      	cmp	r0, #0
 80023be:	d108      	bne.n	80023d2 <prvTimerTask+0x62>
                        portYIELD_WITHIN_API();
 80023c0:	f000 f8e2 	bl	8002588 <vPortYield>
 80023c4:	e005      	b.n	80023d2 <prvTimerTask+0x62>
            prvSwitchTimerLists();
 80023c6:	f7ff ff9d 	bl	8002304 <prvSwitchTimerLists>
        xLastTime = xTimeNow;
 80023ca:	4b4c      	ldr	r3, [pc, #304]	; (80024fc <prvTimerTask+0x18c>)
 80023cc:	601d      	str	r5, [r3, #0]
                ( void ) xTaskResumeAll();
 80023ce:	f7ff fd81 	bl	8001ed4 <xTaskResumeAll>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 80023d2:	2702      	movs	r7, #2
 80023d4:	e05a      	b.n	800248c <prvTimerTask+0x11c>
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80023d6:	4284      	cmp	r4, r0
 80023d8:	d8e8      	bhi.n	80023ac <prvTimerTask+0x3c>
                    ( void ) xTaskResumeAll();
 80023da:	f7ff fd7b 	bl	8001ed4 <xTaskResumeAll>
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80023de:	683b      	ldr	r3, [r7, #0]
 80023e0:	68db      	ldr	r3, [r3, #12]
 80023e2:	68df      	ldr	r7, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80023e4:	1d38      	adds	r0, r7, #4
 80023e6:	f7ff f900 	bl	80015ea <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80023ea:	003a      	movs	r2, r7
 80023ec:	2104      	movs	r1, #4
 80023ee:	3228      	adds	r2, #40	; 0x28
 80023f0:	7813      	ldrb	r3, [r2, #0]
 80023f2:	420b      	tst	r3, r1
 80023f4:	d013      	beq.n	800241e <prvTimerTask+0xae>
            if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 80023f6:	69bb      	ldr	r3, [r7, #24]
 80023f8:	002a      	movs	r2, r5
 80023fa:	18e1      	adds	r1, r4, r3
 80023fc:	0038      	movs	r0, r7
 80023fe:	0023      	movs	r3, r4
 8002400:	f7ff ff1e 	bl	8002240 <prvInsertTimerInActiveList>
 8002404:	2800      	cmp	r0, #0
 8002406:	d00d      	beq.n	8002424 <prvTimerTask+0xb4>
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002408:	0033      	movs	r3, r6
 800240a:	0022      	movs	r2, r4
 800240c:	0031      	movs	r1, r6
 800240e:	0038      	movs	r0, r7
 8002410:	9600      	str	r6, [sp, #0]
 8002412:	f7ff ff51 	bl	80022b8 <xTimerGenericCommand>
                configASSERT( xResult );
 8002416:	2800      	cmp	r0, #0
 8002418:	d104      	bne.n	8002424 <prvTimerTask+0xb4>
 800241a:	b672      	cpsid	i
 800241c:	e7fe      	b.n	800241c <prvTimerTask+0xac>
            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800241e:	2101      	movs	r1, #1
 8002420:	438b      	bics	r3, r1
 8002422:	7013      	strb	r3, [r2, #0]
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002424:	0038      	movs	r0, r7
 8002426:	6a3b      	ldr	r3, [r7, #32]
 8002428:	4798      	blx	r3
    }
 800242a:	e7d2      	b.n	80023d2 <prvTimerTask+0x62>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800242c:	2201      	movs	r2, #1
 800242e:	4313      	orrs	r3, r2
 8002430:	702b      	strb	r3, [r5, #0]
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8002432:	69a2      	ldr	r2, [r4, #24]
 8002434:	9b06      	ldr	r3, [sp, #24]
 8002436:	0020      	movs	r0, r4
 8002438:	1899      	adds	r1, r3, r2
 800243a:	0032      	movs	r2, r6
 800243c:	9303      	str	r3, [sp, #12]
 800243e:	f7ff feff 	bl	8002240 <prvInsertTimerInActiveList>
 8002442:	2800      	cmp	r0, #0
 8002444:	d022      	beq.n	800248c <prvTimerTask+0x11c>
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002446:	6a23      	ldr	r3, [r4, #32]
 8002448:	0020      	movs	r0, r4
 800244a:	4798      	blx	r3
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800244c:	2204      	movs	r2, #4
 800244e:	782b      	ldrb	r3, [r5, #0]
 8002450:	4213      	tst	r3, r2
 8002452:	d01b      	beq.n	800248c <prvTimerTask+0x11c>
                                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8002454:	2100      	movs	r1, #0
 8002456:	69a3      	ldr	r3, [r4, #24]
 8002458:	9a06      	ldr	r2, [sp, #24]
 800245a:	0020      	movs	r0, r4
 800245c:	18d2      	adds	r2, r2, r3
 800245e:	9100      	str	r1, [sp, #0]
 8002460:	000b      	movs	r3, r1
 8002462:	f7ff ff29 	bl	80022b8 <xTimerGenericCommand>
                                configASSERT( xResult );
 8002466:	2800      	cmp	r0, #0
 8002468:	d110      	bne.n	800248c <prvTimerTask+0x11c>
 800246a:	b672      	cpsid	i
 800246c:	e7fe      	b.n	800246c <prvTimerTask+0xfc>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800246e:	2201      	movs	r2, #1
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8002470:	9906      	ldr	r1, [sp, #24]
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8002472:	4313      	orrs	r3, r2
 8002474:	702b      	strb	r3, [r5, #0]
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8002476:	61a1      	str	r1, [r4, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8002478:	2900      	cmp	r1, #0
 800247a:	d101      	bne.n	8002480 <prvTimerTask+0x110>
 800247c:	b672      	cpsid	i
 800247e:	e7fe      	b.n	800247e <prvTimerTask+0x10e>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8002480:	0033      	movs	r3, r6
 8002482:	0032      	movs	r2, r6
 8002484:	0020      	movs	r0, r4
 8002486:	1989      	adds	r1, r1, r6
 8002488:	f7ff feda 	bl	8002240 <prvInsertTimerInActiveList>
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800248c:	4b1d      	ldr	r3, [pc, #116]	; (8002504 <prvTimerTask+0x194>)
 800248e:	2200      	movs	r2, #0
 8002490:	6818      	ldr	r0, [r3, #0]
 8002492:	a905      	add	r1, sp, #20
 8002494:	f7ff fa7d 	bl	8001992 <xQueueReceive>
 8002498:	2800      	cmp	r0, #0
 800249a:	d100      	bne.n	800249e <prvTimerTask+0x12e>
 800249c:	e76a      	b.n	8002374 <prvTimerTask+0x4>
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800249e:	9b05      	ldr	r3, [sp, #20]
 80024a0:	2b00      	cmp	r3, #0
 80024a2:	dbf3      	blt.n	800248c <prvTimerTask+0x11c>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 80024a4:	9c07      	ldr	r4, [sp, #28]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 80024a6:	6963      	ldr	r3, [r4, #20]
 80024a8:	2b00      	cmp	r3, #0
 80024aa:	d002      	beq.n	80024b2 <prvTimerTask+0x142>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80024ac:	1d20      	adds	r0, r4, #4
 80024ae:	f7ff f89c 	bl	80015ea <uxListRemove>
        xTimeNow = xTaskGetTickCount();
 80024b2:	f7ff fca7 	bl	8001e04 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 80024b6:	4b11      	ldr	r3, [pc, #68]	; (80024fc <prvTimerTask+0x18c>)
        xTimeNow = xTaskGetTickCount();
 80024b8:	0006      	movs	r6, r0
        if( xTimeNow < xLastTime )
 80024ba:	681b      	ldr	r3, [r3, #0]
 80024bc:	9303      	str	r3, [sp, #12]
 80024be:	4298      	cmp	r0, r3
 80024c0:	d201      	bcs.n	80024c6 <prvTimerTask+0x156>
            prvSwitchTimerLists();
 80024c2:	f7ff ff1f 	bl	8002304 <prvSwitchTimerLists>
        xLastTime = xTimeNow;
 80024c6:	4b0d      	ldr	r3, [pc, #52]	; (80024fc <prvTimerTask+0x18c>)
 80024c8:	9805      	ldr	r0, [sp, #20]
 80024ca:	601e      	str	r6, [r3, #0]
                switch( xMessage.xMessageID )
 80024cc:	2809      	cmp	r0, #9
 80024ce:	d8dd      	bhi.n	800248c <prvTimerTask+0x11c>
 80024d0:	0025      	movs	r5, r4
 80024d2:	3528      	adds	r5, #40	; 0x28
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 80024d4:	782b      	ldrb	r3, [r5, #0]
 80024d6:	f7fd fe17 	bl	8000108 <__gnu_thumb1_case_sqi>
 80024da:	a9a9      	.short	0xa9a9
 80024dc:	05ca0ba9 	.word	0x05ca0ba9
 80024e0:	ca0ba9a9 	.word	0xca0ba9a9
 80024e4:	423b      	tst	r3, r7
 80024e6:	d103      	bne.n	80024f0 <prvTimerTask+0x180>
                                    vPortFree( pxTimer );
 80024e8:	0020      	movs	r0, r4
 80024ea:	f000 f99b 	bl	8002824 <vPortFree>
 80024ee:	e7cd      	b.n	800248c <prvTimerTask+0x11c>
                                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80024f0:	2201      	movs	r2, #1
 80024f2:	4393      	bics	r3, r2
 80024f4:	702b      	strb	r3, [r5, #0]
 80024f6:	e7c9      	b.n	800248c <prvTimerTask+0x11c>
 80024f8:	20000130 	.word	0x20000130
 80024fc:	20000160 	.word	0x20000160
 8002500:	20000134 	.word	0x20000134
 8002504:	20000164 	.word	0x20000164

08002508 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    volatile uint32_t ulDummy = 0UL;
 8002508:	2300      	movs	r3, #0
{
 800250a:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0UL;
 800250c:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 800250e:	4b06      	ldr	r3, [pc, #24]	; (8002528 <prvTaskExitError+0x20>)
 8002510:	681b      	ldr	r3, [r3, #0]
 8002512:	3301      	adds	r3, #1
 8002514:	d001      	beq.n	800251a <prvTaskExitError+0x12>
 8002516:	b672      	cpsid	i
 8002518:	e7fe      	b.n	8002518 <prvTaskExitError+0x10>
    portDISABLE_INTERRUPTS();
 800251a:	b672      	cpsid	i

    while( ulDummy == 0 )
 800251c:	9b01      	ldr	r3, [sp, #4]
 800251e:	2b00      	cmp	r3, #0
 8002520:	d0fc      	beq.n	800251c <prvTaskExitError+0x14>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 8002522:	b002      	add	sp, #8
 8002524:	4770      	bx	lr
 8002526:	46c0      	nop			; (mov r8, r8)
 8002528:	2000000c 	.word	0x2000000c
 800252c:	00000000 	.word	0x00000000

08002530 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
    /* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
     * table offset register that can be used to locate the initial stack value.
     * Not all M0 parts have the application vector table at address 0. */
    __asm volatile (
 8002530:	4a0b      	ldr	r2, [pc, #44]	; (8002560 <pxCurrentTCBConst2>)
 8002532:	6813      	ldr	r3, [r2, #0]
 8002534:	6818      	ldr	r0, [r3, #0]
 8002536:	3020      	adds	r0, #32
 8002538:	f380 8809 	msr	PSP, r0
 800253c:	2002      	movs	r0, #2
 800253e:	f380 8814 	msr	CONTROL, r0
 8002542:	f3bf 8f6f 	isb	sy
 8002546:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 8002548:	46ae      	mov	lr, r5
 800254a:	bc08      	pop	{r3}
 800254c:	bc04      	pop	{r2}
 800254e:	b662      	cpsie	i
 8002550:	4718      	bx	r3
 8002552:	46c0      	nop			; (mov r8, r8)
 8002554:	46c0      	nop			; (mov r8, r8)
 8002556:	46c0      	nop			; (mov r8, r8)
 8002558:	46c0      	nop			; (mov r8, r8)
 800255a:	46c0      	nop			; (mov r8, r8)
 800255c:	46c0      	nop			; (mov r8, r8)
 800255e:	46c0      	nop			; (mov r8, r8)

08002560 <pxCurrentTCBConst2>:
 8002560:	2000002c 	.word	0x2000002c

08002564 <pxPortInitialiseStack>:
{
 8002564:	b510      	push	{r4, lr}
    *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR */
 8002566:	2480      	movs	r4, #128	; 0x80
 8002568:	1f03      	subs	r3, r0, #4
 800256a:	0464      	lsls	r4, r4, #17
 800256c:	601c      	str	r4, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC */
 800256e:	3b04      	subs	r3, #4
 8002570:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR */
 8002572:	4903      	ldr	r1, [pc, #12]	; (8002580 <pxPortInitialiseStack+0x1c>)
 8002574:	3b04      	subs	r3, #4
 8002576:	6019      	str	r1, [r3, #0]
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 8002578:	3b14      	subs	r3, #20
    pxTopOfStack -= 8;                                       /* R11..R4. */
 800257a:	3840      	subs	r0, #64	; 0x40
    *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0 */
 800257c:	601a      	str	r2, [r3, #0]
}
 800257e:	bd10      	pop	{r4, pc}
 8002580:	08002509 	.word	0x08002509

08002584 <SVC_Handler>:
}
 8002584:	4770      	bx	lr
	...

08002588 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
    /* Set a PendSV to request a context switch. */
    portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002588:	2280      	movs	r2, #128	; 0x80
 800258a:	4b04      	ldr	r3, [pc, #16]	; (800259c <vPortYield+0x14>)
 800258c:	0552      	lsls	r2, r2, #21
 800258e:	601a      	str	r2, [r3, #0]

    /* Barriers are normally not required but do ensure the code is completely
     * within the specified behaviour for the architecture. */
    __asm volatile ( "dsb" ::: "memory" );
 8002590:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 8002594:	f3bf 8f6f 	isb	sy
}
 8002598:	4770      	bx	lr
 800259a:	46c0      	nop			; (mov r8, r8)
 800259c:	e000ed04 	.word	0xe000ed04

080025a0 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 80025a0:	b672      	cpsid	i
    uxCriticalNesting++;
 80025a2:	4a04      	ldr	r2, [pc, #16]	; (80025b4 <vPortEnterCritical+0x14>)
 80025a4:	6813      	ldr	r3, [r2, #0]
 80025a6:	3301      	adds	r3, #1
 80025a8:	6013      	str	r3, [r2, #0]
    __asm volatile ( "dsb" ::: "memory" );
 80025aa:	f3bf 8f4f 	dsb	sy
    __asm volatile ( "isb" );
 80025ae:	f3bf 8f6f 	isb	sy
}
 80025b2:	4770      	bx	lr
 80025b4:	2000000c 	.word	0x2000000c

080025b8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    configASSERT( uxCriticalNesting );
 80025b8:	4a05      	ldr	r2, [pc, #20]	; (80025d0 <vPortExitCritical+0x18>)
 80025ba:	6813      	ldr	r3, [r2, #0]
 80025bc:	2b00      	cmp	r3, #0
 80025be:	d101      	bne.n	80025c4 <vPortExitCritical+0xc>
 80025c0:	b672      	cpsid	i
 80025c2:	e7fe      	b.n	80025c2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 80025c4:	3b01      	subs	r3, #1
 80025c6:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
 80025c8:	2b00      	cmp	r3, #0
 80025ca:	d100      	bne.n	80025ce <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 80025cc:	b662      	cpsie	i
    }
}
 80025ce:	4770      	bx	lr
 80025d0:	2000000c 	.word	0x2000000c

080025d4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
    __asm volatile (
 80025d4:	f3ef 8010 	mrs	r0, PRIMASK
 80025d8:	b672      	cpsid	i
 80025da:	4770      	bx	lr

080025dc <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
    __asm volatile (
 80025dc:	f380 8810 	msr	PRIMASK, r0
 80025e0:	4770      	bx	lr
	...

080025f0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
 80025f0:	f3ef 8009 	mrs	r0, PSP
 80025f4:	4b0e      	ldr	r3, [pc, #56]	; (8002630 <pxCurrentTCBConst>)
 80025f6:	681a      	ldr	r2, [r3, #0]
 80025f8:	3820      	subs	r0, #32
 80025fa:	6010      	str	r0, [r2, #0]
 80025fc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 80025fe:	4644      	mov	r4, r8
 8002600:	464d      	mov	r5, r9
 8002602:	4656      	mov	r6, sl
 8002604:	465f      	mov	r7, fp
 8002606:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 8002608:	b508      	push	{r3, lr}
 800260a:	b672      	cpsid	i
 800260c:	f7ff fcc4 	bl	8001f98 <vTaskSwitchContext>
 8002610:	b662      	cpsie	i
 8002612:	bc0c      	pop	{r2, r3}
 8002614:	6811      	ldr	r1, [r2, #0]
 8002616:	6808      	ldr	r0, [r1, #0]
 8002618:	3010      	adds	r0, #16
 800261a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800261c:	46a0      	mov	r8, r4
 800261e:	46a9      	mov	r9, r5
 8002620:	46b2      	mov	sl, r6
 8002622:	46bb      	mov	fp, r7
 8002624:	f380 8809 	msr	PSP, r0
 8002628:	3820      	subs	r0, #32
 800262a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800262c:	4718      	bx	r3
 800262e:	46c0      	nop			; (mov r8, r8)

08002630 <pxCurrentTCBConst>:
 8002630:	2000002c 	.word	0x2000002c

08002634 <SysTick_Handler>:
    );
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8002634:	b510      	push	{r4, lr}
    uint32_t ulPreviousMask;

    ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 8002636:	f7ff ffcd 	bl	80025d4 <ulSetInterruptMaskFromISR>
 800263a:	0004      	movs	r4, r0
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
 800263c:	f7ff fbe8 	bl	8001e10 <xTaskIncrementTick>
 8002640:	2800      	cmp	r0, #0
 8002642:	d003      	beq.n	800264c <SysTick_Handler+0x18>
        {
            /* Pend a context switch. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8002644:	2280      	movs	r2, #128	; 0x80
 8002646:	4b03      	ldr	r3, [pc, #12]	; (8002654 <SysTick_Handler+0x20>)
 8002648:	0552      	lsls	r2, r2, #21
 800264a:	601a      	str	r2, [r3, #0]
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800264c:	0020      	movs	r0, r4
 800264e:	f7ff ffc5 	bl	80025dc <vClearInterruptMaskFromISR>
}
 8002652:	bd10      	pop	{r4, pc}
 8002654:	e000ed04 	.word	0xe000ed04

08002658 <vPortSetupTimerInterrupt>:
            ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR;
        }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and reset the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8002658:	2300      	movs	r3, #0
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800265a:	21fa      	movs	r1, #250	; 0xfa
{
 800265c:	b510      	push	{r4, lr}
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800265e:	4a07      	ldr	r2, [pc, #28]	; (800267c <vPortSetupTimerInterrupt+0x24>)
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8002660:	4c07      	ldr	r4, [pc, #28]	; (8002680 <vPortSetupTimerInterrupt+0x28>)
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002662:	0089      	lsls	r1, r1, #2
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8002664:	6023      	str	r3, [r4, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8002666:	6013      	str	r3, [r2, #0]
    portNVIC_SYSTICK_LOAD_REG = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002668:	4b06      	ldr	r3, [pc, #24]	; (8002684 <vPortSetupTimerInterrupt+0x2c>)
 800266a:	6818      	ldr	r0, [r3, #0]
 800266c:	f7fd fd56 	bl	800011c <__udivsi3>
 8002670:	4b05      	ldr	r3, [pc, #20]	; (8002688 <vPortSetupTimerInterrupt+0x30>)
 8002672:	3801      	subs	r0, #1
 8002674:	6018      	str	r0, [r3, #0]
    portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8002676:	2307      	movs	r3, #7
 8002678:	6023      	str	r3, [r4, #0]
}
 800267a:	bd10      	pop	{r4, pc}
 800267c:	e000e018 	.word	0xe000e018
 8002680:	e000e010 	.word	0xe000e010
 8002684:	20000000 	.word	0x20000000
 8002688:	e000e014 	.word	0xe000e014

0800268c <xPortStartScheduler>:
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 800268c:	22ff      	movs	r2, #255	; 0xff
 800268e:	4b0c      	ldr	r3, [pc, #48]	; (80026c0 <xPortStartScheduler+0x34>)
 8002690:	0412      	lsls	r2, r2, #16
 8002692:	6819      	ldr	r1, [r3, #0]
{
 8002694:	b510      	push	{r4, lr}
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8002696:	430a      	orrs	r2, r1
 8002698:	601a      	str	r2, [r3, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 800269a:	22ff      	movs	r2, #255	; 0xff
    uxCriticalNesting = 0;
 800269c:	2400      	movs	r4, #0
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 800269e:	6819      	ldr	r1, [r3, #0]
 80026a0:	0612      	lsls	r2, r2, #24
 80026a2:	430a      	orrs	r2, r1
 80026a4:	601a      	str	r2, [r3, #0]
    vPortSetupTimerInterrupt();
 80026a6:	f7ff ffd7 	bl	8002658 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 80026aa:	4b06      	ldr	r3, [pc, #24]	; (80026c4 <xPortStartScheduler+0x38>)
 80026ac:	601c      	str	r4, [r3, #0]
    vPortStartFirstTask();
 80026ae:	f7ff ff3f 	bl	8002530 <vPortStartFirstTask>
    vTaskSwitchContext();
 80026b2:	f7ff fc71 	bl	8001f98 <vTaskSwitchContext>
    prvTaskExitError();
 80026b6:	f7ff ff27 	bl	8002508 <prvTaskExitError>
}
 80026ba:	0020      	movs	r0, r4
 80026bc:	bd10      	pop	{r4, pc}
 80026be:	46c0      	nop			; (mov r8, r8)
 80026c0:	e000ed20 	.word	0xe000ed20
 80026c4:	2000000c 	.word	0x2000000c

080026c8 <prvInsertBlockIntoFreeList>:
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
 80026c8:	b510      	push	{r4, lr}
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80026ca:	4b0f      	ldr	r3, [pc, #60]	; (8002708 <prvInsertBlockIntoFreeList+0x40>)
 80026cc:	001a      	movs	r2, r3
 80026ce:	681b      	ldr	r3, [r3, #0]
 80026d0:	4283      	cmp	r3, r0
 80026d2:	d3fb      	bcc.n	80026cc <prvInsertBlockIntoFreeList+0x4>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80026d4:	6854      	ldr	r4, [r2, #4]
 80026d6:	1911      	adds	r1, r2, r4
 80026d8:	4288      	cmp	r0, r1
 80026da:	d103      	bne.n	80026e4 <prvInsertBlockIntoFreeList+0x1c>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80026dc:	6841      	ldr	r1, [r0, #4]
 80026de:	0010      	movs	r0, r2
 80026e0:	1909      	adds	r1, r1, r4
 80026e2:	6051      	str	r1, [r2, #4]

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80026e4:	6841      	ldr	r1, [r0, #4]
 80026e6:	1844      	adds	r4, r0, r1
 80026e8:	42a3      	cmp	r3, r4
 80026ea:	d107      	bne.n	80026fc <prvInsertBlockIntoFreeList+0x34>
    {
        if( pxIterator->pxNextFreeBlock != pxEnd )
 80026ec:	4c07      	ldr	r4, [pc, #28]	; (800270c <prvInsertBlockIntoFreeList+0x44>)
 80026ee:	6824      	ldr	r4, [r4, #0]
 80026f0:	42a3      	cmp	r3, r4
 80026f2:	d003      	beq.n	80026fc <prvInsertBlockIntoFreeList+0x34>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80026f4:	685c      	ldr	r4, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80026f6:	681b      	ldr	r3, [r3, #0]
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80026f8:	1861      	adds	r1, r4, r1
 80026fa:	6041      	str	r1, [r0, #4]
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80026fc:	6003      	str	r3, [r0, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 80026fe:	4290      	cmp	r0, r2
 8002700:	d000      	beq.n	8002704 <prvInsertBlockIntoFreeList+0x3c>
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8002702:	6010      	str	r0, [r2, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
 8002704:	bd10      	pop	{r4, pc}
 8002706:	46c0      	nop			; (mov r8, r8)
 8002708:	20000760 	.word	0x20000760
 800270c:	2000016c 	.word	0x2000016c

08002710 <pvPortMalloc>:
{
 8002710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002712:	0004      	movs	r4, r0
    vTaskSuspendAll();
 8002714:	f7ff fb6e 	bl	8001df4 <vTaskSuspendAll>
        if( pxEnd == NULL )
 8002718:	4a3a      	ldr	r2, [pc, #232]	; (8002804 <pvPortMalloc+0xf4>)
 800271a:	4d3b      	ldr	r5, [pc, #236]	; (8002808 <pvPortMalloc+0xf8>)
 800271c:	6813      	ldr	r3, [r2, #0]
 800271e:	2b00      	cmp	r3, #0
 8002720:	d11b      	bne.n	800275a <pvPortMalloc+0x4a>
    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8002722:	2007      	movs	r0, #7
    uxAddress = ( size_t ) ucHeap;
 8002724:	4b39      	ldr	r3, [pc, #228]	; (800280c <pvPortMalloc+0xfc>)
    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8002726:	0019      	movs	r1, r3
 8002728:	4203      	tst	r3, r0
 800272a:	d001      	beq.n	8002730 <pvPortMalloc+0x20>
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800272c:	1819      	adds	r1, r3, r0
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800272e:	4381      	bics	r1, r0
    xStart.xBlockSize = ( size_t ) 0;
 8002730:	2000      	movs	r0, #0
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002732:	4e37      	ldr	r6, [pc, #220]	; (8002810 <pvPortMalloc+0x100>)
    xStart.xBlockSize = ( size_t ) 0;
 8002734:	6070      	str	r0, [r6, #4]
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002736:	6031      	str	r1, [r6, #0]
    uxAddress -= xHeapStructSize;
 8002738:	4e36      	ldr	r6, [pc, #216]	; (8002814 <pvPortMalloc+0x104>)
 800273a:	199b      	adds	r3, r3, r6
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800273c:	2607      	movs	r6, #7
 800273e:	43b3      	bics	r3, r6
    pxEnd->pxNextFreeBlock = NULL;
 8002740:	6018      	str	r0, [r3, #0]
    pxEnd->xBlockSize = 0;
 8002742:	6058      	str	r0, [r3, #4]
    pxEnd = ( void * ) uxAddress;
 8002744:	6013      	str	r3, [r2, #0]
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8002746:	1a58      	subs	r0, r3, r1
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8002748:	600b      	str	r3, [r1, #0]
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800274a:	4b33      	ldr	r3, [pc, #204]	; (8002818 <pvPortMalloc+0x108>)
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800274c:	6048      	str	r0, [r1, #4]
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800274e:	6018      	str	r0, [r3, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002750:	4b32      	ldr	r3, [pc, #200]	; (800281c <pvPortMalloc+0x10c>)
 8002752:	6018      	str	r0, [r3, #0]
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8002754:	2380      	movs	r3, #128	; 0x80
 8002756:	061b      	lsls	r3, r3, #24
 8002758:	602b      	str	r3, [r5, #0]
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800275a:	682e      	ldr	r6, [r5, #0]
 800275c:	0025      	movs	r5, r4
 800275e:	4035      	ands	r5, r6
 8002760:	4234      	tst	r4, r6
 8002762:	d14b      	bne.n	80027fc <pvPortMalloc+0xec>
            if( ( xWantedSize > 0 ) && 
 8002764:	1e63      	subs	r3, r4, #1
 8002766:	330a      	adds	r3, #10
 8002768:	d80a      	bhi.n	8002780 <pvPortMalloc+0x70>
                xWantedSize += xHeapStructSize;
 800276a:	0023      	movs	r3, r4
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800276c:	2107      	movs	r1, #7
                xWantedSize += xHeapStructSize;
 800276e:	3308      	adds	r3, #8
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8002770:	420b      	tst	r3, r1
 8002772:	d03f      	beq.n	80027f4 <pvPortMalloc+0xe4>
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) 
 8002774:	0018      	movs	r0, r3
 8002776:	4388      	bics	r0, r1
 8002778:	0001      	movs	r1, r0
 800277a:	3108      	adds	r1, #8
 800277c:	4299      	cmp	r1, r3
 800277e:	d838      	bhi.n	80027f2 <pvPortMalloc+0xe2>
    ( void ) xTaskResumeAll();
 8002780:	f7ff fba8 	bl	8001ed4 <xTaskResumeAll>
    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8002784:	076b      	lsls	r3, r5, #29
 8002786:	d03b      	beq.n	8002800 <pvPortMalloc+0xf0>
 8002788:	b672      	cpsid	i
 800278a:	e7fe      	b.n	800278a <pvPortMalloc+0x7a>
                pxBlock = xStart.pxNextFreeBlock;
 800278c:	4920      	ldr	r1, [pc, #128]	; (8002810 <pvPortMalloc+0x100>)
 800278e:	680c      	ldr	r4, [r1, #0]
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8002790:	6860      	ldr	r0, [r4, #4]
 8002792:	4298      	cmp	r0, r3
 8002794:	d203      	bcs.n	800279e <pvPortMalloc+0x8e>
 8002796:	6827      	ldr	r7, [r4, #0]
 8002798:	46bc      	mov	ip, r7
 800279a:	2f00      	cmp	r7, #0
 800279c:	d10e      	bne.n	80027bc <pvPortMalloc+0xac>
                if( pxBlock != pxEnd )
 800279e:	6812      	ldr	r2, [r2, #0]
 80027a0:	42a2      	cmp	r2, r4
 80027a2:	d02b      	beq.n	80027fc <pvPortMalloc+0xec>
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80027a4:	680a      	ldr	r2, [r1, #0]
 80027a6:	0017      	movs	r7, r2
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80027a8:	6822      	ldr	r2, [r4, #0]
 80027aa:	600a      	str	r2, [r1, #0]
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80027ac:	1ac2      	subs	r2, r0, r3
 80027ae:	2a10      	cmp	r2, #16
 80027b0:	d90b      	bls.n	80027ca <pvPortMalloc+0xba>
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80027b2:	18e0      	adds	r0, r4, r3
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80027b4:	0741      	lsls	r1, r0, #29
 80027b6:	d004      	beq.n	80027c2 <pvPortMalloc+0xb2>
 80027b8:	b672      	cpsid	i
 80027ba:	e7fe      	b.n	80027ba <pvPortMalloc+0xaa>
 80027bc:	0021      	movs	r1, r4
 80027be:	4664      	mov	r4, ip
 80027c0:	e7e6      	b.n	8002790 <pvPortMalloc+0x80>
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80027c2:	6042      	str	r2, [r0, #4]
                        pxBlock->xBlockSize = xWantedSize;
 80027c4:	6063      	str	r3, [r4, #4]
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
 80027c6:	f7ff ff7f 	bl	80026c8 <prvInsertBlockIntoFreeList>
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 80027ca:	6863      	ldr	r3, [r4, #4]
 80027cc:	4a13      	ldr	r2, [pc, #76]	; (800281c <pvPortMalloc+0x10c>)
 80027ce:	1aed      	subs	r5, r5, r3
 80027d0:	6015      	str	r5, [r2, #0]
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80027d2:	4a11      	ldr	r2, [pc, #68]	; (8002818 <pvPortMalloc+0x108>)
 80027d4:	6811      	ldr	r1, [r2, #0]
 80027d6:	428d      	cmp	r5, r1
 80027d8:	d200      	bcs.n	80027dc <pvPortMalloc+0xcc>
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80027da:	6015      	str	r5, [r2, #0]
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 80027dc:	431e      	orrs	r6, r3
                    pxBlock->pxNextFreeBlock = NULL;
 80027de:	2300      	movs	r3, #0
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80027e0:	003d      	movs	r5, r7
                    xNumberOfSuccessfulAllocations++;
 80027e2:	4a0f      	ldr	r2, [pc, #60]	; (8002820 <pvPortMalloc+0x110>)
                    pxBlock->pxNextFreeBlock = NULL;
 80027e4:	6023      	str	r3, [r4, #0]
                    xNumberOfSuccessfulAllocations++;
 80027e6:	6813      	ldr	r3, [r2, #0]
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80027e8:	3508      	adds	r5, #8
                    xNumberOfSuccessfulAllocations++;
 80027ea:	3301      	adds	r3, #1
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 80027ec:	6066      	str	r6, [r4, #4]
                    xNumberOfSuccessfulAllocations++;
 80027ee:	6013      	str	r3, [r2, #0]
 80027f0:	e7c6      	b.n	8002780 <pvPortMalloc+0x70>
 80027f2:	000b      	movs	r3, r1
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 80027f4:	4909      	ldr	r1, [pc, #36]	; (800281c <pvPortMalloc+0x10c>)
 80027f6:	680d      	ldr	r5, [r1, #0]
 80027f8:	429d      	cmp	r5, r3
 80027fa:	d2c7      	bcs.n	800278c <pvPortMalloc+0x7c>
    void * pvReturn = NULL;
 80027fc:	2500      	movs	r5, #0
 80027fe:	e7bf      	b.n	8002780 <pvPortMalloc+0x70>
}
 8002800:	0028      	movs	r0, r5
 8002802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002804:	2000016c 	.word	0x2000016c
 8002808:	2000074c 	.word	0x2000074c
 800280c:	20000170 	.word	0x20000170
 8002810:	20000760 	.word	0x20000760
 8002814:	000005d4 	.word	0x000005d4
 8002818:	20000754 	.word	0x20000754
 800281c:	20000750 	.word	0x20000750
 8002820:	20000758 	.word	0x20000758

08002824 <vPortFree>:
{
 8002824:	b510      	push	{r4, lr}
    if( pv != NULL )
 8002826:	2800      	cmp	r0, #0
 8002828:	d01f      	beq.n	800286a <vPortFree+0x46>
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800282a:	4a10      	ldr	r2, [pc, #64]	; (800286c <vPortFree+0x48>)
 800282c:	3808      	subs	r0, #8
 800282e:	6843      	ldr	r3, [r0, #4]
 8002830:	6812      	ldr	r2, [r2, #0]
 8002832:	0004      	movs	r4, r0
 8002834:	421a      	tst	r2, r3
 8002836:	d101      	bne.n	800283c <vPortFree+0x18>
 8002838:	b672      	cpsid	i
 800283a:	e7fe      	b.n	800283a <vPortFree+0x16>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 800283c:	6801      	ldr	r1, [r0, #0]
 800283e:	2900      	cmp	r1, #0
 8002840:	d001      	beq.n	8002846 <vPortFree+0x22>
 8002842:	b672      	cpsid	i
 8002844:	e7fe      	b.n	8002844 <vPortFree+0x20>
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8002846:	4393      	bics	r3, r2
 8002848:	6043      	str	r3, [r0, #4]
                vTaskSuspendAll();
 800284a:	f7ff fad3 	bl	8001df4 <vTaskSuspendAll>
                    xFreeBytesRemaining += pxLink->xBlockSize;
 800284e:	4a08      	ldr	r2, [pc, #32]	; (8002870 <vPortFree+0x4c>)
 8002850:	6863      	ldr	r3, [r4, #4]
 8002852:	6811      	ldr	r1, [r2, #0]
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002854:	0020      	movs	r0, r4
                    xFreeBytesRemaining += pxLink->xBlockSize;
 8002856:	185b      	adds	r3, r3, r1
 8002858:	6013      	str	r3, [r2, #0]
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800285a:	f7ff ff35 	bl	80026c8 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
 800285e:	4a05      	ldr	r2, [pc, #20]	; (8002874 <vPortFree+0x50>)
 8002860:	6813      	ldr	r3, [r2, #0]
 8002862:	3301      	adds	r3, #1
 8002864:	6013      	str	r3, [r2, #0]
                ( void ) xTaskResumeAll();
 8002866:	f7ff fb35 	bl	8001ed4 <xTaskResumeAll>
}
 800286a:	bd10      	pop	{r4, pc}
 800286c:	2000074c 	.word	0x2000074c
 8002870:	20000750 	.word	0x20000750
 8002874:	2000075c 	.word	0x2000075c

08002878 <__libc_init_array>:
 8002878:	b570      	push	{r4, r5, r6, lr}
 800287a:	2600      	movs	r6, #0
 800287c:	4d0c      	ldr	r5, [pc, #48]	; (80028b0 <__libc_init_array+0x38>)
 800287e:	4c0d      	ldr	r4, [pc, #52]	; (80028b4 <__libc_init_array+0x3c>)
 8002880:	1b64      	subs	r4, r4, r5
 8002882:	10a4      	asrs	r4, r4, #2
 8002884:	42a6      	cmp	r6, r4
 8002886:	d109      	bne.n	800289c <__libc_init_array+0x24>
 8002888:	2600      	movs	r6, #0
 800288a:	f000 f82b 	bl	80028e4 <_init>
 800288e:	4d0a      	ldr	r5, [pc, #40]	; (80028b8 <__libc_init_array+0x40>)
 8002890:	4c0a      	ldr	r4, [pc, #40]	; (80028bc <__libc_init_array+0x44>)
 8002892:	1b64      	subs	r4, r4, r5
 8002894:	10a4      	asrs	r4, r4, #2
 8002896:	42a6      	cmp	r6, r4
 8002898:	d105      	bne.n	80028a6 <__libc_init_array+0x2e>
 800289a:	bd70      	pop	{r4, r5, r6, pc}
 800289c:	00b3      	lsls	r3, r6, #2
 800289e:	58eb      	ldr	r3, [r5, r3]
 80028a0:	4798      	blx	r3
 80028a2:	3601      	adds	r6, #1
 80028a4:	e7ee      	b.n	8002884 <__libc_init_array+0xc>
 80028a6:	00b3      	lsls	r3, r6, #2
 80028a8:	58eb      	ldr	r3, [r5, r3]
 80028aa:	4798      	blx	r3
 80028ac:	3601      	adds	r6, #1
 80028ae:	e7f2      	b.n	8002896 <__libc_init_array+0x1e>
 80028b0:	08002954 	.word	0x08002954
 80028b4:	08002954 	.word	0x08002954
 80028b8:	08002954 	.word	0x08002954
 80028bc:	08002958 	.word	0x08002958

080028c0 <memcpy>:
 80028c0:	2300      	movs	r3, #0
 80028c2:	b510      	push	{r4, lr}
 80028c4:	429a      	cmp	r2, r3
 80028c6:	d100      	bne.n	80028ca <memcpy+0xa>
 80028c8:	bd10      	pop	{r4, pc}
 80028ca:	5ccc      	ldrb	r4, [r1, r3]
 80028cc:	54c4      	strb	r4, [r0, r3]
 80028ce:	3301      	adds	r3, #1
 80028d0:	e7f8      	b.n	80028c4 <memcpy+0x4>

080028d2 <memset>:
 80028d2:	0003      	movs	r3, r0
 80028d4:	1882      	adds	r2, r0, r2
 80028d6:	4293      	cmp	r3, r2
 80028d8:	d100      	bne.n	80028dc <memset+0xa>
 80028da:	4770      	bx	lr
 80028dc:	7019      	strb	r1, [r3, #0]
 80028de:	3301      	adds	r3, #1
 80028e0:	e7f9      	b.n	80028d6 <memset+0x4>
	...

080028e4 <_init>:
 80028e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80028e6:	46c0      	nop			; (mov r8, r8)
 80028e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80028ea:	bc08      	pop	{r3}
 80028ec:	469e      	mov	lr, r3
 80028ee:	4770      	bx	lr

080028f0 <_fini>:
 80028f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80028f2:	46c0      	nop			; (mov r8, r8)
 80028f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80028f6:	bc08      	pop	{r3}
 80028f8:	469e      	mov	lr, r3
 80028fa:	4770      	bx	lr
